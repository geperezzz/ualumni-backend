
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model JobOffer
 * 
 */
export type JobOffer = $Result.DefaultSelection<Prisma.$JobOfferPayload>
/**
 * Model JobOfferTechnicalSkill
 * 
 */
export type JobOfferTechnicalSkill = $Result.DefaultSelection<Prisma.$JobOfferTechnicalSkillPayload>
/**
 * Model ContractType
 * 
 */
export type ContractType = $Result.DefaultSelection<Prisma.$ContractTypePayload>
/**
 * Model Career
 * 
 */
export type Career = $Result.DefaultSelection<Prisma.$CareerPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Alumni
 * 
 */
export type Alumni = $Result.DefaultSelection<Prisma.$AlumniPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Graduation
 * 
 */
export type Graduation = $Result.DefaultSelection<Prisma.$GraduationPayload>
/**
 * Model JobApplication
 * 
 */
export type JobApplication = $Result.DefaultSelection<Prisma.$JobApplicationPayload>
/**
 * Model Resume
 * 
 */
export type Resume = $Result.DefaultSelection<Prisma.$ResumePayload>
/**
 * Model CiapCourse
 * 
 */
export type CiapCourse = $Result.DefaultSelection<Prisma.$CiapCoursePayload>
/**
 * Model ResumeCiapCourse
 * 
 */
export type ResumeCiapCourse = $Result.DefaultSelection<Prisma.$ResumeCiapCoursePayload>
/**
 * Model SoftSkill
 * 
 */
export type SoftSkill = $Result.DefaultSelection<Prisma.$SoftSkillPayload>
/**
 * Model ResumeSoftSkill
 * 
 */
export type ResumeSoftSkill = $Result.DefaultSelection<Prisma.$ResumeSoftSkillPayload>
/**
 * Model SkillCategory
 * 
 */
export type SkillCategory = $Result.DefaultSelection<Prisma.$SkillCategoryPayload>
/**
 * Model TechnicalSkill
 * 
 */
export type TechnicalSkill = $Result.DefaultSelection<Prisma.$TechnicalSkillPayload>
/**
 * Model ResumeTechnicalSkill
 * 
 */
export type ResumeTechnicalSkill = $Result.DefaultSelection<Prisma.$ResumeTechnicalSkillPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model ResumeLanguage
 * 
 */
export type ResumeLanguage = $Result.DefaultSelection<Prisma.$ResumeLanguagePayload>
/**
 * Model PortfolioItem
 * 
 */
export type PortfolioItem = $Result.DefaultSelection<Prisma.$PortfolioItemPayload>
/**
 * Model HigherEducationStudy
 * 
 */
export type HigherEducationStudy = $Result.DefaultSelection<Prisma.$HigherEducationStudyPayload>
/**
 * Model PositionOfInterest
 * 
 */
export type PositionOfInterest = $Result.DefaultSelection<Prisma.$PositionOfInterestPayload>
/**
 * Model IndustryOfInterest
 * 
 */
export type IndustryOfInterest = $Result.DefaultSelection<Prisma.$IndustryOfInterestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  ALUMNI: 'ALUMNI'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more JobOffers
 * const jobOffers = await prisma.jobOffer.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more JobOffers
   * const jobOffers = await prisma.jobOffer.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.jobOffer`: Exposes CRUD operations for the **JobOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobOffers
    * const jobOffers = await prisma.jobOffer.findMany()
    * ```
    */
  get jobOffer(): Prisma.JobOfferDelegate<ExtArgs>;

  /**
   * `prisma.jobOfferTechnicalSkill`: Exposes CRUD operations for the **JobOfferTechnicalSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobOfferTechnicalSkills
    * const jobOfferTechnicalSkills = await prisma.jobOfferTechnicalSkill.findMany()
    * ```
    */
  get jobOfferTechnicalSkill(): Prisma.JobOfferTechnicalSkillDelegate<ExtArgs>;

  /**
   * `prisma.contractType`: Exposes CRUD operations for the **ContractType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractTypes
    * const contractTypes = await prisma.contractType.findMany()
    * ```
    */
  get contractType(): Prisma.ContractTypeDelegate<ExtArgs>;

  /**
   * `prisma.career`: Exposes CRUD operations for the **Career** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Careers
    * const careers = await prisma.career.findMany()
    * ```
    */
  get career(): Prisma.CareerDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.alumni`: Exposes CRUD operations for the **Alumni** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alumni
    * const alumni = await prisma.alumni.findMany()
    * ```
    */
  get alumni(): Prisma.AlumniDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.graduation`: Exposes CRUD operations for the **Graduation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Graduations
    * const graduations = await prisma.graduation.findMany()
    * ```
    */
  get graduation(): Prisma.GraduationDelegate<ExtArgs>;

  /**
   * `prisma.jobApplication`: Exposes CRUD operations for the **JobApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobApplications
    * const jobApplications = await prisma.jobApplication.findMany()
    * ```
    */
  get jobApplication(): Prisma.JobApplicationDelegate<ExtArgs>;

  /**
   * `prisma.resume`: Exposes CRUD operations for the **Resume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resumes
    * const resumes = await prisma.resume.findMany()
    * ```
    */
  get resume(): Prisma.ResumeDelegate<ExtArgs>;

  /**
   * `prisma.ciapCourse`: Exposes CRUD operations for the **CiapCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CiapCourses
    * const ciapCourses = await prisma.ciapCourse.findMany()
    * ```
    */
  get ciapCourse(): Prisma.CiapCourseDelegate<ExtArgs>;

  /**
   * `prisma.resumeCiapCourse`: Exposes CRUD operations for the **ResumeCiapCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeCiapCourses
    * const resumeCiapCourses = await prisma.resumeCiapCourse.findMany()
    * ```
    */
  get resumeCiapCourse(): Prisma.ResumeCiapCourseDelegate<ExtArgs>;

  /**
   * `prisma.softSkill`: Exposes CRUD operations for the **SoftSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SoftSkills
    * const softSkills = await prisma.softSkill.findMany()
    * ```
    */
  get softSkill(): Prisma.SoftSkillDelegate<ExtArgs>;

  /**
   * `prisma.resumeSoftSkill`: Exposes CRUD operations for the **ResumeSoftSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeSoftSkills
    * const resumeSoftSkills = await prisma.resumeSoftSkill.findMany()
    * ```
    */
  get resumeSoftSkill(): Prisma.ResumeSoftSkillDelegate<ExtArgs>;

  /**
   * `prisma.skillCategory`: Exposes CRUD operations for the **SkillCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillCategories
    * const skillCategories = await prisma.skillCategory.findMany()
    * ```
    */
  get skillCategory(): Prisma.SkillCategoryDelegate<ExtArgs>;

  /**
   * `prisma.technicalSkill`: Exposes CRUD operations for the **TechnicalSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicalSkills
    * const technicalSkills = await prisma.technicalSkill.findMany()
    * ```
    */
  get technicalSkill(): Prisma.TechnicalSkillDelegate<ExtArgs>;

  /**
   * `prisma.resumeTechnicalSkill`: Exposes CRUD operations for the **ResumeTechnicalSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeTechnicalSkills
    * const resumeTechnicalSkills = await prisma.resumeTechnicalSkill.findMany()
    * ```
    */
  get resumeTechnicalSkill(): Prisma.ResumeTechnicalSkillDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs>;

  /**
   * `prisma.resumeLanguage`: Exposes CRUD operations for the **ResumeLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeLanguages
    * const resumeLanguages = await prisma.resumeLanguage.findMany()
    * ```
    */
  get resumeLanguage(): Prisma.ResumeLanguageDelegate<ExtArgs>;

  /**
   * `prisma.portfolioItem`: Exposes CRUD operations for the **PortfolioItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioItems
    * const portfolioItems = await prisma.portfolioItem.findMany()
    * ```
    */
  get portfolioItem(): Prisma.PortfolioItemDelegate<ExtArgs>;

  /**
   * `prisma.higherEducationStudy`: Exposes CRUD operations for the **HigherEducationStudy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HigherEducationStudies
    * const higherEducationStudies = await prisma.higherEducationStudy.findMany()
    * ```
    */
  get higherEducationStudy(): Prisma.HigherEducationStudyDelegate<ExtArgs>;

  /**
   * `prisma.positionOfInterest`: Exposes CRUD operations for the **PositionOfInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PositionOfInterests
    * const positionOfInterests = await prisma.positionOfInterest.findMany()
    * ```
    */
  get positionOfInterest(): Prisma.PositionOfInterestDelegate<ExtArgs>;

  /**
   * `prisma.industryOfInterest`: Exposes CRUD operations for the **IndustryOfInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndustryOfInterests
    * const industryOfInterests = await prisma.industryOfInterest.findMany()
    * ```
    */
  get industryOfInterest(): Prisma.IndustryOfInterestDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.6.0
   * Query Engine version: e95e739751f42d8ca026f6b910f5a2dc5adeaeee
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    JobOffer: 'JobOffer',
    JobOfferTechnicalSkill: 'JobOfferTechnicalSkill',
    ContractType: 'ContractType',
    Career: 'Career',
    User: 'User',
    Alumni: 'Alumni',
    Session: 'Session',
    Graduation: 'Graduation',
    JobApplication: 'JobApplication',
    Resume: 'Resume',
    CiapCourse: 'CiapCourse',
    ResumeCiapCourse: 'ResumeCiapCourse',
    SoftSkill: 'SoftSkill',
    ResumeSoftSkill: 'ResumeSoftSkill',
    SkillCategory: 'SkillCategory',
    TechnicalSkill: 'TechnicalSkill',
    ResumeTechnicalSkill: 'ResumeTechnicalSkill',
    Language: 'Language',
    ResumeLanguage: 'ResumeLanguage',
    PortfolioItem: 'PortfolioItem',
    HigherEducationStudy: 'HigherEducationStudy',
    PositionOfInterest: 'PositionOfInterest',
    IndustryOfInterest: 'IndustryOfInterest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'jobOffer' | 'jobOfferTechnicalSkill' | 'contractType' | 'career' | 'user' | 'alumni' | 'session' | 'graduation' | 'jobApplication' | 'resume' | 'ciapCourse' | 'resumeCiapCourse' | 'softSkill' | 'resumeSoftSkill' | 'skillCategory' | 'technicalSkill' | 'resumeTechnicalSkill' | 'language' | 'resumeLanguage' | 'portfolioItem' | 'higherEducationStudy' | 'positionOfInterest' | 'industryOfInterest'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      JobOffer: {
        payload: Prisma.$JobOfferPayload<ExtArgs>
        fields: Prisma.JobOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobOfferFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobOfferFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload>
          }
          findFirst: {
            args: Prisma.JobOfferFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobOfferFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload>
          }
          findMany: {
            args: Prisma.JobOfferFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload>[]
          }
          create: {
            args: Prisma.JobOfferCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload>
          }
          createMany: {
            args: Prisma.JobOfferCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobOfferDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload>
          }
          update: {
            args: Prisma.JobOfferUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload>
          }
          deleteMany: {
            args: Prisma.JobOfferDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobOfferUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobOfferUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferPayload>
          }
          aggregate: {
            args: Prisma.JobOfferAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobOffer>
          }
          groupBy: {
            args: Prisma.JobOfferGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobOfferCountArgs<ExtArgs>,
            result: $Utils.Optional<JobOfferCountAggregateOutputType> | number
          }
        }
      }
      JobOfferTechnicalSkill: {
        payload: Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>
        fields: Prisma.JobOfferTechnicalSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobOfferTechnicalSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobOfferTechnicalSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload>
          }
          findFirst: {
            args: Prisma.JobOfferTechnicalSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobOfferTechnicalSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload>
          }
          findMany: {
            args: Prisma.JobOfferTechnicalSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload>[]
          }
          create: {
            args: Prisma.JobOfferTechnicalSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload>
          }
          createMany: {
            args: Prisma.JobOfferTechnicalSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobOfferTechnicalSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload>
          }
          update: {
            args: Prisma.JobOfferTechnicalSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload>
          }
          deleteMany: {
            args: Prisma.JobOfferTechnicalSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobOfferTechnicalSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobOfferTechnicalSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobOfferTechnicalSkillPayload>
          }
          aggregate: {
            args: Prisma.JobOfferTechnicalSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobOfferTechnicalSkill>
          }
          groupBy: {
            args: Prisma.JobOfferTechnicalSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobOfferTechnicalSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobOfferTechnicalSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<JobOfferTechnicalSkillCountAggregateOutputType> | number
          }
        }
      }
      ContractType: {
        payload: Prisma.$ContractTypePayload<ExtArgs>
        fields: Prisma.ContractTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload>
          }
          findFirst: {
            args: Prisma.ContractTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload>
          }
          findMany: {
            args: Prisma.ContractTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload>[]
          }
          create: {
            args: Prisma.ContractTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload>
          }
          createMany: {
            args: Prisma.ContractTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContractTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload>
          }
          update: {
            args: Prisma.ContractTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload>
          }
          deleteMany: {
            args: Prisma.ContractTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContractTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContractTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContractTypePayload>
          }
          aggregate: {
            args: Prisma.ContractTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContractType>
          }
          groupBy: {
            args: Prisma.ContractTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContractTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<ContractTypeCountAggregateOutputType> | number
          }
        }
      }
      Career: {
        payload: Prisma.$CareerPayload<ExtArgs>
        fields: Prisma.CareerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          findFirst: {
            args: Prisma.CareerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          findMany: {
            args: Prisma.CareerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>[]
          }
          create: {
            args: Prisma.CareerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          createMany: {
            args: Prisma.CareerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CareerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          update: {
            args: Prisma.CareerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          deleteMany: {
            args: Prisma.CareerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CareerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CareerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          aggregate: {
            args: Prisma.CareerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCareer>
          }
          groupBy: {
            args: Prisma.CareerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CareerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareerCountArgs<ExtArgs>,
            result: $Utils.Optional<CareerCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Alumni: {
        payload: Prisma.$AlumniPayload<ExtArgs>
        fields: Prisma.AlumniFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlumniFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlumniFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload>
          }
          findFirst: {
            args: Prisma.AlumniFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlumniFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload>
          }
          findMany: {
            args: Prisma.AlumniFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload>[]
          }
          create: {
            args: Prisma.AlumniCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload>
          }
          createMany: {
            args: Prisma.AlumniCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AlumniDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload>
          }
          update: {
            args: Prisma.AlumniUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload>
          }
          deleteMany: {
            args: Prisma.AlumniDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AlumniUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AlumniUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlumniPayload>
          }
          aggregate: {
            args: Prisma.AlumniAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAlumni>
          }
          groupBy: {
            args: Prisma.AlumniGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AlumniGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlumniCountArgs<ExtArgs>,
            result: $Utils.Optional<AlumniCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Graduation: {
        payload: Prisma.$GraduationPayload<ExtArgs>
        fields: Prisma.GraduationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GraduationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GraduationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload>
          }
          findFirst: {
            args: Prisma.GraduationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GraduationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload>
          }
          findMany: {
            args: Prisma.GraduationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload>[]
          }
          create: {
            args: Prisma.GraduationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload>
          }
          createMany: {
            args: Prisma.GraduationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GraduationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload>
          }
          update: {
            args: Prisma.GraduationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload>
          }
          deleteMany: {
            args: Prisma.GraduationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GraduationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GraduationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GraduationPayload>
          }
          aggregate: {
            args: Prisma.GraduationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGraduation>
          }
          groupBy: {
            args: Prisma.GraduationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GraduationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GraduationCountArgs<ExtArgs>,
            result: $Utils.Optional<GraduationCountAggregateOutputType> | number
          }
        }
      }
      JobApplication: {
        payload: Prisma.$JobApplicationPayload<ExtArgs>
        fields: Prisma.JobApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobApplicationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobApplicationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findFirst: {
            args: Prisma.JobApplicationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobApplicationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findMany: {
            args: Prisma.JobApplicationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          create: {
            args: Prisma.JobApplicationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          createMany: {
            args: Prisma.JobApplicationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobApplicationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          update: {
            args: Prisma.JobApplicationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          deleteMany: {
            args: Prisma.JobApplicationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobApplicationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobApplicationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          aggregate: {
            args: Prisma.JobApplicationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobApplication>
          }
          groupBy: {
            args: Prisma.JobApplicationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobApplicationCountArgs<ExtArgs>,
            result: $Utils.Optional<JobApplicationCountAggregateOutputType> | number
          }
        }
      }
      Resume: {
        payload: Prisma.$ResumePayload<ExtArgs>
        fields: Prisma.ResumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          findFirst: {
            args: Prisma.ResumeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          findMany: {
            args: Prisma.ResumeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          create: {
            args: Prisma.ResumeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          createMany: {
            args: Prisma.ResumeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResumeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          update: {
            args: Prisma.ResumeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          deleteMany: {
            args: Prisma.ResumeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResumeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          aggregate: {
            args: Prisma.ResumeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResume>
          }
          groupBy: {
            args: Prisma.ResumeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeCountArgs<ExtArgs>,
            result: $Utils.Optional<ResumeCountAggregateOutputType> | number
          }
        }
      }
      CiapCourse: {
        payload: Prisma.$CiapCoursePayload<ExtArgs>
        fields: Prisma.CiapCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CiapCourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CiapCourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload>
          }
          findFirst: {
            args: Prisma.CiapCourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CiapCourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload>
          }
          findMany: {
            args: Prisma.CiapCourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload>[]
          }
          create: {
            args: Prisma.CiapCourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload>
          }
          createMany: {
            args: Prisma.CiapCourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CiapCourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload>
          }
          update: {
            args: Prisma.CiapCourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload>
          }
          deleteMany: {
            args: Prisma.CiapCourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CiapCourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CiapCourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CiapCoursePayload>
          }
          aggregate: {
            args: Prisma.CiapCourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCiapCourse>
          }
          groupBy: {
            args: Prisma.CiapCourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CiapCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CiapCourseCountArgs<ExtArgs>,
            result: $Utils.Optional<CiapCourseCountAggregateOutputType> | number
          }
        }
      }
      ResumeCiapCourse: {
        payload: Prisma.$ResumeCiapCoursePayload<ExtArgs>
        fields: Prisma.ResumeCiapCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeCiapCourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeCiapCourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload>
          }
          findFirst: {
            args: Prisma.ResumeCiapCourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeCiapCourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload>
          }
          findMany: {
            args: Prisma.ResumeCiapCourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload>[]
          }
          create: {
            args: Prisma.ResumeCiapCourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload>
          }
          createMany: {
            args: Prisma.ResumeCiapCourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResumeCiapCourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload>
          }
          update: {
            args: Prisma.ResumeCiapCourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload>
          }
          deleteMany: {
            args: Prisma.ResumeCiapCourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeCiapCourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResumeCiapCourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeCiapCoursePayload>
          }
          aggregate: {
            args: Prisma.ResumeCiapCourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResumeCiapCourse>
          }
          groupBy: {
            args: Prisma.ResumeCiapCourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResumeCiapCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeCiapCourseCountArgs<ExtArgs>,
            result: $Utils.Optional<ResumeCiapCourseCountAggregateOutputType> | number
          }
        }
      }
      SoftSkill: {
        payload: Prisma.$SoftSkillPayload<ExtArgs>
        fields: Prisma.SoftSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoftSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoftSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload>
          }
          findFirst: {
            args: Prisma.SoftSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoftSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload>
          }
          findMany: {
            args: Prisma.SoftSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload>[]
          }
          create: {
            args: Prisma.SoftSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload>
          }
          createMany: {
            args: Prisma.SoftSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SoftSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload>
          }
          update: {
            args: Prisma.SoftSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload>
          }
          deleteMany: {
            args: Prisma.SoftSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SoftSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SoftSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SoftSkillPayload>
          }
          aggregate: {
            args: Prisma.SoftSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSoftSkill>
          }
          groupBy: {
            args: Prisma.SoftSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SoftSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoftSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<SoftSkillCountAggregateOutputType> | number
          }
        }
      }
      ResumeSoftSkill: {
        payload: Prisma.$ResumeSoftSkillPayload<ExtArgs>
        fields: Prisma.ResumeSoftSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeSoftSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeSoftSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload>
          }
          findFirst: {
            args: Prisma.ResumeSoftSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeSoftSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload>
          }
          findMany: {
            args: Prisma.ResumeSoftSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload>[]
          }
          create: {
            args: Prisma.ResumeSoftSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload>
          }
          createMany: {
            args: Prisma.ResumeSoftSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResumeSoftSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload>
          }
          update: {
            args: Prisma.ResumeSoftSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload>
          }
          deleteMany: {
            args: Prisma.ResumeSoftSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeSoftSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResumeSoftSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeSoftSkillPayload>
          }
          aggregate: {
            args: Prisma.ResumeSoftSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResumeSoftSkill>
          }
          groupBy: {
            args: Prisma.ResumeSoftSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResumeSoftSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeSoftSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<ResumeSoftSkillCountAggregateOutputType> | number
          }
        }
      }
      SkillCategory: {
        payload: Prisma.$SkillCategoryPayload<ExtArgs>
        fields: Prisma.SkillCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload>
          }
          findFirst: {
            args: Prisma.SkillCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload>
          }
          findMany: {
            args: Prisma.SkillCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload>[]
          }
          create: {
            args: Prisma.SkillCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload>
          }
          createMany: {
            args: Prisma.SkillCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SkillCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload>
          }
          update: {
            args: Prisma.SkillCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload>
          }
          deleteMany: {
            args: Prisma.SkillCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SkillCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SkillCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillCategoryPayload>
          }
          aggregate: {
            args: Prisma.SkillCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSkillCategory>
          }
          groupBy: {
            args: Prisma.SkillCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SkillCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<SkillCategoryCountAggregateOutputType> | number
          }
        }
      }
      TechnicalSkill: {
        payload: Prisma.$TechnicalSkillPayload<ExtArgs>
        fields: Prisma.TechnicalSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicalSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicalSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload>
          }
          findFirst: {
            args: Prisma.TechnicalSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicalSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload>
          }
          findMany: {
            args: Prisma.TechnicalSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload>[]
          }
          create: {
            args: Prisma.TechnicalSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload>
          }
          createMany: {
            args: Prisma.TechnicalSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TechnicalSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload>
          }
          update: {
            args: Prisma.TechnicalSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload>
          }
          deleteMany: {
            args: Prisma.TechnicalSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicalSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TechnicalSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TechnicalSkillPayload>
          }
          aggregate: {
            args: Prisma.TechnicalSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTechnicalSkill>
          }
          groupBy: {
            args: Prisma.TechnicalSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TechnicalSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicalSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<TechnicalSkillCountAggregateOutputType> | number
          }
        }
      }
      ResumeTechnicalSkill: {
        payload: Prisma.$ResumeTechnicalSkillPayload<ExtArgs>
        fields: Prisma.ResumeTechnicalSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeTechnicalSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeTechnicalSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload>
          }
          findFirst: {
            args: Prisma.ResumeTechnicalSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeTechnicalSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload>
          }
          findMany: {
            args: Prisma.ResumeTechnicalSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload>[]
          }
          create: {
            args: Prisma.ResumeTechnicalSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload>
          }
          createMany: {
            args: Prisma.ResumeTechnicalSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResumeTechnicalSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload>
          }
          update: {
            args: Prisma.ResumeTechnicalSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload>
          }
          deleteMany: {
            args: Prisma.ResumeTechnicalSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeTechnicalSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResumeTechnicalSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeTechnicalSkillPayload>
          }
          aggregate: {
            args: Prisma.ResumeTechnicalSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResumeTechnicalSkill>
          }
          groupBy: {
            args: Prisma.ResumeTechnicalSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResumeTechnicalSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeTechnicalSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<ResumeTechnicalSkillCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>,
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      ResumeLanguage: {
        payload: Prisma.$ResumeLanguagePayload<ExtArgs>
        fields: Prisma.ResumeLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeLanguageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeLanguageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload>
          }
          findFirst: {
            args: Prisma.ResumeLanguageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeLanguageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload>
          }
          findMany: {
            args: Prisma.ResumeLanguageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload>[]
          }
          create: {
            args: Prisma.ResumeLanguageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload>
          }
          createMany: {
            args: Prisma.ResumeLanguageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResumeLanguageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload>
          }
          update: {
            args: Prisma.ResumeLanguageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload>
          }
          deleteMany: {
            args: Prisma.ResumeLanguageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeLanguageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResumeLanguageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResumeLanguagePayload>
          }
          aggregate: {
            args: Prisma.ResumeLanguageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResumeLanguage>
          }
          groupBy: {
            args: Prisma.ResumeLanguageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResumeLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeLanguageCountArgs<ExtArgs>,
            result: $Utils.Optional<ResumeLanguageCountAggregateOutputType> | number
          }
        }
      }
      PortfolioItem: {
        payload: Prisma.$PortfolioItemPayload<ExtArgs>
        fields: Prisma.PortfolioItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          findFirst: {
            args: Prisma.PortfolioItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          findMany: {
            args: Prisma.PortfolioItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>[]
          }
          create: {
            args: Prisma.PortfolioItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          createMany: {
            args: Prisma.PortfolioItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PortfolioItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          update: {
            args: Prisma.PortfolioItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PortfolioItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PortfolioItemPayload>
          }
          aggregate: {
            args: Prisma.PortfolioItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePortfolioItem>
          }
          groupBy: {
            args: Prisma.PortfolioItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PortfolioItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioItemCountArgs<ExtArgs>,
            result: $Utils.Optional<PortfolioItemCountAggregateOutputType> | number
          }
        }
      }
      HigherEducationStudy: {
        payload: Prisma.$HigherEducationStudyPayload<ExtArgs>
        fields: Prisma.HigherEducationStudyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HigherEducationStudyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HigherEducationStudyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload>
          }
          findFirst: {
            args: Prisma.HigherEducationStudyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HigherEducationStudyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload>
          }
          findMany: {
            args: Prisma.HigherEducationStudyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload>[]
          }
          create: {
            args: Prisma.HigherEducationStudyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload>
          }
          createMany: {
            args: Prisma.HigherEducationStudyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HigherEducationStudyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload>
          }
          update: {
            args: Prisma.HigherEducationStudyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload>
          }
          deleteMany: {
            args: Prisma.HigherEducationStudyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HigherEducationStudyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HigherEducationStudyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HigherEducationStudyPayload>
          }
          aggregate: {
            args: Prisma.HigherEducationStudyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHigherEducationStudy>
          }
          groupBy: {
            args: Prisma.HigherEducationStudyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HigherEducationStudyGroupByOutputType>[]
          }
          count: {
            args: Prisma.HigherEducationStudyCountArgs<ExtArgs>,
            result: $Utils.Optional<HigherEducationStudyCountAggregateOutputType> | number
          }
        }
      }
      PositionOfInterest: {
        payload: Prisma.$PositionOfInterestPayload<ExtArgs>
        fields: Prisma.PositionOfInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionOfInterestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionOfInterestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload>
          }
          findFirst: {
            args: Prisma.PositionOfInterestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionOfInterestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload>
          }
          findMany: {
            args: Prisma.PositionOfInterestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload>[]
          }
          create: {
            args: Prisma.PositionOfInterestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload>
          }
          createMany: {
            args: Prisma.PositionOfInterestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PositionOfInterestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload>
          }
          update: {
            args: Prisma.PositionOfInterestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload>
          }
          deleteMany: {
            args: Prisma.PositionOfInterestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PositionOfInterestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PositionOfInterestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PositionOfInterestPayload>
          }
          aggregate: {
            args: Prisma.PositionOfInterestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePositionOfInterest>
          }
          groupBy: {
            args: Prisma.PositionOfInterestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PositionOfInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionOfInterestCountArgs<ExtArgs>,
            result: $Utils.Optional<PositionOfInterestCountAggregateOutputType> | number
          }
        }
      }
      IndustryOfInterest: {
        payload: Prisma.$IndustryOfInterestPayload<ExtArgs>
        fields: Prisma.IndustryOfInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndustryOfInterestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndustryOfInterestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload>
          }
          findFirst: {
            args: Prisma.IndustryOfInterestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndustryOfInterestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload>
          }
          findMany: {
            args: Prisma.IndustryOfInterestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload>[]
          }
          create: {
            args: Prisma.IndustryOfInterestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload>
          }
          createMany: {
            args: Prisma.IndustryOfInterestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IndustryOfInterestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload>
          }
          update: {
            args: Prisma.IndustryOfInterestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload>
          }
          deleteMany: {
            args: Prisma.IndustryOfInterestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IndustryOfInterestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IndustryOfInterestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IndustryOfInterestPayload>
          }
          aggregate: {
            args: Prisma.IndustryOfInterestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIndustryOfInterest>
          }
          groupBy: {
            args: Prisma.IndustryOfInterestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IndustryOfInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndustryOfInterestCountArgs<ExtArgs>,
            result: $Utils.Optional<IndustryOfInterestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type JobOfferCountOutputType
   */

  export type JobOfferCountOutputType = {
    applications: number
    technicalSkills: number
  }

  export type JobOfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | JobOfferCountOutputTypeCountApplicationsArgs
    technicalSkills?: boolean | JobOfferCountOutputTypeCountTechnicalSkillsArgs
  }

  // Custom InputTypes

  /**
   * JobOfferCountOutputType without action
   */
  export type JobOfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferCountOutputType
     */
    select?: JobOfferCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JobOfferCountOutputType without action
   */
  export type JobOfferCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }


  /**
   * JobOfferCountOutputType without action
   */
  export type JobOfferCountOutputTypeCountTechnicalSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOfferTechnicalSkillWhereInput
  }



  /**
   * Count Type ContractTypeCountOutputType
   */

  export type ContractTypeCountOutputType = {
    contractsOfThisType: number
  }

  export type ContractTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractsOfThisType?: boolean | ContractTypeCountOutputTypeCountContractsOfThisTypeArgs
  }

  // Custom InputTypes

  /**
   * ContractTypeCountOutputType without action
   */
  export type ContractTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractTypeCountOutputType
     */
    select?: ContractTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContractTypeCountOutputType without action
   */
  export type ContractTypeCountOutputTypeCountContractsOfThisTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOfferWhereInput
  }



  /**
   * Count Type CareerCountOutputType
   */

  export type CareerCountOutputType = {
    jobOffers: number
    graduations: number
    skillCategories: number
  }

  export type CareerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobOffers?: boolean | CareerCountOutputTypeCountJobOffersArgs
    graduations?: boolean | CareerCountOutputTypeCountGraduationsArgs
    skillCategories?: boolean | CareerCountOutputTypeCountSkillCategoriesArgs
  }

  // Custom InputTypes

  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerCountOutputType
     */
    select?: CareerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeCountJobOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOfferWhereInput
  }


  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeCountGraduationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GraduationWhereInput
  }


  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeCountSkillCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillCategoryWhereInput
  }



  /**
   * Count Type AlumniCountOutputType
   */

  export type AlumniCountOutputType = {
    jobApplications: number
    graduations: number
  }

  export type AlumniCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobApplications?: boolean | AlumniCountOutputTypeCountJobApplicationsArgs
    graduations?: boolean | AlumniCountOutputTypeCountGraduationsArgs
  }

  // Custom InputTypes

  /**
   * AlumniCountOutputType without action
   */
  export type AlumniCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumniCountOutputType
     */
    select?: AlumniCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AlumniCountOutputType without action
   */
  export type AlumniCountOutputTypeCountJobApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }


  /**
   * AlumniCountOutputType without action
   */
  export type AlumniCountOutputTypeCountGraduationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GraduationWhereInput
  }



  /**
   * Count Type ResumeCountOutputType
   */

  export type ResumeCountOutputType = {
    knownLanguages: number
    portfolio: number
    higherEducationStudies: number
    technicalSkills: number
    softSkills: number
    ciapCourses: number
    positionsOfInterest: number
    industriesOfInterest: number
  }

  export type ResumeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knownLanguages?: boolean | ResumeCountOutputTypeCountKnownLanguagesArgs
    portfolio?: boolean | ResumeCountOutputTypeCountPortfolioArgs
    higherEducationStudies?: boolean | ResumeCountOutputTypeCountHigherEducationStudiesArgs
    technicalSkills?: boolean | ResumeCountOutputTypeCountTechnicalSkillsArgs
    softSkills?: boolean | ResumeCountOutputTypeCountSoftSkillsArgs
    ciapCourses?: boolean | ResumeCountOutputTypeCountCiapCoursesArgs
    positionsOfInterest?: boolean | ResumeCountOutputTypeCountPositionsOfInterestArgs
    industriesOfInterest?: boolean | ResumeCountOutputTypeCountIndustriesOfInterestArgs
  }

  // Custom InputTypes

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCountOutputType
     */
    select?: ResumeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountKnownLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeLanguageWhereInput
  }


  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountPortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioItemWhereInput
  }


  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountHigherEducationStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HigherEducationStudyWhereInput
  }


  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountTechnicalSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeTechnicalSkillWhereInput
  }


  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountSoftSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeSoftSkillWhereInput
  }


  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountCiapCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeCiapCourseWhereInput
  }


  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountPositionsOfInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionOfInterestWhereInput
  }


  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountIndustriesOfInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndustryOfInterestWhereInput
  }



  /**
   * Count Type CiapCourseCountOutputType
   */

  export type CiapCourseCountOutputType = {
    resumesListingThis: number
  }

  export type CiapCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resumesListingThis?: boolean | CiapCourseCountOutputTypeCountResumesListingThisArgs
  }

  // Custom InputTypes

  /**
   * CiapCourseCountOutputType without action
   */
  export type CiapCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourseCountOutputType
     */
    select?: CiapCourseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CiapCourseCountOutputType without action
   */
  export type CiapCourseCountOutputTypeCountResumesListingThisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeCiapCourseWhereInput
  }



  /**
   * Count Type SoftSkillCountOutputType
   */

  export type SoftSkillCountOutputType = {
    resumesListingThis: number
  }

  export type SoftSkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resumesListingThis?: boolean | SoftSkillCountOutputTypeCountResumesListingThisArgs
  }

  // Custom InputTypes

  /**
   * SoftSkillCountOutputType without action
   */
  export type SoftSkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkillCountOutputType
     */
    select?: SoftSkillCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SoftSkillCountOutputType without action
   */
  export type SoftSkillCountOutputTypeCountResumesListingThisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeSoftSkillWhereInput
  }



  /**
   * Count Type SkillCategoryCountOutputType
   */

  export type SkillCategoryCountOutputType = {
    technicalSkills: number
    relatedCareers: number
  }

  export type SkillCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technicalSkills?: boolean | SkillCategoryCountOutputTypeCountTechnicalSkillsArgs
    relatedCareers?: boolean | SkillCategoryCountOutputTypeCountRelatedCareersArgs
  }

  // Custom InputTypes

  /**
   * SkillCategoryCountOutputType without action
   */
  export type SkillCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategoryCountOutputType
     */
    select?: SkillCategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SkillCategoryCountOutputType without action
   */
  export type SkillCategoryCountOutputTypeCountTechnicalSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalSkillWhereInput
  }


  /**
   * SkillCategoryCountOutputType without action
   */
  export type SkillCategoryCountOutputTypeCountRelatedCareersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerWhereInput
  }



  /**
   * Count Type TechnicalSkillCountOutputType
   */

  export type TechnicalSkillCountOutputType = {
    resumesListingThis: number
    jobOffersListingThis: number
  }

  export type TechnicalSkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resumesListingThis?: boolean | TechnicalSkillCountOutputTypeCountResumesListingThisArgs
    jobOffersListingThis?: boolean | TechnicalSkillCountOutputTypeCountJobOffersListingThisArgs
  }

  // Custom InputTypes

  /**
   * TechnicalSkillCountOutputType without action
   */
  export type TechnicalSkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkillCountOutputType
     */
    select?: TechnicalSkillCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TechnicalSkillCountOutputType without action
   */
  export type TechnicalSkillCountOutputTypeCountResumesListingThisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeTechnicalSkillWhereInput
  }


  /**
   * TechnicalSkillCountOutputType without action
   */
  export type TechnicalSkillCountOutputTypeCountJobOffersListingThisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOfferTechnicalSkillWhereInput
  }



  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    knownBy: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knownBy?: boolean | LanguageCountOutputTypeCountKnownByArgs
  }

  // Custom InputTypes

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountKnownByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeLanguageWhereInput
  }



  /**
   * Models
   */

  /**
   * Model JobOffer
   */

  export type AggregateJobOffer = {
    _count: JobOfferCountAggregateOutputType | null
    _min: JobOfferMinAggregateOutputType | null
    _max: JobOfferMaxAggregateOutputType | null
  }

  export type JobOfferMinAggregateOutputType = {
    id: string | null
    description: string | null
    companyName: string | null
    companyContact: string | null
    companyLogo: string | null
    department: string | null
    position: string | null
    offerLocation: string | null
    offerTimestamp: Date | null
    isVisible: boolean | null
    visibleSince: Date | null
    careerName: string | null
    contractTypeName: string | null
  }

  export type JobOfferMaxAggregateOutputType = {
    id: string | null
    description: string | null
    companyName: string | null
    companyContact: string | null
    companyLogo: string | null
    department: string | null
    position: string | null
    offerLocation: string | null
    offerTimestamp: Date | null
    isVisible: boolean | null
    visibleSince: Date | null
    careerName: string | null
    contractTypeName: string | null
  }

  export type JobOfferCountAggregateOutputType = {
    id: number
    description: number
    companyName: number
    companyContact: number
    companyLogo: number
    department: number
    position: number
    offerLocation: number
    offerTimestamp: number
    isVisible: number
    visibleSince: number
    careerName: number
    contractTypeName: number
    _all: number
  }


  export type JobOfferMinAggregateInputType = {
    id?: true
    description?: true
    companyName?: true
    companyContact?: true
    companyLogo?: true
    department?: true
    position?: true
    offerLocation?: true
    offerTimestamp?: true
    isVisible?: true
    visibleSince?: true
    careerName?: true
    contractTypeName?: true
  }

  export type JobOfferMaxAggregateInputType = {
    id?: true
    description?: true
    companyName?: true
    companyContact?: true
    companyLogo?: true
    department?: true
    position?: true
    offerLocation?: true
    offerTimestamp?: true
    isVisible?: true
    visibleSince?: true
    careerName?: true
    contractTypeName?: true
  }

  export type JobOfferCountAggregateInputType = {
    id?: true
    description?: true
    companyName?: true
    companyContact?: true
    companyLogo?: true
    department?: true
    position?: true
    offerLocation?: true
    offerTimestamp?: true
    isVisible?: true
    visibleSince?: true
    careerName?: true
    contractTypeName?: true
    _all?: true
  }

  export type JobOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobOffer to aggregate.
     */
    where?: JobOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOffers to fetch.
     */
    orderBy?: JobOfferOrderByWithRelationInput | JobOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobOffers
    **/
    _count?: true | JobOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobOfferMaxAggregateInputType
  }

  export type GetJobOfferAggregateType<T extends JobOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateJobOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobOffer[P]>
      : GetScalarType<T[P], AggregateJobOffer[P]>
  }




  export type JobOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOfferWhereInput
    orderBy?: JobOfferOrderByWithAggregationInput | JobOfferOrderByWithAggregationInput[]
    by: JobOfferScalarFieldEnum[] | JobOfferScalarFieldEnum
    having?: JobOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobOfferCountAggregateInputType | true
    _min?: JobOfferMinAggregateInputType
    _max?: JobOfferMaxAggregateInputType
  }

  export type JobOfferGroupByOutputType = {
    id: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date
    isVisible: boolean
    visibleSince: Date
    careerName: string
    contractTypeName: string
    _count: JobOfferCountAggregateOutputType | null
    _min: JobOfferMinAggregateOutputType | null
    _max: JobOfferMaxAggregateOutputType | null
  }

  type GetJobOfferGroupByPayload<T extends JobOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobOfferGroupByOutputType[P]>
            : GetScalarType<T[P], JobOfferGroupByOutputType[P]>
        }
      >
    >


  export type JobOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    companyName?: boolean
    companyContact?: boolean
    companyLogo?: boolean
    department?: boolean
    position?: boolean
    offerLocation?: boolean
    offerTimestamp?: boolean
    isVisible?: boolean
    visibleSince?: boolean
    careerName?: boolean
    contractTypeName?: boolean
    career?: boolean | CareerDefaultArgs<ExtArgs>
    applications?: boolean | JobOffer$applicationsArgs<ExtArgs>
    contractType?: boolean | ContractTypeDefaultArgs<ExtArgs>
    technicalSkills?: boolean | JobOffer$technicalSkillsArgs<ExtArgs>
    _count?: boolean | JobOfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobOffer"]>

  export type JobOfferSelectScalar = {
    id?: boolean
    description?: boolean
    companyName?: boolean
    companyContact?: boolean
    companyLogo?: boolean
    department?: boolean
    position?: boolean
    offerLocation?: boolean
    offerTimestamp?: boolean
    isVisible?: boolean
    visibleSince?: boolean
    careerName?: boolean
    contractTypeName?: boolean
  }

  export type JobOfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    career?: boolean | CareerDefaultArgs<ExtArgs>
    applications?: boolean | JobOffer$applicationsArgs<ExtArgs>
    contractType?: boolean | ContractTypeDefaultArgs<ExtArgs>
    technicalSkills?: boolean | JobOffer$technicalSkillsArgs<ExtArgs>
    _count?: boolean | JobOfferCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $JobOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobOffer"
    objects: {
      career: Prisma.$CareerPayload<ExtArgs>
      applications: Prisma.$JobApplicationPayload<ExtArgs>[]
      contractType: Prisma.$ContractTypePayload<ExtArgs>
      technicalSkills: Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      companyName: string
      companyContact: string
      companyLogo: string
      department: string
      position: string
      offerLocation: string
      offerTimestamp: Date
      isVisible: boolean
      visibleSince: Date
      careerName: string
      contractTypeName: string
    }, ExtArgs["result"]["jobOffer"]>
    composites: {}
  }


  type JobOfferGetPayload<S extends boolean | null | undefined | JobOfferDefaultArgs> = $Result.GetResult<Prisma.$JobOfferPayload, S>

  type JobOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobOfferFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: JobOfferCountAggregateInputType | true
    }

  export interface JobOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobOffer'], meta: { name: 'JobOffer' } }
    /**
     * Find zero or one JobOffer that matches the filter.
     * @param {JobOfferFindUniqueArgs} args - Arguments to find a JobOffer
     * @example
     * // Get one JobOffer
     * const jobOffer = await prisma.jobOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobOfferFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferFindUniqueArgs<ExtArgs>>
    ): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JobOffer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobOfferFindUniqueOrThrowArgs} args - Arguments to find a JobOffer
     * @example
     * // Get one JobOffer
     * const jobOffer = await prisma.jobOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobOfferFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JobOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferFindFirstArgs} args - Arguments to find a JobOffer
     * @example
     * // Get one JobOffer
     * const jobOffer = await prisma.jobOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobOfferFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferFindFirstArgs<ExtArgs>>
    ): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JobOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferFindFirstOrThrowArgs} args - Arguments to find a JobOffer
     * @example
     * // Get one JobOffer
     * const jobOffer = await prisma.jobOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobOfferFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JobOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobOffers
     * const jobOffers = await prisma.jobOffer.findMany()
     * 
     * // Get first 10 JobOffers
     * const jobOffers = await prisma.jobOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobOfferWithIdOnly = await prisma.jobOffer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JobOfferFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JobOffer.
     * @param {JobOfferCreateArgs} args - Arguments to create a JobOffer.
     * @example
     * // Create one JobOffer
     * const JobOffer = await prisma.jobOffer.create({
     *   data: {
     *     // ... data to create a JobOffer
     *   }
     * })
     * 
    **/
    create<T extends JobOfferCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferCreateArgs<ExtArgs>>
    ): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JobOffers.
     *     @param {JobOfferCreateManyArgs} args - Arguments to create many JobOffers.
     *     @example
     *     // Create many JobOffers
     *     const jobOffer = await prisma.jobOffer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobOfferCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobOffer.
     * @param {JobOfferDeleteArgs} args - Arguments to delete one JobOffer.
     * @example
     * // Delete one JobOffer
     * const JobOffer = await prisma.jobOffer.delete({
     *   where: {
     *     // ... filter to delete one JobOffer
     *   }
     * })
     * 
    **/
    delete<T extends JobOfferDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferDeleteArgs<ExtArgs>>
    ): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JobOffer.
     * @param {JobOfferUpdateArgs} args - Arguments to update one JobOffer.
     * @example
     * // Update one JobOffer
     * const jobOffer = await prisma.jobOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobOfferUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferUpdateArgs<ExtArgs>>
    ): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JobOffers.
     * @param {JobOfferDeleteManyArgs} args - Arguments to filter JobOffers to delete.
     * @example
     * // Delete a few JobOffers
     * const { count } = await prisma.jobOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobOfferDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobOffers
     * const jobOffer = await prisma.jobOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobOfferUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobOffer.
     * @param {JobOfferUpsertArgs} args - Arguments to update or create a JobOffer.
     * @example
     * // Update or create a JobOffer
     * const jobOffer = await prisma.jobOffer.upsert({
     *   create: {
     *     // ... data to create a JobOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobOffer we want to update
     *   }
     * })
    **/
    upsert<T extends JobOfferUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferUpsertArgs<ExtArgs>>
    ): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JobOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferCountArgs} args - Arguments to filter JobOffers to count.
     * @example
     * // Count the number of JobOffers
     * const count = await prisma.jobOffer.count({
     *   where: {
     *     // ... the filter for the JobOffers we want to count
     *   }
     * })
    **/
    count<T extends JobOfferCountArgs>(
      args?: Subset<T, JobOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobOfferAggregateArgs>(args: Subset<T, JobOfferAggregateArgs>): Prisma.PrismaPromise<GetJobOfferAggregateType<T>>

    /**
     * Group by JobOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobOfferGroupByArgs['orderBy'] }
        : { orderBy?: JobOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobOffer model
   */
  readonly fields: JobOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    career<T extends CareerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CareerDefaultArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    applications<T extends JobOffer$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, JobOffer$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findMany'> | Null>;

    contractType<T extends ContractTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractTypeDefaultArgs<ExtArgs>>): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    technicalSkills<T extends JobOffer$technicalSkillsArgs<ExtArgs> = {}>(args?: Subset<T, JobOffer$technicalSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JobOffer model
   */ 
  interface JobOfferFieldRefs {
    readonly id: FieldRef<"JobOffer", 'String'>
    readonly description: FieldRef<"JobOffer", 'String'>
    readonly companyName: FieldRef<"JobOffer", 'String'>
    readonly companyContact: FieldRef<"JobOffer", 'String'>
    readonly companyLogo: FieldRef<"JobOffer", 'String'>
    readonly department: FieldRef<"JobOffer", 'String'>
    readonly position: FieldRef<"JobOffer", 'String'>
    readonly offerLocation: FieldRef<"JobOffer", 'String'>
    readonly offerTimestamp: FieldRef<"JobOffer", 'DateTime'>
    readonly isVisible: FieldRef<"JobOffer", 'Boolean'>
    readonly visibleSince: FieldRef<"JobOffer", 'DateTime'>
    readonly careerName: FieldRef<"JobOffer", 'String'>
    readonly contractTypeName: FieldRef<"JobOffer", 'String'>
  }
    

  // Custom InputTypes

  /**
   * JobOffer findUnique
   */
  export type JobOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * Filter, which JobOffer to fetch.
     */
    where: JobOfferWhereUniqueInput
  }


  /**
   * JobOffer findUniqueOrThrow
   */
  export type JobOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * Filter, which JobOffer to fetch.
     */
    where: JobOfferWhereUniqueInput
  }


  /**
   * JobOffer findFirst
   */
  export type JobOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * Filter, which JobOffer to fetch.
     */
    where?: JobOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOffers to fetch.
     */
    orderBy?: JobOfferOrderByWithRelationInput | JobOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobOffers.
     */
    cursor?: JobOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobOffers.
     */
    distinct?: JobOfferScalarFieldEnum | JobOfferScalarFieldEnum[]
  }


  /**
   * JobOffer findFirstOrThrow
   */
  export type JobOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * Filter, which JobOffer to fetch.
     */
    where?: JobOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOffers to fetch.
     */
    orderBy?: JobOfferOrderByWithRelationInput | JobOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobOffers.
     */
    cursor?: JobOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobOffers.
     */
    distinct?: JobOfferScalarFieldEnum | JobOfferScalarFieldEnum[]
  }


  /**
   * JobOffer findMany
   */
  export type JobOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * Filter, which JobOffers to fetch.
     */
    where?: JobOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOffers to fetch.
     */
    orderBy?: JobOfferOrderByWithRelationInput | JobOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobOffers.
     */
    cursor?: JobOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOffers.
     */
    skip?: number
    distinct?: JobOfferScalarFieldEnum | JobOfferScalarFieldEnum[]
  }


  /**
   * JobOffer create
   */
  export type JobOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * The data needed to create a JobOffer.
     */
    data: XOR<JobOfferCreateInput, JobOfferUncheckedCreateInput>
  }


  /**
   * JobOffer createMany
   */
  export type JobOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobOffers.
     */
    data: JobOfferCreateManyInput | JobOfferCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JobOffer update
   */
  export type JobOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * The data needed to update a JobOffer.
     */
    data: XOR<JobOfferUpdateInput, JobOfferUncheckedUpdateInput>
    /**
     * Choose, which JobOffer to update.
     */
    where: JobOfferWhereUniqueInput
  }


  /**
   * JobOffer updateMany
   */
  export type JobOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobOffers.
     */
    data: XOR<JobOfferUpdateManyMutationInput, JobOfferUncheckedUpdateManyInput>
    /**
     * Filter which JobOffers to update
     */
    where?: JobOfferWhereInput
  }


  /**
   * JobOffer upsert
   */
  export type JobOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * The filter to search for the JobOffer to update in case it exists.
     */
    where: JobOfferWhereUniqueInput
    /**
     * In case the JobOffer found by the `where` argument doesn't exist, create a new JobOffer with this data.
     */
    create: XOR<JobOfferCreateInput, JobOfferUncheckedCreateInput>
    /**
     * In case the JobOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobOfferUpdateInput, JobOfferUncheckedUpdateInput>
  }


  /**
   * JobOffer delete
   */
  export type JobOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    /**
     * Filter which JobOffer to delete.
     */
    where: JobOfferWhereUniqueInput
  }


  /**
   * JobOffer deleteMany
   */
  export type JobOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobOffers to delete
     */
    where?: JobOfferWhereInput
  }


  /**
   * JobOffer.applications
   */
  export type JobOffer$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * JobOffer.technicalSkills
   */
  export type JobOffer$technicalSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    where?: JobOfferTechnicalSkillWhereInput
    orderBy?: JobOfferTechnicalSkillOrderByWithRelationInput | JobOfferTechnicalSkillOrderByWithRelationInput[]
    cursor?: JobOfferTechnicalSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobOfferTechnicalSkillScalarFieldEnum | JobOfferTechnicalSkillScalarFieldEnum[]
  }


  /**
   * JobOffer without action
   */
  export type JobOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
  }



  /**
   * Model JobOfferTechnicalSkill
   */

  export type AggregateJobOfferTechnicalSkill = {
    _count: JobOfferTechnicalSkillCountAggregateOutputType | null
    _min: JobOfferTechnicalSkillMinAggregateOutputType | null
    _max: JobOfferTechnicalSkillMaxAggregateOutputType | null
  }

  export type JobOfferTechnicalSkillMinAggregateOutputType = {
    jobOfferId: string | null
    technicalSkillName: string | null
    technicalSkillCategoryName: string | null
  }

  export type JobOfferTechnicalSkillMaxAggregateOutputType = {
    jobOfferId: string | null
    technicalSkillName: string | null
    technicalSkillCategoryName: string | null
  }

  export type JobOfferTechnicalSkillCountAggregateOutputType = {
    jobOfferId: number
    technicalSkillName: number
    technicalSkillCategoryName: number
    _all: number
  }


  export type JobOfferTechnicalSkillMinAggregateInputType = {
    jobOfferId?: true
    technicalSkillName?: true
    technicalSkillCategoryName?: true
  }

  export type JobOfferTechnicalSkillMaxAggregateInputType = {
    jobOfferId?: true
    technicalSkillName?: true
    technicalSkillCategoryName?: true
  }

  export type JobOfferTechnicalSkillCountAggregateInputType = {
    jobOfferId?: true
    technicalSkillName?: true
    technicalSkillCategoryName?: true
    _all?: true
  }

  export type JobOfferTechnicalSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobOfferTechnicalSkill to aggregate.
     */
    where?: JobOfferTechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOfferTechnicalSkills to fetch.
     */
    orderBy?: JobOfferTechnicalSkillOrderByWithRelationInput | JobOfferTechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobOfferTechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOfferTechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOfferTechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobOfferTechnicalSkills
    **/
    _count?: true | JobOfferTechnicalSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobOfferTechnicalSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobOfferTechnicalSkillMaxAggregateInputType
  }

  export type GetJobOfferTechnicalSkillAggregateType<T extends JobOfferTechnicalSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateJobOfferTechnicalSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobOfferTechnicalSkill[P]>
      : GetScalarType<T[P], AggregateJobOfferTechnicalSkill[P]>
  }




  export type JobOfferTechnicalSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobOfferTechnicalSkillWhereInput
    orderBy?: JobOfferTechnicalSkillOrderByWithAggregationInput | JobOfferTechnicalSkillOrderByWithAggregationInput[]
    by: JobOfferTechnicalSkillScalarFieldEnum[] | JobOfferTechnicalSkillScalarFieldEnum
    having?: JobOfferTechnicalSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobOfferTechnicalSkillCountAggregateInputType | true
    _min?: JobOfferTechnicalSkillMinAggregateInputType
    _max?: JobOfferTechnicalSkillMaxAggregateInputType
  }

  export type JobOfferTechnicalSkillGroupByOutputType = {
    jobOfferId: string
    technicalSkillName: string
    technicalSkillCategoryName: string
    _count: JobOfferTechnicalSkillCountAggregateOutputType | null
    _min: JobOfferTechnicalSkillMinAggregateOutputType | null
    _max: JobOfferTechnicalSkillMaxAggregateOutputType | null
  }

  type GetJobOfferTechnicalSkillGroupByPayload<T extends JobOfferTechnicalSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobOfferTechnicalSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobOfferTechnicalSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobOfferTechnicalSkillGroupByOutputType[P]>
            : GetScalarType<T[P], JobOfferTechnicalSkillGroupByOutputType[P]>
        }
      >
    >


  export type JobOfferTechnicalSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jobOfferId?: boolean
    technicalSkillName?: boolean
    technicalSkillCategoryName?: boolean
    jobOffer?: boolean | JobOfferDefaultArgs<ExtArgs>
    technicalSkill?: boolean | TechnicalSkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobOfferTechnicalSkill"]>

  export type JobOfferTechnicalSkillSelectScalar = {
    jobOfferId?: boolean
    technicalSkillName?: boolean
    technicalSkillCategoryName?: boolean
  }

  export type JobOfferTechnicalSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobOffer?: boolean | JobOfferDefaultArgs<ExtArgs>
    technicalSkill?: boolean | TechnicalSkillDefaultArgs<ExtArgs>
  }


  export type $JobOfferTechnicalSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobOfferTechnicalSkill"
    objects: {
      jobOffer: Prisma.$JobOfferPayload<ExtArgs>
      technicalSkill: Prisma.$TechnicalSkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      jobOfferId: string
      technicalSkillName: string
      technicalSkillCategoryName: string
    }, ExtArgs["result"]["jobOfferTechnicalSkill"]>
    composites: {}
  }


  type JobOfferTechnicalSkillGetPayload<S extends boolean | null | undefined | JobOfferTechnicalSkillDefaultArgs> = $Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload, S>

  type JobOfferTechnicalSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobOfferTechnicalSkillFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: JobOfferTechnicalSkillCountAggregateInputType | true
    }

  export interface JobOfferTechnicalSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobOfferTechnicalSkill'], meta: { name: 'JobOfferTechnicalSkill' } }
    /**
     * Find zero or one JobOfferTechnicalSkill that matches the filter.
     * @param {JobOfferTechnicalSkillFindUniqueArgs} args - Arguments to find a JobOfferTechnicalSkill
     * @example
     * // Get one JobOfferTechnicalSkill
     * const jobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobOfferTechnicalSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferTechnicalSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__JobOfferTechnicalSkillClient<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JobOfferTechnicalSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobOfferTechnicalSkillFindUniqueOrThrowArgs} args - Arguments to find a JobOfferTechnicalSkill
     * @example
     * // Get one JobOfferTechnicalSkill
     * const jobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobOfferTechnicalSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferTechnicalSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobOfferTechnicalSkillClient<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JobOfferTechnicalSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferTechnicalSkillFindFirstArgs} args - Arguments to find a JobOfferTechnicalSkill
     * @example
     * // Get one JobOfferTechnicalSkill
     * const jobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobOfferTechnicalSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferTechnicalSkillFindFirstArgs<ExtArgs>>
    ): Prisma__JobOfferTechnicalSkillClient<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JobOfferTechnicalSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferTechnicalSkillFindFirstOrThrowArgs} args - Arguments to find a JobOfferTechnicalSkill
     * @example
     * // Get one JobOfferTechnicalSkill
     * const jobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobOfferTechnicalSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferTechnicalSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobOfferTechnicalSkillClient<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JobOfferTechnicalSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferTechnicalSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobOfferTechnicalSkills
     * const jobOfferTechnicalSkills = await prisma.jobOfferTechnicalSkill.findMany()
     * 
     * // Get first 10 JobOfferTechnicalSkills
     * const jobOfferTechnicalSkills = await prisma.jobOfferTechnicalSkill.findMany({ take: 10 })
     * 
     * // Only select the `jobOfferId`
     * const jobOfferTechnicalSkillWithJobOfferIdOnly = await prisma.jobOfferTechnicalSkill.findMany({ select: { jobOfferId: true } })
     * 
    **/
    findMany<T extends JobOfferTechnicalSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferTechnicalSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JobOfferTechnicalSkill.
     * @param {JobOfferTechnicalSkillCreateArgs} args - Arguments to create a JobOfferTechnicalSkill.
     * @example
     * // Create one JobOfferTechnicalSkill
     * const JobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.create({
     *   data: {
     *     // ... data to create a JobOfferTechnicalSkill
     *   }
     * })
     * 
    **/
    create<T extends JobOfferTechnicalSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferTechnicalSkillCreateArgs<ExtArgs>>
    ): Prisma__JobOfferTechnicalSkillClient<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JobOfferTechnicalSkills.
     *     @param {JobOfferTechnicalSkillCreateManyArgs} args - Arguments to create many JobOfferTechnicalSkills.
     *     @example
     *     // Create many JobOfferTechnicalSkills
     *     const jobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobOfferTechnicalSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferTechnicalSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobOfferTechnicalSkill.
     * @param {JobOfferTechnicalSkillDeleteArgs} args - Arguments to delete one JobOfferTechnicalSkill.
     * @example
     * // Delete one JobOfferTechnicalSkill
     * const JobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.delete({
     *   where: {
     *     // ... filter to delete one JobOfferTechnicalSkill
     *   }
     * })
     * 
    **/
    delete<T extends JobOfferTechnicalSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferTechnicalSkillDeleteArgs<ExtArgs>>
    ): Prisma__JobOfferTechnicalSkillClient<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JobOfferTechnicalSkill.
     * @param {JobOfferTechnicalSkillUpdateArgs} args - Arguments to update one JobOfferTechnicalSkill.
     * @example
     * // Update one JobOfferTechnicalSkill
     * const jobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobOfferTechnicalSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferTechnicalSkillUpdateArgs<ExtArgs>>
    ): Prisma__JobOfferTechnicalSkillClient<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JobOfferTechnicalSkills.
     * @param {JobOfferTechnicalSkillDeleteManyArgs} args - Arguments to filter JobOfferTechnicalSkills to delete.
     * @example
     * // Delete a few JobOfferTechnicalSkills
     * const { count } = await prisma.jobOfferTechnicalSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobOfferTechnicalSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobOfferTechnicalSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobOfferTechnicalSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferTechnicalSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobOfferTechnicalSkills
     * const jobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobOfferTechnicalSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferTechnicalSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobOfferTechnicalSkill.
     * @param {JobOfferTechnicalSkillUpsertArgs} args - Arguments to update or create a JobOfferTechnicalSkill.
     * @example
     * // Update or create a JobOfferTechnicalSkill
     * const jobOfferTechnicalSkill = await prisma.jobOfferTechnicalSkill.upsert({
     *   create: {
     *     // ... data to create a JobOfferTechnicalSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobOfferTechnicalSkill we want to update
     *   }
     * })
    **/
    upsert<T extends JobOfferTechnicalSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobOfferTechnicalSkillUpsertArgs<ExtArgs>>
    ): Prisma__JobOfferTechnicalSkillClient<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JobOfferTechnicalSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferTechnicalSkillCountArgs} args - Arguments to filter JobOfferTechnicalSkills to count.
     * @example
     * // Count the number of JobOfferTechnicalSkills
     * const count = await prisma.jobOfferTechnicalSkill.count({
     *   where: {
     *     // ... the filter for the JobOfferTechnicalSkills we want to count
     *   }
     * })
    **/
    count<T extends JobOfferTechnicalSkillCountArgs>(
      args?: Subset<T, JobOfferTechnicalSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobOfferTechnicalSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobOfferTechnicalSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferTechnicalSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobOfferTechnicalSkillAggregateArgs>(args: Subset<T, JobOfferTechnicalSkillAggregateArgs>): Prisma.PrismaPromise<GetJobOfferTechnicalSkillAggregateType<T>>

    /**
     * Group by JobOfferTechnicalSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobOfferTechnicalSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobOfferTechnicalSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobOfferTechnicalSkillGroupByArgs['orderBy'] }
        : { orderBy?: JobOfferTechnicalSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobOfferTechnicalSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobOfferTechnicalSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobOfferTechnicalSkill model
   */
  readonly fields: JobOfferTechnicalSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobOfferTechnicalSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobOfferTechnicalSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jobOffer<T extends JobOfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobOfferDefaultArgs<ExtArgs>>): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    technicalSkill<T extends TechnicalSkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TechnicalSkillDefaultArgs<ExtArgs>>): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JobOfferTechnicalSkill model
   */ 
  interface JobOfferTechnicalSkillFieldRefs {
    readonly jobOfferId: FieldRef<"JobOfferTechnicalSkill", 'String'>
    readonly technicalSkillName: FieldRef<"JobOfferTechnicalSkill", 'String'>
    readonly technicalSkillCategoryName: FieldRef<"JobOfferTechnicalSkill", 'String'>
  }
    

  // Custom InputTypes

  /**
   * JobOfferTechnicalSkill findUnique
   */
  export type JobOfferTechnicalSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which JobOfferTechnicalSkill to fetch.
     */
    where: JobOfferTechnicalSkillWhereUniqueInput
  }


  /**
   * JobOfferTechnicalSkill findUniqueOrThrow
   */
  export type JobOfferTechnicalSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which JobOfferTechnicalSkill to fetch.
     */
    where: JobOfferTechnicalSkillWhereUniqueInput
  }


  /**
   * JobOfferTechnicalSkill findFirst
   */
  export type JobOfferTechnicalSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which JobOfferTechnicalSkill to fetch.
     */
    where?: JobOfferTechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOfferTechnicalSkills to fetch.
     */
    orderBy?: JobOfferTechnicalSkillOrderByWithRelationInput | JobOfferTechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobOfferTechnicalSkills.
     */
    cursor?: JobOfferTechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOfferTechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOfferTechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobOfferTechnicalSkills.
     */
    distinct?: JobOfferTechnicalSkillScalarFieldEnum | JobOfferTechnicalSkillScalarFieldEnum[]
  }


  /**
   * JobOfferTechnicalSkill findFirstOrThrow
   */
  export type JobOfferTechnicalSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which JobOfferTechnicalSkill to fetch.
     */
    where?: JobOfferTechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOfferTechnicalSkills to fetch.
     */
    orderBy?: JobOfferTechnicalSkillOrderByWithRelationInput | JobOfferTechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobOfferTechnicalSkills.
     */
    cursor?: JobOfferTechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOfferTechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOfferTechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobOfferTechnicalSkills.
     */
    distinct?: JobOfferTechnicalSkillScalarFieldEnum | JobOfferTechnicalSkillScalarFieldEnum[]
  }


  /**
   * JobOfferTechnicalSkill findMany
   */
  export type JobOfferTechnicalSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which JobOfferTechnicalSkills to fetch.
     */
    where?: JobOfferTechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobOfferTechnicalSkills to fetch.
     */
    orderBy?: JobOfferTechnicalSkillOrderByWithRelationInput | JobOfferTechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobOfferTechnicalSkills.
     */
    cursor?: JobOfferTechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobOfferTechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobOfferTechnicalSkills.
     */
    skip?: number
    distinct?: JobOfferTechnicalSkillScalarFieldEnum | JobOfferTechnicalSkillScalarFieldEnum[]
  }


  /**
   * JobOfferTechnicalSkill create
   */
  export type JobOfferTechnicalSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a JobOfferTechnicalSkill.
     */
    data: XOR<JobOfferTechnicalSkillCreateInput, JobOfferTechnicalSkillUncheckedCreateInput>
  }


  /**
   * JobOfferTechnicalSkill createMany
   */
  export type JobOfferTechnicalSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobOfferTechnicalSkills.
     */
    data: JobOfferTechnicalSkillCreateManyInput | JobOfferTechnicalSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JobOfferTechnicalSkill update
   */
  export type JobOfferTechnicalSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a JobOfferTechnicalSkill.
     */
    data: XOR<JobOfferTechnicalSkillUpdateInput, JobOfferTechnicalSkillUncheckedUpdateInput>
    /**
     * Choose, which JobOfferTechnicalSkill to update.
     */
    where: JobOfferTechnicalSkillWhereUniqueInput
  }


  /**
   * JobOfferTechnicalSkill updateMany
   */
  export type JobOfferTechnicalSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobOfferTechnicalSkills.
     */
    data: XOR<JobOfferTechnicalSkillUpdateManyMutationInput, JobOfferTechnicalSkillUncheckedUpdateManyInput>
    /**
     * Filter which JobOfferTechnicalSkills to update
     */
    where?: JobOfferTechnicalSkillWhereInput
  }


  /**
   * JobOfferTechnicalSkill upsert
   */
  export type JobOfferTechnicalSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the JobOfferTechnicalSkill to update in case it exists.
     */
    where: JobOfferTechnicalSkillWhereUniqueInput
    /**
     * In case the JobOfferTechnicalSkill found by the `where` argument doesn't exist, create a new JobOfferTechnicalSkill with this data.
     */
    create: XOR<JobOfferTechnicalSkillCreateInput, JobOfferTechnicalSkillUncheckedCreateInput>
    /**
     * In case the JobOfferTechnicalSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobOfferTechnicalSkillUpdateInput, JobOfferTechnicalSkillUncheckedUpdateInput>
  }


  /**
   * JobOfferTechnicalSkill delete
   */
  export type JobOfferTechnicalSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter which JobOfferTechnicalSkill to delete.
     */
    where: JobOfferTechnicalSkillWhereUniqueInput
  }


  /**
   * JobOfferTechnicalSkill deleteMany
   */
  export type JobOfferTechnicalSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobOfferTechnicalSkills to delete
     */
    where?: JobOfferTechnicalSkillWhereInput
  }


  /**
   * JobOfferTechnicalSkill without action
   */
  export type JobOfferTechnicalSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
  }



  /**
   * Model ContractType
   */

  export type AggregateContractType = {
    _count: ContractTypeCountAggregateOutputType | null
    _min: ContractTypeMinAggregateOutputType | null
    _max: ContractTypeMaxAggregateOutputType | null
  }

  export type ContractTypeMinAggregateOutputType = {
    name: string | null
  }

  export type ContractTypeMaxAggregateOutputType = {
    name: string | null
  }

  export type ContractTypeCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type ContractTypeMinAggregateInputType = {
    name?: true
  }

  export type ContractTypeMaxAggregateInputType = {
    name?: true
  }

  export type ContractTypeCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type ContractTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractType to aggregate.
     */
    where?: ContractTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractTypes to fetch.
     */
    orderBy?: ContractTypeOrderByWithRelationInput | ContractTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractTypes
    **/
    _count?: true | ContractTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractTypeMaxAggregateInputType
  }

  export type GetContractTypeAggregateType<T extends ContractTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContractType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractType[P]>
      : GetScalarType<T[P], AggregateContractType[P]>
  }




  export type ContractTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractTypeWhereInput
    orderBy?: ContractTypeOrderByWithAggregationInput | ContractTypeOrderByWithAggregationInput[]
    by: ContractTypeScalarFieldEnum[] | ContractTypeScalarFieldEnum
    having?: ContractTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractTypeCountAggregateInputType | true
    _min?: ContractTypeMinAggregateInputType
    _max?: ContractTypeMaxAggregateInputType
  }

  export type ContractTypeGroupByOutputType = {
    name: string
    _count: ContractTypeCountAggregateOutputType | null
    _min: ContractTypeMinAggregateOutputType | null
    _max: ContractTypeMaxAggregateOutputType | null
  }

  type GetContractTypeGroupByPayload<T extends ContractTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContractTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContractTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    contractsOfThisType?: boolean | ContractType$contractsOfThisTypeArgs<ExtArgs>
    _count?: boolean | ContractTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractType"]>

  export type ContractTypeSelectScalar = {
    name?: boolean
  }

  export type ContractTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractsOfThisType?: boolean | ContractType$contractsOfThisTypeArgs<ExtArgs>
    _count?: boolean | ContractTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ContractTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractType"
    objects: {
      contractsOfThisType: Prisma.$JobOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
    }, ExtArgs["result"]["contractType"]>
    composites: {}
  }


  type ContractTypeGetPayload<S extends boolean | null | undefined | ContractTypeDefaultArgs> = $Result.GetResult<Prisma.$ContractTypePayload, S>

  type ContractTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractTypeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ContractTypeCountAggregateInputType | true
    }

  export interface ContractTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractType'], meta: { name: 'ContractType' } }
    /**
     * Find zero or one ContractType that matches the filter.
     * @param {ContractTypeFindUniqueArgs} args - Arguments to find a ContractType
     * @example
     * // Get one ContractType
     * const contractType = await prisma.contractType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContractTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContractTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContractType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContractTypeFindUniqueOrThrowArgs} args - Arguments to find a ContractType
     * @example
     * // Get one ContractType
     * const contractType = await prisma.contractType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContractTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContractType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeFindFirstArgs} args - Arguments to find a ContractType
     * @example
     * // Get one ContractType
     * const contractType = await prisma.contractType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContractTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractTypeFindFirstArgs<ExtArgs>>
    ): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContractType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeFindFirstOrThrowArgs} args - Arguments to find a ContractType
     * @example
     * // Get one ContractType
     * const contractType = await prisma.contractType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContractTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContractTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractTypes
     * const contractTypes = await prisma.contractType.findMany()
     * 
     * // Get first 10 ContractTypes
     * const contractTypes = await prisma.contractType.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const contractTypeWithNameOnly = await prisma.contractType.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends ContractTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContractType.
     * @param {ContractTypeCreateArgs} args - Arguments to create a ContractType.
     * @example
     * // Create one ContractType
     * const ContractType = await prisma.contractType.create({
     *   data: {
     *     // ... data to create a ContractType
     *   }
     * })
     * 
    **/
    create<T extends ContractTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContractTypeCreateArgs<ExtArgs>>
    ): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContractTypes.
     *     @param {ContractTypeCreateManyArgs} args - Arguments to create many ContractTypes.
     *     @example
     *     // Create many ContractTypes
     *     const contractType = await prisma.contractType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContractTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContractType.
     * @param {ContractTypeDeleteArgs} args - Arguments to delete one ContractType.
     * @example
     * // Delete one ContractType
     * const ContractType = await prisma.contractType.delete({
     *   where: {
     *     // ... filter to delete one ContractType
     *   }
     * })
     * 
    **/
    delete<T extends ContractTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContractTypeDeleteArgs<ExtArgs>>
    ): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContractType.
     * @param {ContractTypeUpdateArgs} args - Arguments to update one ContractType.
     * @example
     * // Update one ContractType
     * const contractType = await prisma.contractType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContractTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContractTypeUpdateArgs<ExtArgs>>
    ): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContractTypes.
     * @param {ContractTypeDeleteManyArgs} args - Arguments to filter ContractTypes to delete.
     * @example
     * // Delete a few ContractTypes
     * const { count } = await prisma.contractType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContractTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContractTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractTypes
     * const contractType = await prisma.contractType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContractTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContractTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractType.
     * @param {ContractTypeUpsertArgs} args - Arguments to update or create a ContractType.
     * @example
     * // Update or create a ContractType
     * const contractType = await prisma.contractType.upsert({
     *   create: {
     *     // ... data to create a ContractType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractType we want to update
     *   }
     * })
    **/
    upsert<T extends ContractTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContractTypeUpsertArgs<ExtArgs>>
    ): Prisma__ContractTypeClient<$Result.GetResult<Prisma.$ContractTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContractTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeCountArgs} args - Arguments to filter ContractTypes to count.
     * @example
     * // Count the number of ContractTypes
     * const count = await prisma.contractType.count({
     *   where: {
     *     // ... the filter for the ContractTypes we want to count
     *   }
     * })
    **/
    count<T extends ContractTypeCountArgs>(
      args?: Subset<T, ContractTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractTypeAggregateArgs>(args: Subset<T, ContractTypeAggregateArgs>): Prisma.PrismaPromise<GetContractTypeAggregateType<T>>

    /**
     * Group by ContractType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContractTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractType model
   */
  readonly fields: ContractTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contractsOfThisType<T extends ContractType$contractsOfThisTypeArgs<ExtArgs> = {}>(args?: Subset<T, ContractType$contractsOfThisTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ContractType model
   */ 
  interface ContractTypeFieldRefs {
    readonly name: FieldRef<"ContractType", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ContractType findUnique
   */
  export type ContractTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContractType to fetch.
     */
    where: ContractTypeWhereUniqueInput
  }


  /**
   * ContractType findUniqueOrThrow
   */
  export type ContractTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContractType to fetch.
     */
    where: ContractTypeWhereUniqueInput
  }


  /**
   * ContractType findFirst
   */
  export type ContractTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContractType to fetch.
     */
    where?: ContractTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractTypes to fetch.
     */
    orderBy?: ContractTypeOrderByWithRelationInput | ContractTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractTypes.
     */
    cursor?: ContractTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractTypes.
     */
    distinct?: ContractTypeScalarFieldEnum | ContractTypeScalarFieldEnum[]
  }


  /**
   * ContractType findFirstOrThrow
   */
  export type ContractTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContractType to fetch.
     */
    where?: ContractTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractTypes to fetch.
     */
    orderBy?: ContractTypeOrderByWithRelationInput | ContractTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractTypes.
     */
    cursor?: ContractTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractTypes.
     */
    distinct?: ContractTypeScalarFieldEnum | ContractTypeScalarFieldEnum[]
  }


  /**
   * ContractType findMany
   */
  export type ContractTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContractTypes to fetch.
     */
    where?: ContractTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractTypes to fetch.
     */
    orderBy?: ContractTypeOrderByWithRelationInput | ContractTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractTypes.
     */
    cursor?: ContractTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractTypes.
     */
    skip?: number
    distinct?: ContractTypeScalarFieldEnum | ContractTypeScalarFieldEnum[]
  }


  /**
   * ContractType create
   */
  export type ContractTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractType.
     */
    data: XOR<ContractTypeCreateInput, ContractTypeUncheckedCreateInput>
  }


  /**
   * ContractType createMany
   */
  export type ContractTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractTypes.
     */
    data: ContractTypeCreateManyInput | ContractTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContractType update
   */
  export type ContractTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractType.
     */
    data: XOR<ContractTypeUpdateInput, ContractTypeUncheckedUpdateInput>
    /**
     * Choose, which ContractType to update.
     */
    where: ContractTypeWhereUniqueInput
  }


  /**
   * ContractType updateMany
   */
  export type ContractTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractTypes.
     */
    data: XOR<ContractTypeUpdateManyMutationInput, ContractTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContractTypes to update
     */
    where?: ContractTypeWhereInput
  }


  /**
   * ContractType upsert
   */
  export type ContractTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractType to update in case it exists.
     */
    where: ContractTypeWhereUniqueInput
    /**
     * In case the ContractType found by the `where` argument doesn't exist, create a new ContractType with this data.
     */
    create: XOR<ContractTypeCreateInput, ContractTypeUncheckedCreateInput>
    /**
     * In case the ContractType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractTypeUpdateInput, ContractTypeUncheckedUpdateInput>
  }


  /**
   * ContractType delete
   */
  export type ContractTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
    /**
     * Filter which ContractType to delete.
     */
    where: ContractTypeWhereUniqueInput
  }


  /**
   * ContractType deleteMany
   */
  export type ContractTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractTypes to delete
     */
    where?: ContractTypeWhereInput
  }


  /**
   * ContractType.contractsOfThisType
   */
  export type ContractType$contractsOfThisTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    where?: JobOfferWhereInput
    orderBy?: JobOfferOrderByWithRelationInput | JobOfferOrderByWithRelationInput[]
    cursor?: JobOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobOfferScalarFieldEnum | JobOfferScalarFieldEnum[]
  }


  /**
   * ContractType without action
   */
  export type ContractTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractType
     */
    select?: ContractTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContractTypeInclude<ExtArgs> | null
  }



  /**
   * Model Career
   */

  export type AggregateCareer = {
    _count: CareerCountAggregateOutputType | null
    _min: CareerMinAggregateOutputType | null
    _max: CareerMaxAggregateOutputType | null
  }

  export type CareerMinAggregateOutputType = {
    name: string | null
  }

  export type CareerMaxAggregateOutputType = {
    name: string | null
  }

  export type CareerCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type CareerMinAggregateInputType = {
    name?: true
  }

  export type CareerMaxAggregateInputType = {
    name?: true
  }

  export type CareerCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type CareerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Career to aggregate.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Careers
    **/
    _count?: true | CareerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerMaxAggregateInputType
  }

  export type GetCareerAggregateType<T extends CareerAggregateArgs> = {
        [P in keyof T & keyof AggregateCareer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareer[P]>
      : GetScalarType<T[P], AggregateCareer[P]>
  }




  export type CareerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerWhereInput
    orderBy?: CareerOrderByWithAggregationInput | CareerOrderByWithAggregationInput[]
    by: CareerScalarFieldEnum[] | CareerScalarFieldEnum
    having?: CareerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerCountAggregateInputType | true
    _min?: CareerMinAggregateInputType
    _max?: CareerMaxAggregateInputType
  }

  export type CareerGroupByOutputType = {
    name: string
    _count: CareerCountAggregateOutputType | null
    _min: CareerMinAggregateOutputType | null
    _max: CareerMaxAggregateOutputType | null
  }

  type GetCareerGroupByPayload<T extends CareerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerGroupByOutputType[P]>
            : GetScalarType<T[P], CareerGroupByOutputType[P]>
        }
      >
    >


  export type CareerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    jobOffers?: boolean | Career$jobOffersArgs<ExtArgs>
    graduations?: boolean | Career$graduationsArgs<ExtArgs>
    skillCategories?: boolean | Career$skillCategoriesArgs<ExtArgs>
    _count?: boolean | CareerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["career"]>

  export type CareerSelectScalar = {
    name?: boolean
  }

  export type CareerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobOffers?: boolean | Career$jobOffersArgs<ExtArgs>
    graduations?: boolean | Career$graduationsArgs<ExtArgs>
    skillCategories?: boolean | Career$skillCategoriesArgs<ExtArgs>
    _count?: boolean | CareerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CareerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Career"
    objects: {
      jobOffers: Prisma.$JobOfferPayload<ExtArgs>[]
      graduations: Prisma.$GraduationPayload<ExtArgs>[]
      skillCategories: Prisma.$SkillCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
    }, ExtArgs["result"]["career"]>
    composites: {}
  }


  type CareerGetPayload<S extends boolean | null | undefined | CareerDefaultArgs> = $Result.GetResult<Prisma.$CareerPayload, S>

  type CareerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CareerFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CareerCountAggregateInputType | true
    }

  export interface CareerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Career'], meta: { name: 'Career' } }
    /**
     * Find zero or one Career that matches the filter.
     * @param {CareerFindUniqueArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CareerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CareerFindUniqueArgs<ExtArgs>>
    ): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Career that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CareerFindUniqueOrThrowArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CareerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Career that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindFirstArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CareerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerFindFirstArgs<ExtArgs>>
    ): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Career that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindFirstOrThrowArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CareerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Careers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Careers
     * const careers = await prisma.career.findMany()
     * 
     * // Get first 10 Careers
     * const careers = await prisma.career.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const careerWithNameOnly = await prisma.career.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends CareerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Career.
     * @param {CareerCreateArgs} args - Arguments to create a Career.
     * @example
     * // Create one Career
     * const Career = await prisma.career.create({
     *   data: {
     *     // ... data to create a Career
     *   }
     * })
     * 
    **/
    create<T extends CareerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CareerCreateArgs<ExtArgs>>
    ): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Careers.
     *     @param {CareerCreateManyArgs} args - Arguments to create many Careers.
     *     @example
     *     // Create many Careers
     *     const career = await prisma.career.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CareerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Career.
     * @param {CareerDeleteArgs} args - Arguments to delete one Career.
     * @example
     * // Delete one Career
     * const Career = await prisma.career.delete({
     *   where: {
     *     // ... filter to delete one Career
     *   }
     * })
     * 
    **/
    delete<T extends CareerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CareerDeleteArgs<ExtArgs>>
    ): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Career.
     * @param {CareerUpdateArgs} args - Arguments to update one Career.
     * @example
     * // Update one Career
     * const career = await prisma.career.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CareerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CareerUpdateArgs<ExtArgs>>
    ): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Careers.
     * @param {CareerDeleteManyArgs} args - Arguments to filter Careers to delete.
     * @example
     * // Delete a few Careers
     * const { count } = await prisma.career.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CareerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CareerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Careers
     * const career = await prisma.career.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CareerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CareerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Career.
     * @param {CareerUpsertArgs} args - Arguments to update or create a Career.
     * @example
     * // Update or create a Career
     * const career = await prisma.career.upsert({
     *   create: {
     *     // ... data to create a Career
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Career we want to update
     *   }
     * })
    **/
    upsert<T extends CareerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CareerUpsertArgs<ExtArgs>>
    ): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerCountArgs} args - Arguments to filter Careers to count.
     * @example
     * // Count the number of Careers
     * const count = await prisma.career.count({
     *   where: {
     *     // ... the filter for the Careers we want to count
     *   }
     * })
    **/
    count<T extends CareerCountArgs>(
      args?: Subset<T, CareerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Career.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerAggregateArgs>(args: Subset<T, CareerAggregateArgs>): Prisma.PrismaPromise<GetCareerAggregateType<T>>

    /**
     * Group by Career.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerGroupByArgs['orderBy'] }
        : { orderBy?: CareerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Career model
   */
  readonly fields: CareerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Career.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jobOffers<T extends Career$jobOffersArgs<ExtArgs> = {}>(args?: Subset<T, Career$jobOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findMany'> | Null>;

    graduations<T extends Career$graduationsArgs<ExtArgs> = {}>(args?: Subset<T, Career$graduationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'findMany'> | Null>;

    skillCategories<T extends Career$skillCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Career$skillCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Career model
   */ 
  interface CareerFieldRefs {
    readonly name: FieldRef<"Career", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Career findUnique
   */
  export type CareerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where: CareerWhereUniqueInput
  }


  /**
   * Career findUniqueOrThrow
   */
  export type CareerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where: CareerWhereUniqueInput
  }


  /**
   * Career findFirst
   */
  export type CareerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     */
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }


  /**
   * Career findFirstOrThrow
   */
  export type CareerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     */
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }


  /**
   * Career findMany
   */
  export type CareerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Careers to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }


  /**
   * Career create
   */
  export type CareerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The data needed to create a Career.
     */
    data: XOR<CareerCreateInput, CareerUncheckedCreateInput>
  }


  /**
   * Career createMany
   */
  export type CareerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Careers.
     */
    data: CareerCreateManyInput | CareerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Career update
   */
  export type CareerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The data needed to update a Career.
     */
    data: XOR<CareerUpdateInput, CareerUncheckedUpdateInput>
    /**
     * Choose, which Career to update.
     */
    where: CareerWhereUniqueInput
  }


  /**
   * Career updateMany
   */
  export type CareerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Careers.
     */
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyInput>
    /**
     * Filter which Careers to update
     */
    where?: CareerWhereInput
  }


  /**
   * Career upsert
   */
  export type CareerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The filter to search for the Career to update in case it exists.
     */
    where: CareerWhereUniqueInput
    /**
     * In case the Career found by the `where` argument doesn't exist, create a new Career with this data.
     */
    create: XOR<CareerCreateInput, CareerUncheckedCreateInput>
    /**
     * In case the Career was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerUpdateInput, CareerUncheckedUpdateInput>
  }


  /**
   * Career delete
   */
  export type CareerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter which Career to delete.
     */
    where: CareerWhereUniqueInput
  }


  /**
   * Career deleteMany
   */
  export type CareerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Careers to delete
     */
    where?: CareerWhereInput
  }


  /**
   * Career.jobOffers
   */
  export type Career$jobOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOffer
     */
    select?: JobOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferInclude<ExtArgs> | null
    where?: JobOfferWhereInput
    orderBy?: JobOfferOrderByWithRelationInput | JobOfferOrderByWithRelationInput[]
    cursor?: JobOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobOfferScalarFieldEnum | JobOfferScalarFieldEnum[]
  }


  /**
   * Career.graduations
   */
  export type Career$graduationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    where?: GraduationWhereInput
    orderBy?: GraduationOrderByWithRelationInput | GraduationOrderByWithRelationInput[]
    cursor?: GraduationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GraduationScalarFieldEnum | GraduationScalarFieldEnum[]
  }


  /**
   * Career.skillCategories
   */
  export type Career$skillCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    where?: SkillCategoryWhereInput
    orderBy?: SkillCategoryOrderByWithRelationInput | SkillCategoryOrderByWithRelationInput[]
    cursor?: SkillCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillCategoryScalarFieldEnum | SkillCategoryScalarFieldEnum[]
  }


  /**
   * Career without action
   */
  export type CareerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    email: string | null
    password: string | null
    names: string | null
    surnames: string | null
    role: $Enums.Role | null
  }

  export type UserMaxAggregateOutputType = {
    email: string | null
    password: string | null
    names: string | null
    surnames: string | null
    role: $Enums.Role | null
  }

  export type UserCountAggregateOutputType = {
    email: number
    password: number
    names: number
    surnames: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    email?: true
    password?: true
    names?: true
    surnames?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    email?: true
    password?: true
    names?: true
    surnames?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    email?: true
    password?: true
    names?: true
    surnames?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    email: string
    password: string
    names: string
    surnames: string
    role: $Enums.Role
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    password?: boolean
    names?: boolean
    surnames?: boolean
    role?: boolean
    associatedAlumni?: boolean | User$associatedAlumniArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    email?: boolean
    password?: boolean
    names?: boolean
    surnames?: boolean
    role?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    associatedAlumni?: boolean | User$associatedAlumniArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      associatedAlumni: Prisma.$AlumniPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      password: string
      names: string
      surnames: string
      role: $Enums.Role
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const userWithEmailOnly = await prisma.user.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    associatedAlumni<T extends User$associatedAlumniArgs<ExtArgs> = {}>(args?: Subset<T, User$associatedAlumniArgs<ExtArgs>>): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly names: FieldRef<"User", 'String'>
    readonly surnames: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.associatedAlumni
   */
  export type User$associatedAlumniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    where?: AlumniWhereInput
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Alumni
   */

  export type AggregateAlumni = {
    _count: AlumniCountAggregateOutputType | null
    _min: AlumniMinAggregateOutputType | null
    _max: AlumniMaxAggregateOutputType | null
  }

  export type AlumniMinAggregateOutputType = {
    email: string | null
    address: string | null
    telephoneNumber: string | null
  }

  export type AlumniMaxAggregateOutputType = {
    email: string | null
    address: string | null
    telephoneNumber: string | null
  }

  export type AlumniCountAggregateOutputType = {
    email: number
    address: number
    telephoneNumber: number
    _all: number
  }


  export type AlumniMinAggregateInputType = {
    email?: true
    address?: true
    telephoneNumber?: true
  }

  export type AlumniMaxAggregateInputType = {
    email?: true
    address?: true
    telephoneNumber?: true
  }

  export type AlumniCountAggregateInputType = {
    email?: true
    address?: true
    telephoneNumber?: true
    _all?: true
  }

  export type AlumniAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alumni to aggregate.
     */
    where?: AlumniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumni to fetch.
     */
    orderBy?: AlumniOrderByWithRelationInput | AlumniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlumniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumni from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumni.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alumni
    **/
    _count?: true | AlumniCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlumniMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlumniMaxAggregateInputType
  }

  export type GetAlumniAggregateType<T extends AlumniAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumni]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumni[P]>
      : GetScalarType<T[P], AggregateAlumni[P]>
  }




  export type AlumniGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumniWhereInput
    orderBy?: AlumniOrderByWithAggregationInput | AlumniOrderByWithAggregationInput[]
    by: AlumniScalarFieldEnum[] | AlumniScalarFieldEnum
    having?: AlumniScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlumniCountAggregateInputType | true
    _min?: AlumniMinAggregateInputType
    _max?: AlumniMaxAggregateInputType
  }

  export type AlumniGroupByOutputType = {
    email: string
    address: string | null
    telephoneNumber: string | null
    _count: AlumniCountAggregateOutputType | null
    _min: AlumniMinAggregateOutputType | null
    _max: AlumniMaxAggregateOutputType | null
  }

  type GetAlumniGroupByPayload<T extends AlumniGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlumniGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlumniGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlumniGroupByOutputType[P]>
            : GetScalarType<T[P], AlumniGroupByOutputType[P]>
        }
      >
    >


  export type AlumniSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    address?: boolean
    telephoneNumber?: boolean
    associatedUser?: boolean | UserDefaultArgs<ExtArgs>
    jobApplications?: boolean | Alumni$jobApplicationsArgs<ExtArgs>
    resume?: boolean | Alumni$resumeArgs<ExtArgs>
    graduations?: boolean | Alumni$graduationsArgs<ExtArgs>
    _count?: boolean | AlumniCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumni"]>

  export type AlumniSelectScalar = {
    email?: boolean
    address?: boolean
    telephoneNumber?: boolean
  }

  export type AlumniInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    associatedUser?: boolean | UserDefaultArgs<ExtArgs>
    jobApplications?: boolean | Alumni$jobApplicationsArgs<ExtArgs>
    resume?: boolean | Alumni$resumeArgs<ExtArgs>
    graduations?: boolean | Alumni$graduationsArgs<ExtArgs>
    _count?: boolean | AlumniCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AlumniPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alumni"
    objects: {
      associatedUser: Prisma.$UserPayload<ExtArgs>
      jobApplications: Prisma.$JobApplicationPayload<ExtArgs>[]
      resume: Prisma.$ResumePayload<ExtArgs> | null
      graduations: Prisma.$GraduationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      address: string | null
      telephoneNumber: string | null
    }, ExtArgs["result"]["alumni"]>
    composites: {}
  }


  type AlumniGetPayload<S extends boolean | null | undefined | AlumniDefaultArgs> = $Result.GetResult<Prisma.$AlumniPayload, S>

  type AlumniCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlumniFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AlumniCountAggregateInputType | true
    }

  export interface AlumniDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alumni'], meta: { name: 'Alumni' } }
    /**
     * Find zero or one Alumni that matches the filter.
     * @param {AlumniFindUniqueArgs} args - Arguments to find a Alumni
     * @example
     * // Get one Alumni
     * const alumni = await prisma.alumni.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlumniFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AlumniFindUniqueArgs<ExtArgs>>
    ): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Alumni that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlumniFindUniqueOrThrowArgs} args - Arguments to find a Alumni
     * @example
     * // Get one Alumni
     * const alumni = await prisma.alumni.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlumniFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlumniFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Alumni that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniFindFirstArgs} args - Arguments to find a Alumni
     * @example
     * // Get one Alumni
     * const alumni = await prisma.alumni.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlumniFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AlumniFindFirstArgs<ExtArgs>>
    ): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Alumni that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniFindFirstOrThrowArgs} args - Arguments to find a Alumni
     * @example
     * // Get one Alumni
     * const alumni = await prisma.alumni.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlumniFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlumniFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Alumni that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alumni
     * const alumni = await prisma.alumni.findMany()
     * 
     * // Get first 10 Alumni
     * const alumni = await prisma.alumni.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const alumniWithEmailOnly = await prisma.alumni.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends AlumniFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlumniFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Alumni.
     * @param {AlumniCreateArgs} args - Arguments to create a Alumni.
     * @example
     * // Create one Alumni
     * const Alumni = await prisma.alumni.create({
     *   data: {
     *     // ... data to create a Alumni
     *   }
     * })
     * 
    **/
    create<T extends AlumniCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AlumniCreateArgs<ExtArgs>>
    ): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Alumni.
     *     @param {AlumniCreateManyArgs} args - Arguments to create many Alumni.
     *     @example
     *     // Create many Alumni
     *     const alumni = await prisma.alumni.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlumniCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlumniCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alumni.
     * @param {AlumniDeleteArgs} args - Arguments to delete one Alumni.
     * @example
     * // Delete one Alumni
     * const Alumni = await prisma.alumni.delete({
     *   where: {
     *     // ... filter to delete one Alumni
     *   }
     * })
     * 
    **/
    delete<T extends AlumniDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AlumniDeleteArgs<ExtArgs>>
    ): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Alumni.
     * @param {AlumniUpdateArgs} args - Arguments to update one Alumni.
     * @example
     * // Update one Alumni
     * const alumni = await prisma.alumni.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlumniUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AlumniUpdateArgs<ExtArgs>>
    ): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Alumni.
     * @param {AlumniDeleteManyArgs} args - Arguments to filter Alumni to delete.
     * @example
     * // Delete a few Alumni
     * const { count } = await prisma.alumni.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlumniDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlumniDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alumni.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alumni
     * const alumni = await prisma.alumni.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlumniUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AlumniUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alumni.
     * @param {AlumniUpsertArgs} args - Arguments to update or create a Alumni.
     * @example
     * // Update or create a Alumni
     * const alumni = await prisma.alumni.upsert({
     *   create: {
     *     // ... data to create a Alumni
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alumni we want to update
     *   }
     * })
    **/
    upsert<T extends AlumniUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AlumniUpsertArgs<ExtArgs>>
    ): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Alumni.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniCountArgs} args - Arguments to filter Alumni to count.
     * @example
     * // Count the number of Alumni
     * const count = await prisma.alumni.count({
     *   where: {
     *     // ... the filter for the Alumni we want to count
     *   }
     * })
    **/
    count<T extends AlumniCountArgs>(
      args?: Subset<T, AlumniCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlumniCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alumni.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlumniAggregateArgs>(args: Subset<T, AlumniAggregateArgs>): Prisma.PrismaPromise<GetAlumniAggregateType<T>>

    /**
     * Group by Alumni.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumniGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlumniGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlumniGroupByArgs['orderBy'] }
        : { orderBy?: AlumniGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlumniGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumniGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alumni model
   */
  readonly fields: AlumniFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alumni.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlumniClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    associatedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    jobApplications<T extends Alumni$jobApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, Alumni$jobApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findMany'> | Null>;

    resume<T extends Alumni$resumeArgs<ExtArgs> = {}>(args?: Subset<T, Alumni$resumeArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    graduations<T extends Alumni$graduationsArgs<ExtArgs> = {}>(args?: Subset<T, Alumni$graduationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Alumni model
   */ 
  interface AlumniFieldRefs {
    readonly email: FieldRef<"Alumni", 'String'>
    readonly address: FieldRef<"Alumni", 'String'>
    readonly telephoneNumber: FieldRef<"Alumni", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Alumni findUnique
   */
  export type AlumniFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * Filter, which Alumni to fetch.
     */
    where: AlumniWhereUniqueInput
  }


  /**
   * Alumni findUniqueOrThrow
   */
  export type AlumniFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * Filter, which Alumni to fetch.
     */
    where: AlumniWhereUniqueInput
  }


  /**
   * Alumni findFirst
   */
  export type AlumniFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * Filter, which Alumni to fetch.
     */
    where?: AlumniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumni to fetch.
     */
    orderBy?: AlumniOrderByWithRelationInput | AlumniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alumni.
     */
    cursor?: AlumniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumni from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumni.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alumni.
     */
    distinct?: AlumniScalarFieldEnum | AlumniScalarFieldEnum[]
  }


  /**
   * Alumni findFirstOrThrow
   */
  export type AlumniFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * Filter, which Alumni to fetch.
     */
    where?: AlumniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumni to fetch.
     */
    orderBy?: AlumniOrderByWithRelationInput | AlumniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alumni.
     */
    cursor?: AlumniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumni from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumni.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alumni.
     */
    distinct?: AlumniScalarFieldEnum | AlumniScalarFieldEnum[]
  }


  /**
   * Alumni findMany
   */
  export type AlumniFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * Filter, which Alumni to fetch.
     */
    where?: AlumniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumni to fetch.
     */
    orderBy?: AlumniOrderByWithRelationInput | AlumniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alumni.
     */
    cursor?: AlumniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumni from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumni.
     */
    skip?: number
    distinct?: AlumniScalarFieldEnum | AlumniScalarFieldEnum[]
  }


  /**
   * Alumni create
   */
  export type AlumniCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * The data needed to create a Alumni.
     */
    data: XOR<AlumniCreateInput, AlumniUncheckedCreateInput>
  }


  /**
   * Alumni createMany
   */
  export type AlumniCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alumni.
     */
    data: AlumniCreateManyInput | AlumniCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Alumni update
   */
  export type AlumniUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * The data needed to update a Alumni.
     */
    data: XOR<AlumniUpdateInput, AlumniUncheckedUpdateInput>
    /**
     * Choose, which Alumni to update.
     */
    where: AlumniWhereUniqueInput
  }


  /**
   * Alumni updateMany
   */
  export type AlumniUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alumni.
     */
    data: XOR<AlumniUpdateManyMutationInput, AlumniUncheckedUpdateManyInput>
    /**
     * Filter which Alumni to update
     */
    where?: AlumniWhereInput
  }


  /**
   * Alumni upsert
   */
  export type AlumniUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * The filter to search for the Alumni to update in case it exists.
     */
    where: AlumniWhereUniqueInput
    /**
     * In case the Alumni found by the `where` argument doesn't exist, create a new Alumni with this data.
     */
    create: XOR<AlumniCreateInput, AlumniUncheckedCreateInput>
    /**
     * In case the Alumni was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlumniUpdateInput, AlumniUncheckedUpdateInput>
  }


  /**
   * Alumni delete
   */
  export type AlumniDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
    /**
     * Filter which Alumni to delete.
     */
    where: AlumniWhereUniqueInput
  }


  /**
   * Alumni deleteMany
   */
  export type AlumniDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alumni to delete
     */
    where?: AlumniWhereInput
  }


  /**
   * Alumni.jobApplications
   */
  export type Alumni$jobApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * Alumni.resume
   */
  export type Alumni$resumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    where?: ResumeWhereInput
  }


  /**
   * Alumni.graduations
   */
  export type Alumni$graduationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    where?: GraduationWhereInput
    orderBy?: GraduationOrderByWithRelationInput | GraduationOrderByWithRelationInput[]
    cursor?: GraduationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GraduationScalarFieldEnum | GraduationScalarFieldEnum[]
  }


  /**
   * Alumni without action
   */
  export type AlumniDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumni
     */
    select?: AlumniSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlumniInclude<ExtArgs> | null
  }



  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sid: string | null
    data: string | null
    expiresAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sid: string | null
    data: string | null
    expiresAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sid: number
    data: number
    expiresAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sid: string
    data: string
    expiresAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sid?: boolean
    data?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sid?: boolean
    data?: boolean
    expiresAt?: boolean
  }


  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sid: string
      data: string
      expiresAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }


  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sid: FieldRef<"Session", 'String'>
    readonly data: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
  }



  /**
   * Model Graduation
   */

  export type AggregateGraduation = {
    _count: GraduationCountAggregateOutputType | null
    _min: GraduationMinAggregateOutputType | null
    _max: GraduationMaxAggregateOutputType | null
  }

  export type GraduationMinAggregateOutputType = {
    careerName: string | null
    alumniEmail: string | null
    graduationDate: Date | null
  }

  export type GraduationMaxAggregateOutputType = {
    careerName: string | null
    alumniEmail: string | null
    graduationDate: Date | null
  }

  export type GraduationCountAggregateOutputType = {
    careerName: number
    alumniEmail: number
    graduationDate: number
    _all: number
  }


  export type GraduationMinAggregateInputType = {
    careerName?: true
    alumniEmail?: true
    graduationDate?: true
  }

  export type GraduationMaxAggregateInputType = {
    careerName?: true
    alumniEmail?: true
    graduationDate?: true
  }

  export type GraduationCountAggregateInputType = {
    careerName?: true
    alumniEmail?: true
    graduationDate?: true
    _all?: true
  }

  export type GraduationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Graduation to aggregate.
     */
    where?: GraduationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Graduations to fetch.
     */
    orderBy?: GraduationOrderByWithRelationInput | GraduationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GraduationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Graduations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Graduations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Graduations
    **/
    _count?: true | GraduationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GraduationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GraduationMaxAggregateInputType
  }

  export type GetGraduationAggregateType<T extends GraduationAggregateArgs> = {
        [P in keyof T & keyof AggregateGraduation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGraduation[P]>
      : GetScalarType<T[P], AggregateGraduation[P]>
  }




  export type GraduationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GraduationWhereInput
    orderBy?: GraduationOrderByWithAggregationInput | GraduationOrderByWithAggregationInput[]
    by: GraduationScalarFieldEnum[] | GraduationScalarFieldEnum
    having?: GraduationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GraduationCountAggregateInputType | true
    _min?: GraduationMinAggregateInputType
    _max?: GraduationMaxAggregateInputType
  }

  export type GraduationGroupByOutputType = {
    careerName: string
    alumniEmail: string
    graduationDate: Date
    _count: GraduationCountAggregateOutputType | null
    _min: GraduationMinAggregateOutputType | null
    _max: GraduationMaxAggregateOutputType | null
  }

  type GetGraduationGroupByPayload<T extends GraduationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GraduationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GraduationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GraduationGroupByOutputType[P]>
            : GetScalarType<T[P], GraduationGroupByOutputType[P]>
        }
      >
    >


  export type GraduationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    careerName?: boolean
    alumniEmail?: boolean
    graduationDate?: boolean
    career?: boolean | CareerDefaultArgs<ExtArgs>
    alumni?: boolean | AlumniDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["graduation"]>

  export type GraduationSelectScalar = {
    careerName?: boolean
    alumniEmail?: boolean
    graduationDate?: boolean
  }

  export type GraduationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    career?: boolean | CareerDefaultArgs<ExtArgs>
    alumni?: boolean | AlumniDefaultArgs<ExtArgs>
  }


  export type $GraduationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Graduation"
    objects: {
      career: Prisma.$CareerPayload<ExtArgs>
      alumni: Prisma.$AlumniPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      careerName: string
      alumniEmail: string
      graduationDate: Date
    }, ExtArgs["result"]["graduation"]>
    composites: {}
  }


  type GraduationGetPayload<S extends boolean | null | undefined | GraduationDefaultArgs> = $Result.GetResult<Prisma.$GraduationPayload, S>

  type GraduationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GraduationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GraduationCountAggregateInputType | true
    }

  export interface GraduationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Graduation'], meta: { name: 'Graduation' } }
    /**
     * Find zero or one Graduation that matches the filter.
     * @param {GraduationFindUniqueArgs} args - Arguments to find a Graduation
     * @example
     * // Get one Graduation
     * const graduation = await prisma.graduation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GraduationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GraduationFindUniqueArgs<ExtArgs>>
    ): Prisma__GraduationClient<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Graduation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GraduationFindUniqueOrThrowArgs} args - Arguments to find a Graduation
     * @example
     * // Get one Graduation
     * const graduation = await prisma.graduation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GraduationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GraduationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GraduationClient<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Graduation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraduationFindFirstArgs} args - Arguments to find a Graduation
     * @example
     * // Get one Graduation
     * const graduation = await prisma.graduation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GraduationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GraduationFindFirstArgs<ExtArgs>>
    ): Prisma__GraduationClient<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Graduation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraduationFindFirstOrThrowArgs} args - Arguments to find a Graduation
     * @example
     * // Get one Graduation
     * const graduation = await prisma.graduation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GraduationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GraduationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GraduationClient<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Graduations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraduationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Graduations
     * const graduations = await prisma.graduation.findMany()
     * 
     * // Get first 10 Graduations
     * const graduations = await prisma.graduation.findMany({ take: 10 })
     * 
     * // Only select the `careerName`
     * const graduationWithCareerNameOnly = await prisma.graduation.findMany({ select: { careerName: true } })
     * 
    **/
    findMany<T extends GraduationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GraduationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Graduation.
     * @param {GraduationCreateArgs} args - Arguments to create a Graduation.
     * @example
     * // Create one Graduation
     * const Graduation = await prisma.graduation.create({
     *   data: {
     *     // ... data to create a Graduation
     *   }
     * })
     * 
    **/
    create<T extends GraduationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GraduationCreateArgs<ExtArgs>>
    ): Prisma__GraduationClient<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Graduations.
     *     @param {GraduationCreateManyArgs} args - Arguments to create many Graduations.
     *     @example
     *     // Create many Graduations
     *     const graduation = await prisma.graduation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GraduationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GraduationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Graduation.
     * @param {GraduationDeleteArgs} args - Arguments to delete one Graduation.
     * @example
     * // Delete one Graduation
     * const Graduation = await prisma.graduation.delete({
     *   where: {
     *     // ... filter to delete one Graduation
     *   }
     * })
     * 
    **/
    delete<T extends GraduationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GraduationDeleteArgs<ExtArgs>>
    ): Prisma__GraduationClient<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Graduation.
     * @param {GraduationUpdateArgs} args - Arguments to update one Graduation.
     * @example
     * // Update one Graduation
     * const graduation = await prisma.graduation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GraduationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GraduationUpdateArgs<ExtArgs>>
    ): Prisma__GraduationClient<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Graduations.
     * @param {GraduationDeleteManyArgs} args - Arguments to filter Graduations to delete.
     * @example
     * // Delete a few Graduations
     * const { count } = await prisma.graduation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GraduationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GraduationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Graduations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraduationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Graduations
     * const graduation = await prisma.graduation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GraduationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GraduationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Graduation.
     * @param {GraduationUpsertArgs} args - Arguments to update or create a Graduation.
     * @example
     * // Update or create a Graduation
     * const graduation = await prisma.graduation.upsert({
     *   create: {
     *     // ... data to create a Graduation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Graduation we want to update
     *   }
     * })
    **/
    upsert<T extends GraduationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GraduationUpsertArgs<ExtArgs>>
    ): Prisma__GraduationClient<$Result.GetResult<Prisma.$GraduationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Graduations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraduationCountArgs} args - Arguments to filter Graduations to count.
     * @example
     * // Count the number of Graduations
     * const count = await prisma.graduation.count({
     *   where: {
     *     // ... the filter for the Graduations we want to count
     *   }
     * })
    **/
    count<T extends GraduationCountArgs>(
      args?: Subset<T, GraduationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GraduationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Graduation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraduationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GraduationAggregateArgs>(args: Subset<T, GraduationAggregateArgs>): Prisma.PrismaPromise<GetGraduationAggregateType<T>>

    /**
     * Group by Graduation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraduationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GraduationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GraduationGroupByArgs['orderBy'] }
        : { orderBy?: GraduationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GraduationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGraduationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Graduation model
   */
  readonly fields: GraduationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Graduation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GraduationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    career<T extends CareerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CareerDefaultArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    alumni<T extends AlumniDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumniDefaultArgs<ExtArgs>>): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Graduation model
   */ 
  interface GraduationFieldRefs {
    readonly careerName: FieldRef<"Graduation", 'String'>
    readonly alumniEmail: FieldRef<"Graduation", 'String'>
    readonly graduationDate: FieldRef<"Graduation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Graduation findUnique
   */
  export type GraduationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * Filter, which Graduation to fetch.
     */
    where: GraduationWhereUniqueInput
  }


  /**
   * Graduation findUniqueOrThrow
   */
  export type GraduationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * Filter, which Graduation to fetch.
     */
    where: GraduationWhereUniqueInput
  }


  /**
   * Graduation findFirst
   */
  export type GraduationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * Filter, which Graduation to fetch.
     */
    where?: GraduationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Graduations to fetch.
     */
    orderBy?: GraduationOrderByWithRelationInput | GraduationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Graduations.
     */
    cursor?: GraduationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Graduations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Graduations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Graduations.
     */
    distinct?: GraduationScalarFieldEnum | GraduationScalarFieldEnum[]
  }


  /**
   * Graduation findFirstOrThrow
   */
  export type GraduationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * Filter, which Graduation to fetch.
     */
    where?: GraduationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Graduations to fetch.
     */
    orderBy?: GraduationOrderByWithRelationInput | GraduationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Graduations.
     */
    cursor?: GraduationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Graduations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Graduations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Graduations.
     */
    distinct?: GraduationScalarFieldEnum | GraduationScalarFieldEnum[]
  }


  /**
   * Graduation findMany
   */
  export type GraduationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * Filter, which Graduations to fetch.
     */
    where?: GraduationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Graduations to fetch.
     */
    orderBy?: GraduationOrderByWithRelationInput | GraduationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Graduations.
     */
    cursor?: GraduationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Graduations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Graduations.
     */
    skip?: number
    distinct?: GraduationScalarFieldEnum | GraduationScalarFieldEnum[]
  }


  /**
   * Graduation create
   */
  export type GraduationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * The data needed to create a Graduation.
     */
    data: XOR<GraduationCreateInput, GraduationUncheckedCreateInput>
  }


  /**
   * Graduation createMany
   */
  export type GraduationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Graduations.
     */
    data: GraduationCreateManyInput | GraduationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Graduation update
   */
  export type GraduationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * The data needed to update a Graduation.
     */
    data: XOR<GraduationUpdateInput, GraduationUncheckedUpdateInput>
    /**
     * Choose, which Graduation to update.
     */
    where: GraduationWhereUniqueInput
  }


  /**
   * Graduation updateMany
   */
  export type GraduationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Graduations.
     */
    data: XOR<GraduationUpdateManyMutationInput, GraduationUncheckedUpdateManyInput>
    /**
     * Filter which Graduations to update
     */
    where?: GraduationWhereInput
  }


  /**
   * Graduation upsert
   */
  export type GraduationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * The filter to search for the Graduation to update in case it exists.
     */
    where: GraduationWhereUniqueInput
    /**
     * In case the Graduation found by the `where` argument doesn't exist, create a new Graduation with this data.
     */
    create: XOR<GraduationCreateInput, GraduationUncheckedCreateInput>
    /**
     * In case the Graduation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GraduationUpdateInput, GraduationUncheckedUpdateInput>
  }


  /**
   * Graduation delete
   */
  export type GraduationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
    /**
     * Filter which Graduation to delete.
     */
    where: GraduationWhereUniqueInput
  }


  /**
   * Graduation deleteMany
   */
  export type GraduationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Graduations to delete
     */
    where?: GraduationWhereInput
  }


  /**
   * Graduation without action
   */
  export type GraduationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Graduation
     */
    select?: GraduationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GraduationInclude<ExtArgs> | null
  }



  /**
   * Model JobApplication
   */

  export type AggregateJobApplication = {
    _count: JobApplicationCountAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  export type JobApplicationMinAggregateOutputType = {
    jobOfferId: string | null
    alumniWhoAppliedEmail: string | null
    applicationTimestamp: Date | null
  }

  export type JobApplicationMaxAggregateOutputType = {
    jobOfferId: string | null
    alumniWhoAppliedEmail: string | null
    applicationTimestamp: Date | null
  }

  export type JobApplicationCountAggregateOutputType = {
    jobOfferId: number
    alumniWhoAppliedEmail: number
    applicationTimestamp: number
    _all: number
  }


  export type JobApplicationMinAggregateInputType = {
    jobOfferId?: true
    alumniWhoAppliedEmail?: true
    applicationTimestamp?: true
  }

  export type JobApplicationMaxAggregateInputType = {
    jobOfferId?: true
    alumniWhoAppliedEmail?: true
    applicationTimestamp?: true
  }

  export type JobApplicationCountAggregateInputType = {
    jobOfferId?: true
    alumniWhoAppliedEmail?: true
    applicationTimestamp?: true
    _all?: true
  }

  export type JobApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplication to aggregate.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobApplications
    **/
    _count?: true | JobApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobApplicationMaxAggregateInputType
  }

  export type GetJobApplicationAggregateType<T extends JobApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateJobApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobApplication[P]>
      : GetScalarType<T[P], AggregateJobApplication[P]>
  }




  export type JobApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithAggregationInput | JobApplicationOrderByWithAggregationInput[]
    by: JobApplicationScalarFieldEnum[] | JobApplicationScalarFieldEnum
    having?: JobApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobApplicationCountAggregateInputType | true
    _min?: JobApplicationMinAggregateInputType
    _max?: JobApplicationMaxAggregateInputType
  }

  export type JobApplicationGroupByOutputType = {
    jobOfferId: string
    alumniWhoAppliedEmail: string
    applicationTimestamp: Date
    _count: JobApplicationCountAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  type GetJobApplicationGroupByPayload<T extends JobApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
        }
      >
    >


  export type JobApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jobOfferId?: boolean
    alumniWhoAppliedEmail?: boolean
    applicationTimestamp?: boolean
    jobOffer?: boolean | JobOfferDefaultArgs<ExtArgs>
    alumniWhoApplied?: boolean | AlumniDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectScalar = {
    jobOfferId?: boolean
    alumniWhoAppliedEmail?: boolean
    applicationTimestamp?: boolean
  }

  export type JobApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobOffer?: boolean | JobOfferDefaultArgs<ExtArgs>
    alumniWhoApplied?: boolean | AlumniDefaultArgs<ExtArgs>
  }


  export type $JobApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobApplication"
    objects: {
      jobOffer: Prisma.$JobOfferPayload<ExtArgs>
      alumniWhoApplied: Prisma.$AlumniPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      jobOfferId: string
      alumniWhoAppliedEmail: string
      applicationTimestamp: Date
    }, ExtArgs["result"]["jobApplication"]>
    composites: {}
  }


  type JobApplicationGetPayload<S extends boolean | null | undefined | JobApplicationDefaultArgs> = $Result.GetResult<Prisma.$JobApplicationPayload, S>

  type JobApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobApplicationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: JobApplicationCountAggregateInputType | true
    }

  export interface JobApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobApplication'], meta: { name: 'JobApplication' } }
    /**
     * Find zero or one JobApplication that matches the filter.
     * @param {JobApplicationFindUniqueArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobApplicationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationFindUniqueArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JobApplication that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobApplicationFindUniqueOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobApplicationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JobApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobApplicationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationFindFirstArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JobApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobApplicationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JobApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobApplications
     * const jobApplications = await prisma.jobApplication.findMany()
     * 
     * // Get first 10 JobApplications
     * const jobApplications = await prisma.jobApplication.findMany({ take: 10 })
     * 
     * // Only select the `jobOfferId`
     * const jobApplicationWithJobOfferIdOnly = await prisma.jobApplication.findMany({ select: { jobOfferId: true } })
     * 
    **/
    findMany<T extends JobApplicationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JobApplication.
     * @param {JobApplicationCreateArgs} args - Arguments to create a JobApplication.
     * @example
     * // Create one JobApplication
     * const JobApplication = await prisma.jobApplication.create({
     *   data: {
     *     // ... data to create a JobApplication
     *   }
     * })
     * 
    **/
    create<T extends JobApplicationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationCreateArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JobApplications.
     *     @param {JobApplicationCreateManyArgs} args - Arguments to create many JobApplications.
     *     @example
     *     // Create many JobApplications
     *     const jobApplication = await prisma.jobApplication.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobApplicationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobApplication.
     * @param {JobApplicationDeleteArgs} args - Arguments to delete one JobApplication.
     * @example
     * // Delete one JobApplication
     * const JobApplication = await prisma.jobApplication.delete({
     *   where: {
     *     // ... filter to delete one JobApplication
     *   }
     * })
     * 
    **/
    delete<T extends JobApplicationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationDeleteArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JobApplication.
     * @param {JobApplicationUpdateArgs} args - Arguments to update one JobApplication.
     * @example
     * // Update one JobApplication
     * const jobApplication = await prisma.jobApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobApplicationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationUpdateArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JobApplications.
     * @param {JobApplicationDeleteManyArgs} args - Arguments to filter JobApplications to delete.
     * @example
     * // Delete a few JobApplications
     * const { count } = await prisma.jobApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobApplicationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobApplications
     * const jobApplication = await prisma.jobApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobApplicationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobApplication.
     * @param {JobApplicationUpsertArgs} args - Arguments to update or create a JobApplication.
     * @example
     * // Update or create a JobApplication
     * const jobApplication = await prisma.jobApplication.upsert({
     *   create: {
     *     // ... data to create a JobApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobApplication we want to update
     *   }
     * })
    **/
    upsert<T extends JobApplicationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationUpsertArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationCountArgs} args - Arguments to filter JobApplications to count.
     * @example
     * // Count the number of JobApplications
     * const count = await prisma.jobApplication.count({
     *   where: {
     *     // ... the filter for the JobApplications we want to count
     *   }
     * })
    **/
    count<T extends JobApplicationCountArgs>(
      args?: Subset<T, JobApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobApplicationAggregateArgs>(args: Subset<T, JobApplicationAggregateArgs>): Prisma.PrismaPromise<GetJobApplicationAggregateType<T>>

    /**
     * Group by JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobApplicationGroupByArgs['orderBy'] }
        : { orderBy?: JobApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobApplication model
   */
  readonly fields: JobApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jobOffer<T extends JobOfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobOfferDefaultArgs<ExtArgs>>): Prisma__JobOfferClient<$Result.GetResult<Prisma.$JobOfferPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    alumniWhoApplied<T extends AlumniDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumniDefaultArgs<ExtArgs>>): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JobApplication model
   */ 
  interface JobApplicationFieldRefs {
    readonly jobOfferId: FieldRef<"JobApplication", 'String'>
    readonly alumniWhoAppliedEmail: FieldRef<"JobApplication", 'String'>
    readonly applicationTimestamp: FieldRef<"JobApplication", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * JobApplication findUnique
   */
  export type JobApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }


  /**
   * JobApplication findUniqueOrThrow
   */
  export type JobApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }


  /**
   * JobApplication findFirst
   */
  export type JobApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * JobApplication findFirstOrThrow
   */
  export type JobApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * JobApplication findMany
   */
  export type JobApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplications to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * JobApplication create
   */
  export type JobApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a JobApplication.
     */
    data: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
  }


  /**
   * JobApplication createMany
   */
  export type JobApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobApplications.
     */
    data: JobApplicationCreateManyInput | JobApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JobApplication update
   */
  export type JobApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a JobApplication.
     */
    data: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
    /**
     * Choose, which JobApplication to update.
     */
    where: JobApplicationWhereUniqueInput
  }


  /**
   * JobApplication updateMany
   */
  export type JobApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobApplications.
     */
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which JobApplications to update
     */
    where?: JobApplicationWhereInput
  }


  /**
   * JobApplication upsert
   */
  export type JobApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the JobApplication to update in case it exists.
     */
    where: JobApplicationWhereUniqueInput
    /**
     * In case the JobApplication found by the `where` argument doesn't exist, create a new JobApplication with this data.
     */
    create: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
    /**
     * In case the JobApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
  }


  /**
   * JobApplication delete
   */
  export type JobApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter which JobApplication to delete.
     */
    where: JobApplicationWhereUniqueInput
  }


  /**
   * JobApplication deleteMany
   */
  export type JobApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplications to delete
     */
    where?: JobApplicationWhereInput
  }


  /**
   * JobApplication without action
   */
  export type JobApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
  }



  /**
   * Model Resume
   */

  export type AggregateResume = {
    _count: ResumeCountAggregateOutputType | null
    _avg: ResumeAvgAggregateOutputType | null
    _sum: ResumeSumAggregateOutputType | null
    _min: ResumeMinAggregateOutputType | null
    _max: ResumeMaxAggregateOutputType | null
  }

  export type ResumeAvgAggregateOutputType = {
    numberOfDownloads: number | null
  }

  export type ResumeSumAggregateOutputType = {
    numberOfDownloads: number | null
  }

  export type ResumeMinAggregateOutputType = {
    ownerEmail: string | null
    numberOfDownloads: number | null
    isVisible: boolean | null
    visibleSince: Date | null
    aboutMe: string | null
  }

  export type ResumeMaxAggregateOutputType = {
    ownerEmail: string | null
    numberOfDownloads: number | null
    isVisible: boolean | null
    visibleSince: Date | null
    aboutMe: string | null
  }

  export type ResumeCountAggregateOutputType = {
    ownerEmail: number
    numberOfDownloads: number
    isVisible: number
    visibleSince: number
    aboutMe: number
    _all: number
  }


  export type ResumeAvgAggregateInputType = {
    numberOfDownloads?: true
  }

  export type ResumeSumAggregateInputType = {
    numberOfDownloads?: true
  }

  export type ResumeMinAggregateInputType = {
    ownerEmail?: true
    numberOfDownloads?: true
    isVisible?: true
    visibleSince?: true
    aboutMe?: true
  }

  export type ResumeMaxAggregateInputType = {
    ownerEmail?: true
    numberOfDownloads?: true
    isVisible?: true
    visibleSince?: true
    aboutMe?: true
  }

  export type ResumeCountAggregateInputType = {
    ownerEmail?: true
    numberOfDownloads?: true
    isVisible?: true
    visibleSince?: true
    aboutMe?: true
    _all?: true
  }

  export type ResumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resume to aggregate.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resumes
    **/
    _count?: true | ResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeMaxAggregateInputType
  }

  export type GetResumeAggregateType<T extends ResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResume[P]>
      : GetScalarType<T[P], AggregateResume[P]>
  }




  export type ResumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeWhereInput
    orderBy?: ResumeOrderByWithAggregationInput | ResumeOrderByWithAggregationInput[]
    by: ResumeScalarFieldEnum[] | ResumeScalarFieldEnum
    having?: ResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeCountAggregateInputType | true
    _avg?: ResumeAvgAggregateInputType
    _sum?: ResumeSumAggregateInputType
    _min?: ResumeMinAggregateInputType
    _max?: ResumeMaxAggregateInputType
  }

  export type ResumeGroupByOutputType = {
    ownerEmail: string
    numberOfDownloads: number
    isVisible: boolean
    visibleSince: Date
    aboutMe: string | null
    _count: ResumeCountAggregateOutputType | null
    _avg: ResumeAvgAggregateOutputType | null
    _sum: ResumeSumAggregateOutputType | null
    _min: ResumeMinAggregateOutputType | null
    _max: ResumeMaxAggregateOutputType | null
  }

  type GetResumeGroupByPayload<T extends ResumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeGroupByOutputType[P]>
        }
      >
    >


  export type ResumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ownerEmail?: boolean
    numberOfDownloads?: boolean
    isVisible?: boolean
    visibleSince?: boolean
    aboutMe?: boolean
    owner?: boolean | AlumniDefaultArgs<ExtArgs>
    knownLanguages?: boolean | Resume$knownLanguagesArgs<ExtArgs>
    portfolio?: boolean | Resume$portfolioArgs<ExtArgs>
    higherEducationStudies?: boolean | Resume$higherEducationStudiesArgs<ExtArgs>
    technicalSkills?: boolean | Resume$technicalSkillsArgs<ExtArgs>
    softSkills?: boolean | Resume$softSkillsArgs<ExtArgs>
    ciapCourses?: boolean | Resume$ciapCoursesArgs<ExtArgs>
    positionsOfInterest?: boolean | Resume$positionsOfInterestArgs<ExtArgs>
    industriesOfInterest?: boolean | Resume$industriesOfInterestArgs<ExtArgs>
    _count?: boolean | ResumeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectScalar = {
    ownerEmail?: boolean
    numberOfDownloads?: boolean
    isVisible?: boolean
    visibleSince?: boolean
    aboutMe?: boolean
  }

  export type ResumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | AlumniDefaultArgs<ExtArgs>
    knownLanguages?: boolean | Resume$knownLanguagesArgs<ExtArgs>
    portfolio?: boolean | Resume$portfolioArgs<ExtArgs>
    higherEducationStudies?: boolean | Resume$higherEducationStudiesArgs<ExtArgs>
    technicalSkills?: boolean | Resume$technicalSkillsArgs<ExtArgs>
    softSkills?: boolean | Resume$softSkillsArgs<ExtArgs>
    ciapCourses?: boolean | Resume$ciapCoursesArgs<ExtArgs>
    positionsOfInterest?: boolean | Resume$positionsOfInterestArgs<ExtArgs>
    industriesOfInterest?: boolean | Resume$industriesOfInterestArgs<ExtArgs>
    _count?: boolean | ResumeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ResumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resume"
    objects: {
      owner: Prisma.$AlumniPayload<ExtArgs>
      knownLanguages: Prisma.$ResumeLanguagePayload<ExtArgs>[]
      portfolio: Prisma.$PortfolioItemPayload<ExtArgs>[]
      higherEducationStudies: Prisma.$HigherEducationStudyPayload<ExtArgs>[]
      technicalSkills: Prisma.$ResumeTechnicalSkillPayload<ExtArgs>[]
      softSkills: Prisma.$ResumeSoftSkillPayload<ExtArgs>[]
      ciapCourses: Prisma.$ResumeCiapCoursePayload<ExtArgs>[]
      positionsOfInterest: Prisma.$PositionOfInterestPayload<ExtArgs>[]
      industriesOfInterest: Prisma.$IndustryOfInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ownerEmail: string
      numberOfDownloads: number
      isVisible: boolean
      visibleSince: Date
      aboutMe: string | null
    }, ExtArgs["result"]["resume"]>
    composites: {}
  }


  type ResumeGetPayload<S extends boolean | null | undefined | ResumeDefaultArgs> = $Result.GetResult<Prisma.$ResumePayload, S>

  type ResumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResumeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ResumeCountAggregateInputType | true
    }

  export interface ResumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resume'], meta: { name: 'Resume' } }
    /**
     * Find zero or one Resume that matches the filter.
     * @param {ResumeFindUniqueArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeFindUniqueArgs<ExtArgs>>
    ): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Resume that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResumeFindUniqueOrThrowArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Resume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindFirstArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeFindFirstArgs<ExtArgs>>
    ): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Resume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindFirstOrThrowArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Resumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resumes
     * const resumes = await prisma.resume.findMany()
     * 
     * // Get first 10 Resumes
     * const resumes = await prisma.resume.findMany({ take: 10 })
     * 
     * // Only select the `ownerEmail`
     * const resumeWithOwnerEmailOnly = await prisma.resume.findMany({ select: { ownerEmail: true } })
     * 
    **/
    findMany<T extends ResumeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Resume.
     * @param {ResumeCreateArgs} args - Arguments to create a Resume.
     * @example
     * // Create one Resume
     * const Resume = await prisma.resume.create({
     *   data: {
     *     // ... data to create a Resume
     *   }
     * })
     * 
    **/
    create<T extends ResumeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeCreateArgs<ExtArgs>>
    ): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Resumes.
     *     @param {ResumeCreateManyArgs} args - Arguments to create many Resumes.
     *     @example
     *     // Create many Resumes
     *     const resume = await prisma.resume.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resume.
     * @param {ResumeDeleteArgs} args - Arguments to delete one Resume.
     * @example
     * // Delete one Resume
     * const Resume = await prisma.resume.delete({
     *   where: {
     *     // ... filter to delete one Resume
     *   }
     * })
     * 
    **/
    delete<T extends ResumeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeDeleteArgs<ExtArgs>>
    ): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Resume.
     * @param {ResumeUpdateArgs} args - Arguments to update one Resume.
     * @example
     * // Update one Resume
     * const resume = await prisma.resume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeUpdateArgs<ExtArgs>>
    ): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Resumes.
     * @param {ResumeDeleteManyArgs} args - Arguments to filter Resumes to delete.
     * @example
     * // Delete a few Resumes
     * const { count } = await prisma.resume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resumes
     * const resume = await prisma.resume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resume.
     * @param {ResumeUpsertArgs} args - Arguments to update or create a Resume.
     * @example
     * // Update or create a Resume
     * const resume = await prisma.resume.upsert({
     *   create: {
     *     // ... data to create a Resume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resume we want to update
     *   }
     * })
    **/
    upsert<T extends ResumeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeUpsertArgs<ExtArgs>>
    ): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCountArgs} args - Arguments to filter Resumes to count.
     * @example
     * // Count the number of Resumes
     * const count = await prisma.resume.count({
     *   where: {
     *     // ... the filter for the Resumes we want to count
     *   }
     * })
    **/
    count<T extends ResumeCountArgs>(
      args?: Subset<T, ResumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeAggregateArgs>(args: Subset<T, ResumeAggregateArgs>): Prisma.PrismaPromise<GetResumeAggregateType<T>>

    /**
     * Group by Resume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeGroupByArgs['orderBy'] }
        : { orderBy?: ResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resume model
   */
  readonly fields: ResumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    owner<T extends AlumniDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumniDefaultArgs<ExtArgs>>): Prisma__AlumniClient<$Result.GetResult<Prisma.$AlumniPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    knownLanguages<T extends Resume$knownLanguagesArgs<ExtArgs> = {}>(args?: Subset<T, Resume$knownLanguagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'findMany'> | Null>;

    portfolio<T extends Resume$portfolioArgs<ExtArgs> = {}>(args?: Subset<T, Resume$portfolioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    higherEducationStudies<T extends Resume$higherEducationStudiesArgs<ExtArgs> = {}>(args?: Subset<T, Resume$higherEducationStudiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'findMany'> | Null>;

    technicalSkills<T extends Resume$technicalSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$technicalSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    softSkills<T extends Resume$softSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$softSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    ciapCourses<T extends Resume$ciapCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Resume$ciapCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    positionsOfInterest<T extends Resume$positionsOfInterestArgs<ExtArgs> = {}>(args?: Subset<T, Resume$positionsOfInterestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'findMany'> | Null>;

    industriesOfInterest<T extends Resume$industriesOfInterestArgs<ExtArgs> = {}>(args?: Subset<T, Resume$industriesOfInterestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Resume model
   */ 
  interface ResumeFieldRefs {
    readonly ownerEmail: FieldRef<"Resume", 'String'>
    readonly numberOfDownloads: FieldRef<"Resume", 'Int'>
    readonly isVisible: FieldRef<"Resume", 'Boolean'>
    readonly visibleSince: FieldRef<"Resume", 'DateTime'>
    readonly aboutMe: FieldRef<"Resume", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Resume findUnique
   */
  export type ResumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where: ResumeWhereUniqueInput
  }


  /**
   * Resume findUniqueOrThrow
   */
  export type ResumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where: ResumeWhereUniqueInput
  }


  /**
   * Resume findFirst
   */
  export type ResumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resumes.
     */
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }


  /**
   * Resume findFirstOrThrow
   */
  export type ResumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resumes.
     */
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }


  /**
   * Resume findMany
   */
  export type ResumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resumes to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }


  /**
   * Resume create
   */
  export type ResumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The data needed to create a Resume.
     */
    data: XOR<ResumeCreateInput, ResumeUncheckedCreateInput>
  }


  /**
   * Resume createMany
   */
  export type ResumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resumes.
     */
    data: ResumeCreateManyInput | ResumeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Resume update
   */
  export type ResumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The data needed to update a Resume.
     */
    data: XOR<ResumeUpdateInput, ResumeUncheckedUpdateInput>
    /**
     * Choose, which Resume to update.
     */
    where: ResumeWhereUniqueInput
  }


  /**
   * Resume updateMany
   */
  export type ResumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resumes.
     */
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyInput>
    /**
     * Filter which Resumes to update
     */
    where?: ResumeWhereInput
  }


  /**
   * Resume upsert
   */
  export type ResumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The filter to search for the Resume to update in case it exists.
     */
    where: ResumeWhereUniqueInput
    /**
     * In case the Resume found by the `where` argument doesn't exist, create a new Resume with this data.
     */
    create: XOR<ResumeCreateInput, ResumeUncheckedCreateInput>
    /**
     * In case the Resume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeUpdateInput, ResumeUncheckedUpdateInput>
  }


  /**
   * Resume delete
   */
  export type ResumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter which Resume to delete.
     */
    where: ResumeWhereUniqueInput
  }


  /**
   * Resume deleteMany
   */
  export type ResumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resumes to delete
     */
    where?: ResumeWhereInput
  }


  /**
   * Resume.knownLanguages
   */
  export type Resume$knownLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    where?: ResumeLanguageWhereInput
    orderBy?: ResumeLanguageOrderByWithRelationInput | ResumeLanguageOrderByWithRelationInput[]
    cursor?: ResumeLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeLanguageScalarFieldEnum | ResumeLanguageScalarFieldEnum[]
  }


  /**
   * Resume.portfolio
   */
  export type Resume$portfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    where?: PortfolioItemWhereInput
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    cursor?: PortfolioItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }


  /**
   * Resume.higherEducationStudies
   */
  export type Resume$higherEducationStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    where?: HigherEducationStudyWhereInput
    orderBy?: HigherEducationStudyOrderByWithRelationInput | HigherEducationStudyOrderByWithRelationInput[]
    cursor?: HigherEducationStudyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HigherEducationStudyScalarFieldEnum | HigherEducationStudyScalarFieldEnum[]
  }


  /**
   * Resume.technicalSkills
   */
  export type Resume$technicalSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    where?: ResumeTechnicalSkillWhereInput
    orderBy?: ResumeTechnicalSkillOrderByWithRelationInput | ResumeTechnicalSkillOrderByWithRelationInput[]
    cursor?: ResumeTechnicalSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeTechnicalSkillScalarFieldEnum | ResumeTechnicalSkillScalarFieldEnum[]
  }


  /**
   * Resume.softSkills
   */
  export type Resume$softSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    where?: ResumeSoftSkillWhereInput
    orderBy?: ResumeSoftSkillOrderByWithRelationInput | ResumeSoftSkillOrderByWithRelationInput[]
    cursor?: ResumeSoftSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeSoftSkillScalarFieldEnum | ResumeSoftSkillScalarFieldEnum[]
  }


  /**
   * Resume.ciapCourses
   */
  export type Resume$ciapCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    where?: ResumeCiapCourseWhereInput
    orderBy?: ResumeCiapCourseOrderByWithRelationInput | ResumeCiapCourseOrderByWithRelationInput[]
    cursor?: ResumeCiapCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeCiapCourseScalarFieldEnum | ResumeCiapCourseScalarFieldEnum[]
  }


  /**
   * Resume.positionsOfInterest
   */
  export type Resume$positionsOfInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    where?: PositionOfInterestWhereInput
    orderBy?: PositionOfInterestOrderByWithRelationInput | PositionOfInterestOrderByWithRelationInput[]
    cursor?: PositionOfInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PositionOfInterestScalarFieldEnum | PositionOfInterestScalarFieldEnum[]
  }


  /**
   * Resume.industriesOfInterest
   */
  export type Resume$industriesOfInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    where?: IndustryOfInterestWhereInput
    orderBy?: IndustryOfInterestOrderByWithRelationInput | IndustryOfInterestOrderByWithRelationInput[]
    cursor?: IndustryOfInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndustryOfInterestScalarFieldEnum | IndustryOfInterestScalarFieldEnum[]
  }


  /**
   * Resume without action
   */
  export type ResumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeInclude<ExtArgs> | null
  }



  /**
   * Model CiapCourse
   */

  export type AggregateCiapCourse = {
    _count: CiapCourseCountAggregateOutputType | null
    _min: CiapCourseMinAggregateOutputType | null
    _max: CiapCourseMaxAggregateOutputType | null
  }

  export type CiapCourseMinAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
  }

  export type CiapCourseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
  }

  export type CiapCourseCountAggregateOutputType = {
    id: number
    name: number
    date: number
    _all: number
  }


  export type CiapCourseMinAggregateInputType = {
    id?: true
    name?: true
    date?: true
  }

  export type CiapCourseMaxAggregateInputType = {
    id?: true
    name?: true
    date?: true
  }

  export type CiapCourseCountAggregateInputType = {
    id?: true
    name?: true
    date?: true
    _all?: true
  }

  export type CiapCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CiapCourse to aggregate.
     */
    where?: CiapCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CiapCourses to fetch.
     */
    orderBy?: CiapCourseOrderByWithRelationInput | CiapCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CiapCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CiapCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CiapCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CiapCourses
    **/
    _count?: true | CiapCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CiapCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CiapCourseMaxAggregateInputType
  }

  export type GetCiapCourseAggregateType<T extends CiapCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCiapCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCiapCourse[P]>
      : GetScalarType<T[P], AggregateCiapCourse[P]>
  }




  export type CiapCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CiapCourseWhereInput
    orderBy?: CiapCourseOrderByWithAggregationInput | CiapCourseOrderByWithAggregationInput[]
    by: CiapCourseScalarFieldEnum[] | CiapCourseScalarFieldEnum
    having?: CiapCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CiapCourseCountAggregateInputType | true
    _min?: CiapCourseMinAggregateInputType
    _max?: CiapCourseMaxAggregateInputType
  }

  export type CiapCourseGroupByOutputType = {
    id: string
    name: string
    date: Date
    _count: CiapCourseCountAggregateOutputType | null
    _min: CiapCourseMinAggregateOutputType | null
    _max: CiapCourseMaxAggregateOutputType | null
  }

  type GetCiapCourseGroupByPayload<T extends CiapCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CiapCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CiapCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CiapCourseGroupByOutputType[P]>
            : GetScalarType<T[P], CiapCourseGroupByOutputType[P]>
        }
      >
    >


  export type CiapCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    resumesListingThis?: boolean | CiapCourse$resumesListingThisArgs<ExtArgs>
    _count?: boolean | CiapCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ciapCourse"]>

  export type CiapCourseSelectScalar = {
    id?: boolean
    name?: boolean
    date?: boolean
  }

  export type CiapCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resumesListingThis?: boolean | CiapCourse$resumesListingThisArgs<ExtArgs>
    _count?: boolean | CiapCourseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CiapCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CiapCourse"
    objects: {
      resumesListingThis: Prisma.$ResumeCiapCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      date: Date
    }, ExtArgs["result"]["ciapCourse"]>
    composites: {}
  }


  type CiapCourseGetPayload<S extends boolean | null | undefined | CiapCourseDefaultArgs> = $Result.GetResult<Prisma.$CiapCoursePayload, S>

  type CiapCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CiapCourseFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CiapCourseCountAggregateInputType | true
    }

  export interface CiapCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CiapCourse'], meta: { name: 'CiapCourse' } }
    /**
     * Find zero or one CiapCourse that matches the filter.
     * @param {CiapCourseFindUniqueArgs} args - Arguments to find a CiapCourse
     * @example
     * // Get one CiapCourse
     * const ciapCourse = await prisma.ciapCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CiapCourseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CiapCourseFindUniqueArgs<ExtArgs>>
    ): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CiapCourse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CiapCourseFindUniqueOrThrowArgs} args - Arguments to find a CiapCourse
     * @example
     * // Get one CiapCourse
     * const ciapCourse = await prisma.ciapCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CiapCourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CiapCourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CiapCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiapCourseFindFirstArgs} args - Arguments to find a CiapCourse
     * @example
     * // Get one CiapCourse
     * const ciapCourse = await prisma.ciapCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CiapCourseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CiapCourseFindFirstArgs<ExtArgs>>
    ): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CiapCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiapCourseFindFirstOrThrowArgs} args - Arguments to find a CiapCourse
     * @example
     * // Get one CiapCourse
     * const ciapCourse = await prisma.ciapCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CiapCourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CiapCourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CiapCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiapCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CiapCourses
     * const ciapCourses = await prisma.ciapCourse.findMany()
     * 
     * // Get first 10 CiapCourses
     * const ciapCourses = await prisma.ciapCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ciapCourseWithIdOnly = await prisma.ciapCourse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CiapCourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CiapCourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CiapCourse.
     * @param {CiapCourseCreateArgs} args - Arguments to create a CiapCourse.
     * @example
     * // Create one CiapCourse
     * const CiapCourse = await prisma.ciapCourse.create({
     *   data: {
     *     // ... data to create a CiapCourse
     *   }
     * })
     * 
    **/
    create<T extends CiapCourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CiapCourseCreateArgs<ExtArgs>>
    ): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CiapCourses.
     *     @param {CiapCourseCreateManyArgs} args - Arguments to create many CiapCourses.
     *     @example
     *     // Create many CiapCourses
     *     const ciapCourse = await prisma.ciapCourse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CiapCourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CiapCourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CiapCourse.
     * @param {CiapCourseDeleteArgs} args - Arguments to delete one CiapCourse.
     * @example
     * // Delete one CiapCourse
     * const CiapCourse = await prisma.ciapCourse.delete({
     *   where: {
     *     // ... filter to delete one CiapCourse
     *   }
     * })
     * 
    **/
    delete<T extends CiapCourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CiapCourseDeleteArgs<ExtArgs>>
    ): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CiapCourse.
     * @param {CiapCourseUpdateArgs} args - Arguments to update one CiapCourse.
     * @example
     * // Update one CiapCourse
     * const ciapCourse = await prisma.ciapCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CiapCourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CiapCourseUpdateArgs<ExtArgs>>
    ): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CiapCourses.
     * @param {CiapCourseDeleteManyArgs} args - Arguments to filter CiapCourses to delete.
     * @example
     * // Delete a few CiapCourses
     * const { count } = await prisma.ciapCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CiapCourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CiapCourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CiapCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiapCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CiapCourses
     * const ciapCourse = await prisma.ciapCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CiapCourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CiapCourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CiapCourse.
     * @param {CiapCourseUpsertArgs} args - Arguments to update or create a CiapCourse.
     * @example
     * // Update or create a CiapCourse
     * const ciapCourse = await prisma.ciapCourse.upsert({
     *   create: {
     *     // ... data to create a CiapCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CiapCourse we want to update
     *   }
     * })
    **/
    upsert<T extends CiapCourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CiapCourseUpsertArgs<ExtArgs>>
    ): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CiapCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiapCourseCountArgs} args - Arguments to filter CiapCourses to count.
     * @example
     * // Count the number of CiapCourses
     * const count = await prisma.ciapCourse.count({
     *   where: {
     *     // ... the filter for the CiapCourses we want to count
     *   }
     * })
    **/
    count<T extends CiapCourseCountArgs>(
      args?: Subset<T, CiapCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CiapCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CiapCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiapCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CiapCourseAggregateArgs>(args: Subset<T, CiapCourseAggregateArgs>): Prisma.PrismaPromise<GetCiapCourseAggregateType<T>>

    /**
     * Group by CiapCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiapCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CiapCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CiapCourseGroupByArgs['orderBy'] }
        : { orderBy?: CiapCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CiapCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCiapCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CiapCourse model
   */
  readonly fields: CiapCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CiapCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CiapCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resumesListingThis<T extends CiapCourse$resumesListingThisArgs<ExtArgs> = {}>(args?: Subset<T, CiapCourse$resumesListingThisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CiapCourse model
   */ 
  interface CiapCourseFieldRefs {
    readonly id: FieldRef<"CiapCourse", 'String'>
    readonly name: FieldRef<"CiapCourse", 'String'>
    readonly date: FieldRef<"CiapCourse", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CiapCourse findUnique
   */
  export type CiapCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which CiapCourse to fetch.
     */
    where: CiapCourseWhereUniqueInput
  }


  /**
   * CiapCourse findUniqueOrThrow
   */
  export type CiapCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which CiapCourse to fetch.
     */
    where: CiapCourseWhereUniqueInput
  }


  /**
   * CiapCourse findFirst
   */
  export type CiapCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which CiapCourse to fetch.
     */
    where?: CiapCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CiapCourses to fetch.
     */
    orderBy?: CiapCourseOrderByWithRelationInput | CiapCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CiapCourses.
     */
    cursor?: CiapCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CiapCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CiapCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CiapCourses.
     */
    distinct?: CiapCourseScalarFieldEnum | CiapCourseScalarFieldEnum[]
  }


  /**
   * CiapCourse findFirstOrThrow
   */
  export type CiapCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which CiapCourse to fetch.
     */
    where?: CiapCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CiapCourses to fetch.
     */
    orderBy?: CiapCourseOrderByWithRelationInput | CiapCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CiapCourses.
     */
    cursor?: CiapCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CiapCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CiapCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CiapCourses.
     */
    distinct?: CiapCourseScalarFieldEnum | CiapCourseScalarFieldEnum[]
  }


  /**
   * CiapCourse findMany
   */
  export type CiapCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which CiapCourses to fetch.
     */
    where?: CiapCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CiapCourses to fetch.
     */
    orderBy?: CiapCourseOrderByWithRelationInput | CiapCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CiapCourses.
     */
    cursor?: CiapCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CiapCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CiapCourses.
     */
    skip?: number
    distinct?: CiapCourseScalarFieldEnum | CiapCourseScalarFieldEnum[]
  }


  /**
   * CiapCourse create
   */
  export type CiapCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a CiapCourse.
     */
    data: XOR<CiapCourseCreateInput, CiapCourseUncheckedCreateInput>
  }


  /**
   * CiapCourse createMany
   */
  export type CiapCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CiapCourses.
     */
    data: CiapCourseCreateManyInput | CiapCourseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CiapCourse update
   */
  export type CiapCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a CiapCourse.
     */
    data: XOR<CiapCourseUpdateInput, CiapCourseUncheckedUpdateInput>
    /**
     * Choose, which CiapCourse to update.
     */
    where: CiapCourseWhereUniqueInput
  }


  /**
   * CiapCourse updateMany
   */
  export type CiapCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CiapCourses.
     */
    data: XOR<CiapCourseUpdateManyMutationInput, CiapCourseUncheckedUpdateManyInput>
    /**
     * Filter which CiapCourses to update
     */
    where?: CiapCourseWhereInput
  }


  /**
   * CiapCourse upsert
   */
  export type CiapCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the CiapCourse to update in case it exists.
     */
    where: CiapCourseWhereUniqueInput
    /**
     * In case the CiapCourse found by the `where` argument doesn't exist, create a new CiapCourse with this data.
     */
    create: XOR<CiapCourseCreateInput, CiapCourseUncheckedCreateInput>
    /**
     * In case the CiapCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CiapCourseUpdateInput, CiapCourseUncheckedUpdateInput>
  }


  /**
   * CiapCourse delete
   */
  export type CiapCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
    /**
     * Filter which CiapCourse to delete.
     */
    where: CiapCourseWhereUniqueInput
  }


  /**
   * CiapCourse deleteMany
   */
  export type CiapCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CiapCourses to delete
     */
    where?: CiapCourseWhereInput
  }


  /**
   * CiapCourse.resumesListingThis
   */
  export type CiapCourse$resumesListingThisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    where?: ResumeCiapCourseWhereInput
    orderBy?: ResumeCiapCourseOrderByWithRelationInput | ResumeCiapCourseOrderByWithRelationInput[]
    cursor?: ResumeCiapCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeCiapCourseScalarFieldEnum | ResumeCiapCourseScalarFieldEnum[]
  }


  /**
   * CiapCourse without action
   */
  export type CiapCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiapCourse
     */
    select?: CiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CiapCourseInclude<ExtArgs> | null
  }



  /**
   * Model ResumeCiapCourse
   */

  export type AggregateResumeCiapCourse = {
    _count: ResumeCiapCourseCountAggregateOutputType | null
    _min: ResumeCiapCourseMinAggregateOutputType | null
    _max: ResumeCiapCourseMaxAggregateOutputType | null
  }

  export type ResumeCiapCourseMinAggregateOutputType = {
    resumeOwnerEmail: string | null
    courseId: string | null
    isVisible: boolean | null
  }

  export type ResumeCiapCourseMaxAggregateOutputType = {
    resumeOwnerEmail: string | null
    courseId: string | null
    isVisible: boolean | null
  }

  export type ResumeCiapCourseCountAggregateOutputType = {
    resumeOwnerEmail: number
    courseId: number
    isVisible: number
    _all: number
  }


  export type ResumeCiapCourseMinAggregateInputType = {
    resumeOwnerEmail?: true
    courseId?: true
    isVisible?: true
  }

  export type ResumeCiapCourseMaxAggregateInputType = {
    resumeOwnerEmail?: true
    courseId?: true
    isVisible?: true
  }

  export type ResumeCiapCourseCountAggregateInputType = {
    resumeOwnerEmail?: true
    courseId?: true
    isVisible?: true
    _all?: true
  }

  export type ResumeCiapCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeCiapCourse to aggregate.
     */
    where?: ResumeCiapCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeCiapCourses to fetch.
     */
    orderBy?: ResumeCiapCourseOrderByWithRelationInput | ResumeCiapCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeCiapCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeCiapCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeCiapCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeCiapCourses
    **/
    _count?: true | ResumeCiapCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeCiapCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeCiapCourseMaxAggregateInputType
  }

  export type GetResumeCiapCourseAggregateType<T extends ResumeCiapCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeCiapCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeCiapCourse[P]>
      : GetScalarType<T[P], AggregateResumeCiapCourse[P]>
  }




  export type ResumeCiapCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeCiapCourseWhereInput
    orderBy?: ResumeCiapCourseOrderByWithAggregationInput | ResumeCiapCourseOrderByWithAggregationInput[]
    by: ResumeCiapCourseScalarFieldEnum[] | ResumeCiapCourseScalarFieldEnum
    having?: ResumeCiapCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeCiapCourseCountAggregateInputType | true
    _min?: ResumeCiapCourseMinAggregateInputType
    _max?: ResumeCiapCourseMaxAggregateInputType
  }

  export type ResumeCiapCourseGroupByOutputType = {
    resumeOwnerEmail: string
    courseId: string
    isVisible: boolean
    _count: ResumeCiapCourseCountAggregateOutputType | null
    _min: ResumeCiapCourseMinAggregateOutputType | null
    _max: ResumeCiapCourseMaxAggregateOutputType | null
  }

  type GetResumeCiapCourseGroupByPayload<T extends ResumeCiapCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeCiapCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeCiapCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeCiapCourseGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeCiapCourseGroupByOutputType[P]>
        }
      >
    >


  export type ResumeCiapCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resumeOwnerEmail?: boolean
    courseId?: boolean
    isVisible?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    course?: boolean | CiapCourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeCiapCourse"]>

  export type ResumeCiapCourseSelectScalar = {
    resumeOwnerEmail?: boolean
    courseId?: boolean
    isVisible?: boolean
  }

  export type ResumeCiapCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    course?: boolean | CiapCourseDefaultArgs<ExtArgs>
  }


  export type $ResumeCiapCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeCiapCourse"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
      course: Prisma.$CiapCoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resumeOwnerEmail: string
      courseId: string
      isVisible: boolean
    }, ExtArgs["result"]["resumeCiapCourse"]>
    composites: {}
  }


  type ResumeCiapCourseGetPayload<S extends boolean | null | undefined | ResumeCiapCourseDefaultArgs> = $Result.GetResult<Prisma.$ResumeCiapCoursePayload, S>

  type ResumeCiapCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResumeCiapCourseFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ResumeCiapCourseCountAggregateInputType | true
    }

  export interface ResumeCiapCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeCiapCourse'], meta: { name: 'ResumeCiapCourse' } }
    /**
     * Find zero or one ResumeCiapCourse that matches the filter.
     * @param {ResumeCiapCourseFindUniqueArgs} args - Arguments to find a ResumeCiapCourse
     * @example
     * // Get one ResumeCiapCourse
     * const resumeCiapCourse = await prisma.resumeCiapCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumeCiapCourseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeCiapCourseFindUniqueArgs<ExtArgs>>
    ): Prisma__ResumeCiapCourseClient<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ResumeCiapCourse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResumeCiapCourseFindUniqueOrThrowArgs} args - Arguments to find a ResumeCiapCourse
     * @example
     * // Get one ResumeCiapCourse
     * const resumeCiapCourse = await prisma.resumeCiapCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumeCiapCourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeCiapCourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeCiapCourseClient<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ResumeCiapCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCiapCourseFindFirstArgs} args - Arguments to find a ResumeCiapCourse
     * @example
     * // Get one ResumeCiapCourse
     * const resumeCiapCourse = await prisma.resumeCiapCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumeCiapCourseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeCiapCourseFindFirstArgs<ExtArgs>>
    ): Prisma__ResumeCiapCourseClient<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ResumeCiapCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCiapCourseFindFirstOrThrowArgs} args - Arguments to find a ResumeCiapCourse
     * @example
     * // Get one ResumeCiapCourse
     * const resumeCiapCourse = await prisma.resumeCiapCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumeCiapCourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeCiapCourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeCiapCourseClient<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ResumeCiapCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCiapCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeCiapCourses
     * const resumeCiapCourses = await prisma.resumeCiapCourse.findMany()
     * 
     * // Get first 10 ResumeCiapCourses
     * const resumeCiapCourses = await prisma.resumeCiapCourse.findMany({ take: 10 })
     * 
     * // Only select the `resumeOwnerEmail`
     * const resumeCiapCourseWithResumeOwnerEmailOnly = await prisma.resumeCiapCourse.findMany({ select: { resumeOwnerEmail: true } })
     * 
    **/
    findMany<T extends ResumeCiapCourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeCiapCourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ResumeCiapCourse.
     * @param {ResumeCiapCourseCreateArgs} args - Arguments to create a ResumeCiapCourse.
     * @example
     * // Create one ResumeCiapCourse
     * const ResumeCiapCourse = await prisma.resumeCiapCourse.create({
     *   data: {
     *     // ... data to create a ResumeCiapCourse
     *   }
     * })
     * 
    **/
    create<T extends ResumeCiapCourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeCiapCourseCreateArgs<ExtArgs>>
    ): Prisma__ResumeCiapCourseClient<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ResumeCiapCourses.
     *     @param {ResumeCiapCourseCreateManyArgs} args - Arguments to create many ResumeCiapCourses.
     *     @example
     *     // Create many ResumeCiapCourses
     *     const resumeCiapCourse = await prisma.resumeCiapCourse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumeCiapCourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeCiapCourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResumeCiapCourse.
     * @param {ResumeCiapCourseDeleteArgs} args - Arguments to delete one ResumeCiapCourse.
     * @example
     * // Delete one ResumeCiapCourse
     * const ResumeCiapCourse = await prisma.resumeCiapCourse.delete({
     *   where: {
     *     // ... filter to delete one ResumeCiapCourse
     *   }
     * })
     * 
    **/
    delete<T extends ResumeCiapCourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeCiapCourseDeleteArgs<ExtArgs>>
    ): Prisma__ResumeCiapCourseClient<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ResumeCiapCourse.
     * @param {ResumeCiapCourseUpdateArgs} args - Arguments to update one ResumeCiapCourse.
     * @example
     * // Update one ResumeCiapCourse
     * const resumeCiapCourse = await prisma.resumeCiapCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumeCiapCourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeCiapCourseUpdateArgs<ExtArgs>>
    ): Prisma__ResumeCiapCourseClient<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ResumeCiapCourses.
     * @param {ResumeCiapCourseDeleteManyArgs} args - Arguments to filter ResumeCiapCourses to delete.
     * @example
     * // Delete a few ResumeCiapCourses
     * const { count } = await prisma.resumeCiapCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumeCiapCourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeCiapCourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeCiapCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCiapCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeCiapCourses
     * const resumeCiapCourse = await prisma.resumeCiapCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumeCiapCourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeCiapCourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumeCiapCourse.
     * @param {ResumeCiapCourseUpsertArgs} args - Arguments to update or create a ResumeCiapCourse.
     * @example
     * // Update or create a ResumeCiapCourse
     * const resumeCiapCourse = await prisma.resumeCiapCourse.upsert({
     *   create: {
     *     // ... data to create a ResumeCiapCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeCiapCourse we want to update
     *   }
     * })
    **/
    upsert<T extends ResumeCiapCourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeCiapCourseUpsertArgs<ExtArgs>>
    ): Prisma__ResumeCiapCourseClient<$Result.GetResult<Prisma.$ResumeCiapCoursePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ResumeCiapCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCiapCourseCountArgs} args - Arguments to filter ResumeCiapCourses to count.
     * @example
     * // Count the number of ResumeCiapCourses
     * const count = await prisma.resumeCiapCourse.count({
     *   where: {
     *     // ... the filter for the ResumeCiapCourses we want to count
     *   }
     * })
    **/
    count<T extends ResumeCiapCourseCountArgs>(
      args?: Subset<T, ResumeCiapCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeCiapCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeCiapCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCiapCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeCiapCourseAggregateArgs>(args: Subset<T, ResumeCiapCourseAggregateArgs>): Prisma.PrismaPromise<GetResumeCiapCourseAggregateType<T>>

    /**
     * Group by ResumeCiapCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCiapCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeCiapCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeCiapCourseGroupByArgs['orderBy'] }
        : { orderBy?: ResumeCiapCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeCiapCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeCiapCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeCiapCourse model
   */
  readonly fields: ResumeCiapCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeCiapCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeCiapCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    course<T extends CiapCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CiapCourseDefaultArgs<ExtArgs>>): Prisma__CiapCourseClient<$Result.GetResult<Prisma.$CiapCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ResumeCiapCourse model
   */ 
  interface ResumeCiapCourseFieldRefs {
    readonly resumeOwnerEmail: FieldRef<"ResumeCiapCourse", 'String'>
    readonly courseId: FieldRef<"ResumeCiapCourse", 'String'>
    readonly isVisible: FieldRef<"ResumeCiapCourse", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ResumeCiapCourse findUnique
   */
  export type ResumeCiapCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which ResumeCiapCourse to fetch.
     */
    where: ResumeCiapCourseWhereUniqueInput
  }


  /**
   * ResumeCiapCourse findUniqueOrThrow
   */
  export type ResumeCiapCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which ResumeCiapCourse to fetch.
     */
    where: ResumeCiapCourseWhereUniqueInput
  }


  /**
   * ResumeCiapCourse findFirst
   */
  export type ResumeCiapCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which ResumeCiapCourse to fetch.
     */
    where?: ResumeCiapCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeCiapCourses to fetch.
     */
    orderBy?: ResumeCiapCourseOrderByWithRelationInput | ResumeCiapCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeCiapCourses.
     */
    cursor?: ResumeCiapCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeCiapCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeCiapCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeCiapCourses.
     */
    distinct?: ResumeCiapCourseScalarFieldEnum | ResumeCiapCourseScalarFieldEnum[]
  }


  /**
   * ResumeCiapCourse findFirstOrThrow
   */
  export type ResumeCiapCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which ResumeCiapCourse to fetch.
     */
    where?: ResumeCiapCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeCiapCourses to fetch.
     */
    orderBy?: ResumeCiapCourseOrderByWithRelationInput | ResumeCiapCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeCiapCourses.
     */
    cursor?: ResumeCiapCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeCiapCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeCiapCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeCiapCourses.
     */
    distinct?: ResumeCiapCourseScalarFieldEnum | ResumeCiapCourseScalarFieldEnum[]
  }


  /**
   * ResumeCiapCourse findMany
   */
  export type ResumeCiapCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * Filter, which ResumeCiapCourses to fetch.
     */
    where?: ResumeCiapCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeCiapCourses to fetch.
     */
    orderBy?: ResumeCiapCourseOrderByWithRelationInput | ResumeCiapCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeCiapCourses.
     */
    cursor?: ResumeCiapCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeCiapCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeCiapCourses.
     */
    skip?: number
    distinct?: ResumeCiapCourseScalarFieldEnum | ResumeCiapCourseScalarFieldEnum[]
  }


  /**
   * ResumeCiapCourse create
   */
  export type ResumeCiapCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeCiapCourse.
     */
    data: XOR<ResumeCiapCourseCreateInput, ResumeCiapCourseUncheckedCreateInput>
  }


  /**
   * ResumeCiapCourse createMany
   */
  export type ResumeCiapCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeCiapCourses.
     */
    data: ResumeCiapCourseCreateManyInput | ResumeCiapCourseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ResumeCiapCourse update
   */
  export type ResumeCiapCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeCiapCourse.
     */
    data: XOR<ResumeCiapCourseUpdateInput, ResumeCiapCourseUncheckedUpdateInput>
    /**
     * Choose, which ResumeCiapCourse to update.
     */
    where: ResumeCiapCourseWhereUniqueInput
  }


  /**
   * ResumeCiapCourse updateMany
   */
  export type ResumeCiapCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeCiapCourses.
     */
    data: XOR<ResumeCiapCourseUpdateManyMutationInput, ResumeCiapCourseUncheckedUpdateManyInput>
    /**
     * Filter which ResumeCiapCourses to update
     */
    where?: ResumeCiapCourseWhereInput
  }


  /**
   * ResumeCiapCourse upsert
   */
  export type ResumeCiapCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeCiapCourse to update in case it exists.
     */
    where: ResumeCiapCourseWhereUniqueInput
    /**
     * In case the ResumeCiapCourse found by the `where` argument doesn't exist, create a new ResumeCiapCourse with this data.
     */
    create: XOR<ResumeCiapCourseCreateInput, ResumeCiapCourseUncheckedCreateInput>
    /**
     * In case the ResumeCiapCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeCiapCourseUpdateInput, ResumeCiapCourseUncheckedUpdateInput>
  }


  /**
   * ResumeCiapCourse delete
   */
  export type ResumeCiapCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
    /**
     * Filter which ResumeCiapCourse to delete.
     */
    where: ResumeCiapCourseWhereUniqueInput
  }


  /**
   * ResumeCiapCourse deleteMany
   */
  export type ResumeCiapCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeCiapCourses to delete
     */
    where?: ResumeCiapCourseWhereInput
  }


  /**
   * ResumeCiapCourse without action
   */
  export type ResumeCiapCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCiapCourse
     */
    select?: ResumeCiapCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeCiapCourseInclude<ExtArgs> | null
  }



  /**
   * Model SoftSkill
   */

  export type AggregateSoftSkill = {
    _count: SoftSkillCountAggregateOutputType | null
    _min: SoftSkillMinAggregateOutputType | null
    _max: SoftSkillMaxAggregateOutputType | null
  }

  export type SoftSkillMinAggregateOutputType = {
    name: string | null
  }

  export type SoftSkillMaxAggregateOutputType = {
    name: string | null
  }

  export type SoftSkillCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type SoftSkillMinAggregateInputType = {
    name?: true
  }

  export type SoftSkillMaxAggregateInputType = {
    name?: true
  }

  export type SoftSkillCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type SoftSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoftSkill to aggregate.
     */
    where?: SoftSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoftSkills to fetch.
     */
    orderBy?: SoftSkillOrderByWithRelationInput | SoftSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoftSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoftSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoftSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SoftSkills
    **/
    _count?: true | SoftSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoftSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoftSkillMaxAggregateInputType
  }

  export type GetSoftSkillAggregateType<T extends SoftSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSoftSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoftSkill[P]>
      : GetScalarType<T[P], AggregateSoftSkill[P]>
  }




  export type SoftSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoftSkillWhereInput
    orderBy?: SoftSkillOrderByWithAggregationInput | SoftSkillOrderByWithAggregationInput[]
    by: SoftSkillScalarFieldEnum[] | SoftSkillScalarFieldEnum
    having?: SoftSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoftSkillCountAggregateInputType | true
    _min?: SoftSkillMinAggregateInputType
    _max?: SoftSkillMaxAggregateInputType
  }

  export type SoftSkillGroupByOutputType = {
    name: string
    _count: SoftSkillCountAggregateOutputType | null
    _min: SoftSkillMinAggregateOutputType | null
    _max: SoftSkillMaxAggregateOutputType | null
  }

  type GetSoftSkillGroupByPayload<T extends SoftSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoftSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoftSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoftSkillGroupByOutputType[P]>
            : GetScalarType<T[P], SoftSkillGroupByOutputType[P]>
        }
      >
    >


  export type SoftSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    resumesListingThis?: boolean | SoftSkill$resumesListingThisArgs<ExtArgs>
    _count?: boolean | SoftSkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["softSkill"]>

  export type SoftSkillSelectScalar = {
    name?: boolean
  }

  export type SoftSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resumesListingThis?: boolean | SoftSkill$resumesListingThisArgs<ExtArgs>
    _count?: boolean | SoftSkillCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SoftSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SoftSkill"
    objects: {
      resumesListingThis: Prisma.$ResumeSoftSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
    }, ExtArgs["result"]["softSkill"]>
    composites: {}
  }


  type SoftSkillGetPayload<S extends boolean | null | undefined | SoftSkillDefaultArgs> = $Result.GetResult<Prisma.$SoftSkillPayload, S>

  type SoftSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SoftSkillFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SoftSkillCountAggregateInputType | true
    }

  export interface SoftSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SoftSkill'], meta: { name: 'SoftSkill' } }
    /**
     * Find zero or one SoftSkill that matches the filter.
     * @param {SoftSkillFindUniqueArgs} args - Arguments to find a SoftSkill
     * @example
     * // Get one SoftSkill
     * const softSkill = await prisma.softSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SoftSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SoftSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SoftSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SoftSkillFindUniqueOrThrowArgs} args - Arguments to find a SoftSkill
     * @example
     * // Get one SoftSkill
     * const softSkill = await prisma.softSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SoftSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SoftSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftSkillFindFirstArgs} args - Arguments to find a SoftSkill
     * @example
     * // Get one SoftSkill
     * const softSkill = await prisma.softSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SoftSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftSkillFindFirstArgs<ExtArgs>>
    ): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SoftSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftSkillFindFirstOrThrowArgs} args - Arguments to find a SoftSkill
     * @example
     * // Get one SoftSkill
     * const softSkill = await prisma.softSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SoftSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SoftSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SoftSkills
     * const softSkills = await prisma.softSkill.findMany()
     * 
     * // Get first 10 SoftSkills
     * const softSkills = await prisma.softSkill.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const softSkillWithNameOnly = await prisma.softSkill.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends SoftSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SoftSkill.
     * @param {SoftSkillCreateArgs} args - Arguments to create a SoftSkill.
     * @example
     * // Create one SoftSkill
     * const SoftSkill = await prisma.softSkill.create({
     *   data: {
     *     // ... data to create a SoftSkill
     *   }
     * })
     * 
    **/
    create<T extends SoftSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SoftSkillCreateArgs<ExtArgs>>
    ): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SoftSkills.
     *     @param {SoftSkillCreateManyArgs} args - Arguments to create many SoftSkills.
     *     @example
     *     // Create many SoftSkills
     *     const softSkill = await prisma.softSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SoftSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SoftSkill.
     * @param {SoftSkillDeleteArgs} args - Arguments to delete one SoftSkill.
     * @example
     * // Delete one SoftSkill
     * const SoftSkill = await prisma.softSkill.delete({
     *   where: {
     *     // ... filter to delete one SoftSkill
     *   }
     * })
     * 
    **/
    delete<T extends SoftSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SoftSkillDeleteArgs<ExtArgs>>
    ): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SoftSkill.
     * @param {SoftSkillUpdateArgs} args - Arguments to update one SoftSkill.
     * @example
     * // Update one SoftSkill
     * const softSkill = await prisma.softSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SoftSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SoftSkillUpdateArgs<ExtArgs>>
    ): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SoftSkills.
     * @param {SoftSkillDeleteManyArgs} args - Arguments to filter SoftSkills to delete.
     * @example
     * // Delete a few SoftSkills
     * const { count } = await prisma.softSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SoftSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SoftSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoftSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SoftSkills
     * const softSkill = await prisma.softSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SoftSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SoftSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SoftSkill.
     * @param {SoftSkillUpsertArgs} args - Arguments to update or create a SoftSkill.
     * @example
     * // Update or create a SoftSkill
     * const softSkill = await prisma.softSkill.upsert({
     *   create: {
     *     // ... data to create a SoftSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SoftSkill we want to update
     *   }
     * })
    **/
    upsert<T extends SoftSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SoftSkillUpsertArgs<ExtArgs>>
    ): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SoftSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftSkillCountArgs} args - Arguments to filter SoftSkills to count.
     * @example
     * // Count the number of SoftSkills
     * const count = await prisma.softSkill.count({
     *   where: {
     *     // ... the filter for the SoftSkills we want to count
     *   }
     * })
    **/
    count<T extends SoftSkillCountArgs>(
      args?: Subset<T, SoftSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoftSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SoftSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoftSkillAggregateArgs>(args: Subset<T, SoftSkillAggregateArgs>): Prisma.PrismaPromise<GetSoftSkillAggregateType<T>>

    /**
     * Group by SoftSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoftSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoftSkillGroupByArgs['orderBy'] }
        : { orderBy?: SoftSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoftSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoftSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SoftSkill model
   */
  readonly fields: SoftSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SoftSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoftSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resumesListingThis<T extends SoftSkill$resumesListingThisArgs<ExtArgs> = {}>(args?: Subset<T, SoftSkill$resumesListingThisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SoftSkill model
   */ 
  interface SoftSkillFieldRefs {
    readonly name: FieldRef<"SoftSkill", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SoftSkill findUnique
   */
  export type SoftSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which SoftSkill to fetch.
     */
    where: SoftSkillWhereUniqueInput
  }


  /**
   * SoftSkill findUniqueOrThrow
   */
  export type SoftSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which SoftSkill to fetch.
     */
    where: SoftSkillWhereUniqueInput
  }


  /**
   * SoftSkill findFirst
   */
  export type SoftSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which SoftSkill to fetch.
     */
    where?: SoftSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoftSkills to fetch.
     */
    orderBy?: SoftSkillOrderByWithRelationInput | SoftSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoftSkills.
     */
    cursor?: SoftSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoftSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoftSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoftSkills.
     */
    distinct?: SoftSkillScalarFieldEnum | SoftSkillScalarFieldEnum[]
  }


  /**
   * SoftSkill findFirstOrThrow
   */
  export type SoftSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which SoftSkill to fetch.
     */
    where?: SoftSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoftSkills to fetch.
     */
    orderBy?: SoftSkillOrderByWithRelationInput | SoftSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoftSkills.
     */
    cursor?: SoftSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoftSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoftSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoftSkills.
     */
    distinct?: SoftSkillScalarFieldEnum | SoftSkillScalarFieldEnum[]
  }


  /**
   * SoftSkill findMany
   */
  export type SoftSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which SoftSkills to fetch.
     */
    where?: SoftSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoftSkills to fetch.
     */
    orderBy?: SoftSkillOrderByWithRelationInput | SoftSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SoftSkills.
     */
    cursor?: SoftSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoftSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoftSkills.
     */
    skip?: number
    distinct?: SoftSkillScalarFieldEnum | SoftSkillScalarFieldEnum[]
  }


  /**
   * SoftSkill create
   */
  export type SoftSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a SoftSkill.
     */
    data: XOR<SoftSkillCreateInput, SoftSkillUncheckedCreateInput>
  }


  /**
   * SoftSkill createMany
   */
  export type SoftSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SoftSkills.
     */
    data: SoftSkillCreateManyInput | SoftSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SoftSkill update
   */
  export type SoftSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a SoftSkill.
     */
    data: XOR<SoftSkillUpdateInput, SoftSkillUncheckedUpdateInput>
    /**
     * Choose, which SoftSkill to update.
     */
    where: SoftSkillWhereUniqueInput
  }


  /**
   * SoftSkill updateMany
   */
  export type SoftSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SoftSkills.
     */
    data: XOR<SoftSkillUpdateManyMutationInput, SoftSkillUncheckedUpdateManyInput>
    /**
     * Filter which SoftSkills to update
     */
    where?: SoftSkillWhereInput
  }


  /**
   * SoftSkill upsert
   */
  export type SoftSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the SoftSkill to update in case it exists.
     */
    where: SoftSkillWhereUniqueInput
    /**
     * In case the SoftSkill found by the `where` argument doesn't exist, create a new SoftSkill with this data.
     */
    create: XOR<SoftSkillCreateInput, SoftSkillUncheckedCreateInput>
    /**
     * In case the SoftSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoftSkillUpdateInput, SoftSkillUncheckedUpdateInput>
  }


  /**
   * SoftSkill delete
   */
  export type SoftSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
    /**
     * Filter which SoftSkill to delete.
     */
    where: SoftSkillWhereUniqueInput
  }


  /**
   * SoftSkill deleteMany
   */
  export type SoftSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoftSkills to delete
     */
    where?: SoftSkillWhereInput
  }


  /**
   * SoftSkill.resumesListingThis
   */
  export type SoftSkill$resumesListingThisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    where?: ResumeSoftSkillWhereInput
    orderBy?: ResumeSoftSkillOrderByWithRelationInput | ResumeSoftSkillOrderByWithRelationInput[]
    cursor?: ResumeSoftSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeSoftSkillScalarFieldEnum | ResumeSoftSkillScalarFieldEnum[]
  }


  /**
   * SoftSkill without action
   */
  export type SoftSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoftSkill
     */
    select?: SoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SoftSkillInclude<ExtArgs> | null
  }



  /**
   * Model ResumeSoftSkill
   */

  export type AggregateResumeSoftSkill = {
    _count: ResumeSoftSkillCountAggregateOutputType | null
    _min: ResumeSoftSkillMinAggregateOutputType | null
    _max: ResumeSoftSkillMaxAggregateOutputType | null
  }

  export type ResumeSoftSkillMinAggregateOutputType = {
    resumeOwnerEmail: string | null
    skillName: string | null
    isVisible: boolean | null
  }

  export type ResumeSoftSkillMaxAggregateOutputType = {
    resumeOwnerEmail: string | null
    skillName: string | null
    isVisible: boolean | null
  }

  export type ResumeSoftSkillCountAggregateOutputType = {
    resumeOwnerEmail: number
    skillName: number
    isVisible: number
    _all: number
  }


  export type ResumeSoftSkillMinAggregateInputType = {
    resumeOwnerEmail?: true
    skillName?: true
    isVisible?: true
  }

  export type ResumeSoftSkillMaxAggregateInputType = {
    resumeOwnerEmail?: true
    skillName?: true
    isVisible?: true
  }

  export type ResumeSoftSkillCountAggregateInputType = {
    resumeOwnerEmail?: true
    skillName?: true
    isVisible?: true
    _all?: true
  }

  export type ResumeSoftSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeSoftSkill to aggregate.
     */
    where?: ResumeSoftSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeSoftSkills to fetch.
     */
    orderBy?: ResumeSoftSkillOrderByWithRelationInput | ResumeSoftSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeSoftSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeSoftSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeSoftSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeSoftSkills
    **/
    _count?: true | ResumeSoftSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeSoftSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeSoftSkillMaxAggregateInputType
  }

  export type GetResumeSoftSkillAggregateType<T extends ResumeSoftSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeSoftSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeSoftSkill[P]>
      : GetScalarType<T[P], AggregateResumeSoftSkill[P]>
  }




  export type ResumeSoftSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeSoftSkillWhereInput
    orderBy?: ResumeSoftSkillOrderByWithAggregationInput | ResumeSoftSkillOrderByWithAggregationInput[]
    by: ResumeSoftSkillScalarFieldEnum[] | ResumeSoftSkillScalarFieldEnum
    having?: ResumeSoftSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeSoftSkillCountAggregateInputType | true
    _min?: ResumeSoftSkillMinAggregateInputType
    _max?: ResumeSoftSkillMaxAggregateInputType
  }

  export type ResumeSoftSkillGroupByOutputType = {
    resumeOwnerEmail: string
    skillName: string
    isVisible: boolean
    _count: ResumeSoftSkillCountAggregateOutputType | null
    _min: ResumeSoftSkillMinAggregateOutputType | null
    _max: ResumeSoftSkillMaxAggregateOutputType | null
  }

  type GetResumeSoftSkillGroupByPayload<T extends ResumeSoftSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeSoftSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeSoftSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeSoftSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeSoftSkillGroupByOutputType[P]>
        }
      >
    >


  export type ResumeSoftSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resumeOwnerEmail?: boolean
    skillName?: boolean
    isVisible?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | SoftSkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeSoftSkill"]>

  export type ResumeSoftSkillSelectScalar = {
    resumeOwnerEmail?: boolean
    skillName?: boolean
    isVisible?: boolean
  }

  export type ResumeSoftSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | SoftSkillDefaultArgs<ExtArgs>
  }


  export type $ResumeSoftSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeSoftSkill"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
      skill: Prisma.$SoftSkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resumeOwnerEmail: string
      skillName: string
      isVisible: boolean
    }, ExtArgs["result"]["resumeSoftSkill"]>
    composites: {}
  }


  type ResumeSoftSkillGetPayload<S extends boolean | null | undefined | ResumeSoftSkillDefaultArgs> = $Result.GetResult<Prisma.$ResumeSoftSkillPayload, S>

  type ResumeSoftSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResumeSoftSkillFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ResumeSoftSkillCountAggregateInputType | true
    }

  export interface ResumeSoftSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeSoftSkill'], meta: { name: 'ResumeSoftSkill' } }
    /**
     * Find zero or one ResumeSoftSkill that matches the filter.
     * @param {ResumeSoftSkillFindUniqueArgs} args - Arguments to find a ResumeSoftSkill
     * @example
     * // Get one ResumeSoftSkill
     * const resumeSoftSkill = await prisma.resumeSoftSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumeSoftSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeSoftSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__ResumeSoftSkillClient<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ResumeSoftSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResumeSoftSkillFindUniqueOrThrowArgs} args - Arguments to find a ResumeSoftSkill
     * @example
     * // Get one ResumeSoftSkill
     * const resumeSoftSkill = await prisma.resumeSoftSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumeSoftSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeSoftSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeSoftSkillClient<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ResumeSoftSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSoftSkillFindFirstArgs} args - Arguments to find a ResumeSoftSkill
     * @example
     * // Get one ResumeSoftSkill
     * const resumeSoftSkill = await prisma.resumeSoftSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumeSoftSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeSoftSkillFindFirstArgs<ExtArgs>>
    ): Prisma__ResumeSoftSkillClient<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ResumeSoftSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSoftSkillFindFirstOrThrowArgs} args - Arguments to find a ResumeSoftSkill
     * @example
     * // Get one ResumeSoftSkill
     * const resumeSoftSkill = await prisma.resumeSoftSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumeSoftSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeSoftSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeSoftSkillClient<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ResumeSoftSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSoftSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeSoftSkills
     * const resumeSoftSkills = await prisma.resumeSoftSkill.findMany()
     * 
     * // Get first 10 ResumeSoftSkills
     * const resumeSoftSkills = await prisma.resumeSoftSkill.findMany({ take: 10 })
     * 
     * // Only select the `resumeOwnerEmail`
     * const resumeSoftSkillWithResumeOwnerEmailOnly = await prisma.resumeSoftSkill.findMany({ select: { resumeOwnerEmail: true } })
     * 
    **/
    findMany<T extends ResumeSoftSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeSoftSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ResumeSoftSkill.
     * @param {ResumeSoftSkillCreateArgs} args - Arguments to create a ResumeSoftSkill.
     * @example
     * // Create one ResumeSoftSkill
     * const ResumeSoftSkill = await prisma.resumeSoftSkill.create({
     *   data: {
     *     // ... data to create a ResumeSoftSkill
     *   }
     * })
     * 
    **/
    create<T extends ResumeSoftSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeSoftSkillCreateArgs<ExtArgs>>
    ): Prisma__ResumeSoftSkillClient<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ResumeSoftSkills.
     *     @param {ResumeSoftSkillCreateManyArgs} args - Arguments to create many ResumeSoftSkills.
     *     @example
     *     // Create many ResumeSoftSkills
     *     const resumeSoftSkill = await prisma.resumeSoftSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumeSoftSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeSoftSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResumeSoftSkill.
     * @param {ResumeSoftSkillDeleteArgs} args - Arguments to delete one ResumeSoftSkill.
     * @example
     * // Delete one ResumeSoftSkill
     * const ResumeSoftSkill = await prisma.resumeSoftSkill.delete({
     *   where: {
     *     // ... filter to delete one ResumeSoftSkill
     *   }
     * })
     * 
    **/
    delete<T extends ResumeSoftSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeSoftSkillDeleteArgs<ExtArgs>>
    ): Prisma__ResumeSoftSkillClient<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ResumeSoftSkill.
     * @param {ResumeSoftSkillUpdateArgs} args - Arguments to update one ResumeSoftSkill.
     * @example
     * // Update one ResumeSoftSkill
     * const resumeSoftSkill = await prisma.resumeSoftSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumeSoftSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeSoftSkillUpdateArgs<ExtArgs>>
    ): Prisma__ResumeSoftSkillClient<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ResumeSoftSkills.
     * @param {ResumeSoftSkillDeleteManyArgs} args - Arguments to filter ResumeSoftSkills to delete.
     * @example
     * // Delete a few ResumeSoftSkills
     * const { count } = await prisma.resumeSoftSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumeSoftSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeSoftSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeSoftSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSoftSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeSoftSkills
     * const resumeSoftSkill = await prisma.resumeSoftSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumeSoftSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeSoftSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumeSoftSkill.
     * @param {ResumeSoftSkillUpsertArgs} args - Arguments to update or create a ResumeSoftSkill.
     * @example
     * // Update or create a ResumeSoftSkill
     * const resumeSoftSkill = await prisma.resumeSoftSkill.upsert({
     *   create: {
     *     // ... data to create a ResumeSoftSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeSoftSkill we want to update
     *   }
     * })
    **/
    upsert<T extends ResumeSoftSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeSoftSkillUpsertArgs<ExtArgs>>
    ): Prisma__ResumeSoftSkillClient<$Result.GetResult<Prisma.$ResumeSoftSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ResumeSoftSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSoftSkillCountArgs} args - Arguments to filter ResumeSoftSkills to count.
     * @example
     * // Count the number of ResumeSoftSkills
     * const count = await prisma.resumeSoftSkill.count({
     *   where: {
     *     // ... the filter for the ResumeSoftSkills we want to count
     *   }
     * })
    **/
    count<T extends ResumeSoftSkillCountArgs>(
      args?: Subset<T, ResumeSoftSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeSoftSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeSoftSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSoftSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeSoftSkillAggregateArgs>(args: Subset<T, ResumeSoftSkillAggregateArgs>): Prisma.PrismaPromise<GetResumeSoftSkillAggregateType<T>>

    /**
     * Group by ResumeSoftSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSoftSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeSoftSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeSoftSkillGroupByArgs['orderBy'] }
        : { orderBy?: ResumeSoftSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeSoftSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeSoftSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeSoftSkill model
   */
  readonly fields: ResumeSoftSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeSoftSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeSoftSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    skill<T extends SoftSkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SoftSkillDefaultArgs<ExtArgs>>): Prisma__SoftSkillClient<$Result.GetResult<Prisma.$SoftSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ResumeSoftSkill model
   */ 
  interface ResumeSoftSkillFieldRefs {
    readonly resumeOwnerEmail: FieldRef<"ResumeSoftSkill", 'String'>
    readonly skillName: FieldRef<"ResumeSoftSkill", 'String'>
    readonly isVisible: FieldRef<"ResumeSoftSkill", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ResumeSoftSkill findUnique
   */
  export type ResumeSoftSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSoftSkill to fetch.
     */
    where: ResumeSoftSkillWhereUniqueInput
  }


  /**
   * ResumeSoftSkill findUniqueOrThrow
   */
  export type ResumeSoftSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSoftSkill to fetch.
     */
    where: ResumeSoftSkillWhereUniqueInput
  }


  /**
   * ResumeSoftSkill findFirst
   */
  export type ResumeSoftSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSoftSkill to fetch.
     */
    where?: ResumeSoftSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeSoftSkills to fetch.
     */
    orderBy?: ResumeSoftSkillOrderByWithRelationInput | ResumeSoftSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeSoftSkills.
     */
    cursor?: ResumeSoftSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeSoftSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeSoftSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeSoftSkills.
     */
    distinct?: ResumeSoftSkillScalarFieldEnum | ResumeSoftSkillScalarFieldEnum[]
  }


  /**
   * ResumeSoftSkill findFirstOrThrow
   */
  export type ResumeSoftSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSoftSkill to fetch.
     */
    where?: ResumeSoftSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeSoftSkills to fetch.
     */
    orderBy?: ResumeSoftSkillOrderByWithRelationInput | ResumeSoftSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeSoftSkills.
     */
    cursor?: ResumeSoftSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeSoftSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeSoftSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeSoftSkills.
     */
    distinct?: ResumeSoftSkillScalarFieldEnum | ResumeSoftSkillScalarFieldEnum[]
  }


  /**
   * ResumeSoftSkill findMany
   */
  export type ResumeSoftSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSoftSkills to fetch.
     */
    where?: ResumeSoftSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeSoftSkills to fetch.
     */
    orderBy?: ResumeSoftSkillOrderByWithRelationInput | ResumeSoftSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeSoftSkills.
     */
    cursor?: ResumeSoftSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeSoftSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeSoftSkills.
     */
    skip?: number
    distinct?: ResumeSoftSkillScalarFieldEnum | ResumeSoftSkillScalarFieldEnum[]
  }


  /**
   * ResumeSoftSkill create
   */
  export type ResumeSoftSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeSoftSkill.
     */
    data: XOR<ResumeSoftSkillCreateInput, ResumeSoftSkillUncheckedCreateInput>
  }


  /**
   * ResumeSoftSkill createMany
   */
  export type ResumeSoftSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeSoftSkills.
     */
    data: ResumeSoftSkillCreateManyInput | ResumeSoftSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ResumeSoftSkill update
   */
  export type ResumeSoftSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeSoftSkill.
     */
    data: XOR<ResumeSoftSkillUpdateInput, ResumeSoftSkillUncheckedUpdateInput>
    /**
     * Choose, which ResumeSoftSkill to update.
     */
    where: ResumeSoftSkillWhereUniqueInput
  }


  /**
   * ResumeSoftSkill updateMany
   */
  export type ResumeSoftSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeSoftSkills.
     */
    data: XOR<ResumeSoftSkillUpdateManyMutationInput, ResumeSoftSkillUncheckedUpdateManyInput>
    /**
     * Filter which ResumeSoftSkills to update
     */
    where?: ResumeSoftSkillWhereInput
  }


  /**
   * ResumeSoftSkill upsert
   */
  export type ResumeSoftSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeSoftSkill to update in case it exists.
     */
    where: ResumeSoftSkillWhereUniqueInput
    /**
     * In case the ResumeSoftSkill found by the `where` argument doesn't exist, create a new ResumeSoftSkill with this data.
     */
    create: XOR<ResumeSoftSkillCreateInput, ResumeSoftSkillUncheckedCreateInput>
    /**
     * In case the ResumeSoftSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeSoftSkillUpdateInput, ResumeSoftSkillUncheckedUpdateInput>
  }


  /**
   * ResumeSoftSkill delete
   */
  export type ResumeSoftSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
    /**
     * Filter which ResumeSoftSkill to delete.
     */
    where: ResumeSoftSkillWhereUniqueInput
  }


  /**
   * ResumeSoftSkill deleteMany
   */
  export type ResumeSoftSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeSoftSkills to delete
     */
    where?: ResumeSoftSkillWhereInput
  }


  /**
   * ResumeSoftSkill without action
   */
  export type ResumeSoftSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSoftSkill
     */
    select?: ResumeSoftSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeSoftSkillInclude<ExtArgs> | null
  }



  /**
   * Model SkillCategory
   */

  export type AggregateSkillCategory = {
    _count: SkillCategoryCountAggregateOutputType | null
    _min: SkillCategoryMinAggregateOutputType | null
    _max: SkillCategoryMaxAggregateOutputType | null
  }

  export type SkillCategoryMinAggregateOutputType = {
    name: string | null
  }

  export type SkillCategoryMaxAggregateOutputType = {
    name: string | null
  }

  export type SkillCategoryCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type SkillCategoryMinAggregateInputType = {
    name?: true
  }

  export type SkillCategoryMaxAggregateInputType = {
    name?: true
  }

  export type SkillCategoryCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type SkillCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillCategory to aggregate.
     */
    where?: SkillCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillCategories to fetch.
     */
    orderBy?: SkillCategoryOrderByWithRelationInput | SkillCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillCategories
    **/
    _count?: true | SkillCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillCategoryMaxAggregateInputType
  }

  export type GetSkillCategoryAggregateType<T extends SkillCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillCategory[P]>
      : GetScalarType<T[P], AggregateSkillCategory[P]>
  }




  export type SkillCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillCategoryWhereInput
    orderBy?: SkillCategoryOrderByWithAggregationInput | SkillCategoryOrderByWithAggregationInput[]
    by: SkillCategoryScalarFieldEnum[] | SkillCategoryScalarFieldEnum
    having?: SkillCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCategoryCountAggregateInputType | true
    _min?: SkillCategoryMinAggregateInputType
    _max?: SkillCategoryMaxAggregateInputType
  }

  export type SkillCategoryGroupByOutputType = {
    name: string
    _count: SkillCategoryCountAggregateOutputType | null
    _min: SkillCategoryMinAggregateOutputType | null
    _max: SkillCategoryMaxAggregateOutputType | null
  }

  type GetSkillCategoryGroupByPayload<T extends SkillCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SkillCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SkillCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    technicalSkills?: boolean | SkillCategory$technicalSkillsArgs<ExtArgs>
    relatedCareers?: boolean | SkillCategory$relatedCareersArgs<ExtArgs>
    _count?: boolean | SkillCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillCategory"]>

  export type SkillCategorySelectScalar = {
    name?: boolean
  }

  export type SkillCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technicalSkills?: boolean | SkillCategory$technicalSkillsArgs<ExtArgs>
    relatedCareers?: boolean | SkillCategory$relatedCareersArgs<ExtArgs>
    _count?: boolean | SkillCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SkillCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillCategory"
    objects: {
      technicalSkills: Prisma.$TechnicalSkillPayload<ExtArgs>[]
      relatedCareers: Prisma.$CareerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
    }, ExtArgs["result"]["skillCategory"]>
    composites: {}
  }


  type SkillCategoryGetPayload<S extends boolean | null | undefined | SkillCategoryDefaultArgs> = $Result.GetResult<Prisma.$SkillCategoryPayload, S>

  type SkillCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillCategoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SkillCategoryCountAggregateInputType | true
    }

  export interface SkillCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillCategory'], meta: { name: 'SkillCategory' } }
    /**
     * Find zero or one SkillCategory that matches the filter.
     * @param {SkillCategoryFindUniqueArgs} args - Arguments to find a SkillCategory
     * @example
     * // Get one SkillCategory
     * const skillCategory = await prisma.skillCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SkillCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SkillCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SkillCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SkillCategoryFindUniqueOrThrowArgs} args - Arguments to find a SkillCategory
     * @example
     * // Get one SkillCategory
     * const skillCategory = await prisma.skillCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SkillCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SkillCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCategoryFindFirstArgs} args - Arguments to find a SkillCategory
     * @example
     * // Get one SkillCategory
     * const skillCategory = await prisma.skillCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SkillCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SkillCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCategoryFindFirstOrThrowArgs} args - Arguments to find a SkillCategory
     * @example
     * // Get one SkillCategory
     * const skillCategory = await prisma.skillCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SkillCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SkillCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillCategories
     * const skillCategories = await prisma.skillCategory.findMany()
     * 
     * // Get first 10 SkillCategories
     * const skillCategories = await prisma.skillCategory.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const skillCategoryWithNameOnly = await prisma.skillCategory.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends SkillCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SkillCategory.
     * @param {SkillCategoryCreateArgs} args - Arguments to create a SkillCategory.
     * @example
     * // Create one SkillCategory
     * const SkillCategory = await prisma.skillCategory.create({
     *   data: {
     *     // ... data to create a SkillCategory
     *   }
     * })
     * 
    **/
    create<T extends SkillCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SkillCategoryCreateArgs<ExtArgs>>
    ): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SkillCategories.
     *     @param {SkillCategoryCreateManyArgs} args - Arguments to create many SkillCategories.
     *     @example
     *     // Create many SkillCategories
     *     const skillCategory = await prisma.skillCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SkillCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SkillCategory.
     * @param {SkillCategoryDeleteArgs} args - Arguments to delete one SkillCategory.
     * @example
     * // Delete one SkillCategory
     * const SkillCategory = await prisma.skillCategory.delete({
     *   where: {
     *     // ... filter to delete one SkillCategory
     *   }
     * })
     * 
    **/
    delete<T extends SkillCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SkillCategoryDeleteArgs<ExtArgs>>
    ): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SkillCategory.
     * @param {SkillCategoryUpdateArgs} args - Arguments to update one SkillCategory.
     * @example
     * // Update one SkillCategory
     * const skillCategory = await prisma.skillCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SkillCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SkillCategoryUpdateArgs<ExtArgs>>
    ): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SkillCategories.
     * @param {SkillCategoryDeleteManyArgs} args - Arguments to filter SkillCategories to delete.
     * @example
     * // Delete a few SkillCategories
     * const { count } = await prisma.skillCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SkillCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillCategories
     * const skillCategory = await prisma.skillCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SkillCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SkillCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillCategory.
     * @param {SkillCategoryUpsertArgs} args - Arguments to update or create a SkillCategory.
     * @example
     * // Update or create a SkillCategory
     * const skillCategory = await prisma.skillCategory.upsert({
     *   create: {
     *     // ... data to create a SkillCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillCategory we want to update
     *   }
     * })
    **/
    upsert<T extends SkillCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SkillCategoryUpsertArgs<ExtArgs>>
    ): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SkillCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCategoryCountArgs} args - Arguments to filter SkillCategories to count.
     * @example
     * // Count the number of SkillCategories
     * const count = await prisma.skillCategory.count({
     *   where: {
     *     // ... the filter for the SkillCategories we want to count
     *   }
     * })
    **/
    count<T extends SkillCategoryCountArgs>(
      args?: Subset<T, SkillCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillCategoryAggregateArgs>(args: Subset<T, SkillCategoryAggregateArgs>): Prisma.PrismaPromise<GetSkillCategoryAggregateType<T>>

    /**
     * Group by SkillCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SkillCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillCategory model
   */
  readonly fields: SkillCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    technicalSkills<T extends SkillCategory$technicalSkillsArgs<ExtArgs> = {}>(args?: Subset<T, SkillCategory$technicalSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    relatedCareers<T extends SkillCategory$relatedCareersArgs<ExtArgs> = {}>(args?: Subset<T, SkillCategory$relatedCareersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SkillCategory model
   */ 
  interface SkillCategoryFieldRefs {
    readonly name: FieldRef<"SkillCategory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SkillCategory findUnique
   */
  export type SkillCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillCategory to fetch.
     */
    where: SkillCategoryWhereUniqueInput
  }


  /**
   * SkillCategory findUniqueOrThrow
   */
  export type SkillCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillCategory to fetch.
     */
    where: SkillCategoryWhereUniqueInput
  }


  /**
   * SkillCategory findFirst
   */
  export type SkillCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillCategory to fetch.
     */
    where?: SkillCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillCategories to fetch.
     */
    orderBy?: SkillCategoryOrderByWithRelationInput | SkillCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillCategories.
     */
    cursor?: SkillCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillCategories.
     */
    distinct?: SkillCategoryScalarFieldEnum | SkillCategoryScalarFieldEnum[]
  }


  /**
   * SkillCategory findFirstOrThrow
   */
  export type SkillCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillCategory to fetch.
     */
    where?: SkillCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillCategories to fetch.
     */
    orderBy?: SkillCategoryOrderByWithRelationInput | SkillCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillCategories.
     */
    cursor?: SkillCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillCategories.
     */
    distinct?: SkillCategoryScalarFieldEnum | SkillCategoryScalarFieldEnum[]
  }


  /**
   * SkillCategory findMany
   */
  export type SkillCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillCategories to fetch.
     */
    where?: SkillCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillCategories to fetch.
     */
    orderBy?: SkillCategoryOrderByWithRelationInput | SkillCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillCategories.
     */
    cursor?: SkillCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillCategories.
     */
    skip?: number
    distinct?: SkillCategoryScalarFieldEnum | SkillCategoryScalarFieldEnum[]
  }


  /**
   * SkillCategory create
   */
  export type SkillCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillCategory.
     */
    data: XOR<SkillCategoryCreateInput, SkillCategoryUncheckedCreateInput>
  }


  /**
   * SkillCategory createMany
   */
  export type SkillCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillCategories.
     */
    data: SkillCategoryCreateManyInput | SkillCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SkillCategory update
   */
  export type SkillCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillCategory.
     */
    data: XOR<SkillCategoryUpdateInput, SkillCategoryUncheckedUpdateInput>
    /**
     * Choose, which SkillCategory to update.
     */
    where: SkillCategoryWhereUniqueInput
  }


  /**
   * SkillCategory updateMany
   */
  export type SkillCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillCategories.
     */
    data: XOR<SkillCategoryUpdateManyMutationInput, SkillCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SkillCategories to update
     */
    where?: SkillCategoryWhereInput
  }


  /**
   * SkillCategory upsert
   */
  export type SkillCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillCategory to update in case it exists.
     */
    where: SkillCategoryWhereUniqueInput
    /**
     * In case the SkillCategory found by the `where` argument doesn't exist, create a new SkillCategory with this data.
     */
    create: XOR<SkillCategoryCreateInput, SkillCategoryUncheckedCreateInput>
    /**
     * In case the SkillCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillCategoryUpdateInput, SkillCategoryUncheckedUpdateInput>
  }


  /**
   * SkillCategory delete
   */
  export type SkillCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
    /**
     * Filter which SkillCategory to delete.
     */
    where: SkillCategoryWhereUniqueInput
  }


  /**
   * SkillCategory deleteMany
   */
  export type SkillCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillCategories to delete
     */
    where?: SkillCategoryWhereInput
  }


  /**
   * SkillCategory.technicalSkills
   */
  export type SkillCategory$technicalSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    where?: TechnicalSkillWhereInput
    orderBy?: TechnicalSkillOrderByWithRelationInput | TechnicalSkillOrderByWithRelationInput[]
    cursor?: TechnicalSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicalSkillScalarFieldEnum | TechnicalSkillScalarFieldEnum[]
  }


  /**
   * SkillCategory.relatedCareers
   */
  export type SkillCategory$relatedCareersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CareerInclude<ExtArgs> | null
    where?: CareerWhereInput
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    cursor?: CareerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }


  /**
   * SkillCategory without action
   */
  export type SkillCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCategory
     */
    select?: SkillCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillCategoryInclude<ExtArgs> | null
  }



  /**
   * Model TechnicalSkill
   */

  export type AggregateTechnicalSkill = {
    _count: TechnicalSkillCountAggregateOutputType | null
    _min: TechnicalSkillMinAggregateOutputType | null
    _max: TechnicalSkillMaxAggregateOutputType | null
  }

  export type TechnicalSkillMinAggregateOutputType = {
    name: string | null
    categoryName: string | null
  }

  export type TechnicalSkillMaxAggregateOutputType = {
    name: string | null
    categoryName: string | null
  }

  export type TechnicalSkillCountAggregateOutputType = {
    name: number
    categoryName: number
    _all: number
  }


  export type TechnicalSkillMinAggregateInputType = {
    name?: true
    categoryName?: true
  }

  export type TechnicalSkillMaxAggregateInputType = {
    name?: true
    categoryName?: true
  }

  export type TechnicalSkillCountAggregateInputType = {
    name?: true
    categoryName?: true
    _all?: true
  }

  export type TechnicalSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalSkill to aggregate.
     */
    where?: TechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSkills to fetch.
     */
    orderBy?: TechnicalSkillOrderByWithRelationInput | TechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicalSkills
    **/
    _count?: true | TechnicalSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicalSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicalSkillMaxAggregateInputType
  }

  export type GetTechnicalSkillAggregateType<T extends TechnicalSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicalSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicalSkill[P]>
      : GetScalarType<T[P], AggregateTechnicalSkill[P]>
  }




  export type TechnicalSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalSkillWhereInput
    orderBy?: TechnicalSkillOrderByWithAggregationInput | TechnicalSkillOrderByWithAggregationInput[]
    by: TechnicalSkillScalarFieldEnum[] | TechnicalSkillScalarFieldEnum
    having?: TechnicalSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicalSkillCountAggregateInputType | true
    _min?: TechnicalSkillMinAggregateInputType
    _max?: TechnicalSkillMaxAggregateInputType
  }

  export type TechnicalSkillGroupByOutputType = {
    name: string
    categoryName: string
    _count: TechnicalSkillCountAggregateOutputType | null
    _min: TechnicalSkillMinAggregateOutputType | null
    _max: TechnicalSkillMaxAggregateOutputType | null
  }

  type GetTechnicalSkillGroupByPayload<T extends TechnicalSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicalSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicalSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicalSkillGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicalSkillGroupByOutputType[P]>
        }
      >
    >


  export type TechnicalSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    categoryName?: boolean
    category?: boolean | SkillCategoryDefaultArgs<ExtArgs>
    resumesListingThis?: boolean | TechnicalSkill$resumesListingThisArgs<ExtArgs>
    jobOffersListingThis?: boolean | TechnicalSkill$jobOffersListingThisArgs<ExtArgs>
    _count?: boolean | TechnicalSkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalSkill"]>

  export type TechnicalSkillSelectScalar = {
    name?: boolean
    categoryName?: boolean
  }

  export type TechnicalSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | SkillCategoryDefaultArgs<ExtArgs>
    resumesListingThis?: boolean | TechnicalSkill$resumesListingThisArgs<ExtArgs>
    jobOffersListingThis?: boolean | TechnicalSkill$jobOffersListingThisArgs<ExtArgs>
    _count?: boolean | TechnicalSkillCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TechnicalSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicalSkill"
    objects: {
      category: Prisma.$SkillCategoryPayload<ExtArgs>
      resumesListingThis: Prisma.$ResumeTechnicalSkillPayload<ExtArgs>[]
      jobOffersListingThis: Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      categoryName: string
    }, ExtArgs["result"]["technicalSkill"]>
    composites: {}
  }


  type TechnicalSkillGetPayload<S extends boolean | null | undefined | TechnicalSkillDefaultArgs> = $Result.GetResult<Prisma.$TechnicalSkillPayload, S>

  type TechnicalSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TechnicalSkillFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TechnicalSkillCountAggregateInputType | true
    }

  export interface TechnicalSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicalSkill'], meta: { name: 'TechnicalSkill' } }
    /**
     * Find zero or one TechnicalSkill that matches the filter.
     * @param {TechnicalSkillFindUniqueArgs} args - Arguments to find a TechnicalSkill
     * @example
     * // Get one TechnicalSkill
     * const technicalSkill = await prisma.technicalSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TechnicalSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TechnicalSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TechnicalSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TechnicalSkillFindUniqueOrThrowArgs} args - Arguments to find a TechnicalSkill
     * @example
     * // Get one TechnicalSkill
     * const technicalSkill = await prisma.technicalSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TechnicalSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TechnicalSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TechnicalSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSkillFindFirstArgs} args - Arguments to find a TechnicalSkill
     * @example
     * // Get one TechnicalSkill
     * const technicalSkill = await prisma.technicalSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TechnicalSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TechnicalSkillFindFirstArgs<ExtArgs>>
    ): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TechnicalSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSkillFindFirstOrThrowArgs} args - Arguments to find a TechnicalSkill
     * @example
     * // Get one TechnicalSkill
     * const technicalSkill = await prisma.technicalSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TechnicalSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TechnicalSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TechnicalSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicalSkills
     * const technicalSkills = await prisma.technicalSkill.findMany()
     * 
     * // Get first 10 TechnicalSkills
     * const technicalSkills = await prisma.technicalSkill.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const technicalSkillWithNameOnly = await prisma.technicalSkill.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends TechnicalSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TechnicalSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TechnicalSkill.
     * @param {TechnicalSkillCreateArgs} args - Arguments to create a TechnicalSkill.
     * @example
     * // Create one TechnicalSkill
     * const TechnicalSkill = await prisma.technicalSkill.create({
     *   data: {
     *     // ... data to create a TechnicalSkill
     *   }
     * })
     * 
    **/
    create<T extends TechnicalSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TechnicalSkillCreateArgs<ExtArgs>>
    ): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TechnicalSkills.
     *     @param {TechnicalSkillCreateManyArgs} args - Arguments to create many TechnicalSkills.
     *     @example
     *     // Create many TechnicalSkills
     *     const technicalSkill = await prisma.technicalSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TechnicalSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TechnicalSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TechnicalSkill.
     * @param {TechnicalSkillDeleteArgs} args - Arguments to delete one TechnicalSkill.
     * @example
     * // Delete one TechnicalSkill
     * const TechnicalSkill = await prisma.technicalSkill.delete({
     *   where: {
     *     // ... filter to delete one TechnicalSkill
     *   }
     * })
     * 
    **/
    delete<T extends TechnicalSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TechnicalSkillDeleteArgs<ExtArgs>>
    ): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TechnicalSkill.
     * @param {TechnicalSkillUpdateArgs} args - Arguments to update one TechnicalSkill.
     * @example
     * // Update one TechnicalSkill
     * const technicalSkill = await prisma.technicalSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TechnicalSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TechnicalSkillUpdateArgs<ExtArgs>>
    ): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TechnicalSkills.
     * @param {TechnicalSkillDeleteManyArgs} args - Arguments to filter TechnicalSkills to delete.
     * @example
     * // Delete a few TechnicalSkills
     * const { count } = await prisma.technicalSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TechnicalSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TechnicalSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicalSkills
     * const technicalSkill = await prisma.technicalSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TechnicalSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TechnicalSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TechnicalSkill.
     * @param {TechnicalSkillUpsertArgs} args - Arguments to update or create a TechnicalSkill.
     * @example
     * // Update or create a TechnicalSkill
     * const technicalSkill = await prisma.technicalSkill.upsert({
     *   create: {
     *     // ... data to create a TechnicalSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicalSkill we want to update
     *   }
     * })
    **/
    upsert<T extends TechnicalSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TechnicalSkillUpsertArgs<ExtArgs>>
    ): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TechnicalSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSkillCountArgs} args - Arguments to filter TechnicalSkills to count.
     * @example
     * // Count the number of TechnicalSkills
     * const count = await prisma.technicalSkill.count({
     *   where: {
     *     // ... the filter for the TechnicalSkills we want to count
     *   }
     * })
    **/
    count<T extends TechnicalSkillCountArgs>(
      args?: Subset<T, TechnicalSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicalSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicalSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicalSkillAggregateArgs>(args: Subset<T, TechnicalSkillAggregateArgs>): Prisma.PrismaPromise<GetTechnicalSkillAggregateType<T>>

    /**
     * Group by TechnicalSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicalSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicalSkillGroupByArgs['orderBy'] }
        : { orderBy?: TechnicalSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicalSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicalSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicalSkill model
   */
  readonly fields: TechnicalSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicalSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicalSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    category<T extends SkillCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillCategoryDefaultArgs<ExtArgs>>): Prisma__SkillCategoryClient<$Result.GetResult<Prisma.$SkillCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    resumesListingThis<T extends TechnicalSkill$resumesListingThisArgs<ExtArgs> = {}>(args?: Subset<T, TechnicalSkill$resumesListingThisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    jobOffersListingThis<T extends TechnicalSkill$jobOffersListingThisArgs<ExtArgs> = {}>(args?: Subset<T, TechnicalSkill$jobOffersListingThisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobOfferTechnicalSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TechnicalSkill model
   */ 
  interface TechnicalSkillFieldRefs {
    readonly name: FieldRef<"TechnicalSkill", 'String'>
    readonly categoryName: FieldRef<"TechnicalSkill", 'String'>
  }
    

  // Custom InputTypes

  /**
   * TechnicalSkill findUnique
   */
  export type TechnicalSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSkill to fetch.
     */
    where: TechnicalSkillWhereUniqueInput
  }


  /**
   * TechnicalSkill findUniqueOrThrow
   */
  export type TechnicalSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSkill to fetch.
     */
    where: TechnicalSkillWhereUniqueInput
  }


  /**
   * TechnicalSkill findFirst
   */
  export type TechnicalSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSkill to fetch.
     */
    where?: TechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSkills to fetch.
     */
    orderBy?: TechnicalSkillOrderByWithRelationInput | TechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalSkills.
     */
    cursor?: TechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalSkills.
     */
    distinct?: TechnicalSkillScalarFieldEnum | TechnicalSkillScalarFieldEnum[]
  }


  /**
   * TechnicalSkill findFirstOrThrow
   */
  export type TechnicalSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSkill to fetch.
     */
    where?: TechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSkills to fetch.
     */
    orderBy?: TechnicalSkillOrderByWithRelationInput | TechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalSkills.
     */
    cursor?: TechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalSkills.
     */
    distinct?: TechnicalSkillScalarFieldEnum | TechnicalSkillScalarFieldEnum[]
  }


  /**
   * TechnicalSkill findMany
   */
  export type TechnicalSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalSkills to fetch.
     */
    where?: TechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalSkills to fetch.
     */
    orderBy?: TechnicalSkillOrderByWithRelationInput | TechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicalSkills.
     */
    cursor?: TechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalSkills.
     */
    skip?: number
    distinct?: TechnicalSkillScalarFieldEnum | TechnicalSkillScalarFieldEnum[]
  }


  /**
   * TechnicalSkill create
   */
  export type TechnicalSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicalSkill.
     */
    data: XOR<TechnicalSkillCreateInput, TechnicalSkillUncheckedCreateInput>
  }


  /**
   * TechnicalSkill createMany
   */
  export type TechnicalSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicalSkills.
     */
    data: TechnicalSkillCreateManyInput | TechnicalSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TechnicalSkill update
   */
  export type TechnicalSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicalSkill.
     */
    data: XOR<TechnicalSkillUpdateInput, TechnicalSkillUncheckedUpdateInput>
    /**
     * Choose, which TechnicalSkill to update.
     */
    where: TechnicalSkillWhereUniqueInput
  }


  /**
   * TechnicalSkill updateMany
   */
  export type TechnicalSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicalSkills.
     */
    data: XOR<TechnicalSkillUpdateManyMutationInput, TechnicalSkillUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalSkills to update
     */
    where?: TechnicalSkillWhereInput
  }


  /**
   * TechnicalSkill upsert
   */
  export type TechnicalSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicalSkill to update in case it exists.
     */
    where: TechnicalSkillWhereUniqueInput
    /**
     * In case the TechnicalSkill found by the `where` argument doesn't exist, create a new TechnicalSkill with this data.
     */
    create: XOR<TechnicalSkillCreateInput, TechnicalSkillUncheckedCreateInput>
    /**
     * In case the TechnicalSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicalSkillUpdateInput, TechnicalSkillUncheckedUpdateInput>
  }


  /**
   * TechnicalSkill delete
   */
  export type TechnicalSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter which TechnicalSkill to delete.
     */
    where: TechnicalSkillWhereUniqueInput
  }


  /**
   * TechnicalSkill deleteMany
   */
  export type TechnicalSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalSkills to delete
     */
    where?: TechnicalSkillWhereInput
  }


  /**
   * TechnicalSkill.resumesListingThis
   */
  export type TechnicalSkill$resumesListingThisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    where?: ResumeTechnicalSkillWhereInput
    orderBy?: ResumeTechnicalSkillOrderByWithRelationInput | ResumeTechnicalSkillOrderByWithRelationInput[]
    cursor?: ResumeTechnicalSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeTechnicalSkillScalarFieldEnum | ResumeTechnicalSkillScalarFieldEnum[]
  }


  /**
   * TechnicalSkill.jobOffersListingThis
   */
  export type TechnicalSkill$jobOffersListingThisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobOfferTechnicalSkill
     */
    select?: JobOfferTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobOfferTechnicalSkillInclude<ExtArgs> | null
    where?: JobOfferTechnicalSkillWhereInput
    orderBy?: JobOfferTechnicalSkillOrderByWithRelationInput | JobOfferTechnicalSkillOrderByWithRelationInput[]
    cursor?: JobOfferTechnicalSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobOfferTechnicalSkillScalarFieldEnum | JobOfferTechnicalSkillScalarFieldEnum[]
  }


  /**
   * TechnicalSkill without action
   */
  export type TechnicalSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalSkill
     */
    select?: TechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TechnicalSkillInclude<ExtArgs> | null
  }



  /**
   * Model ResumeTechnicalSkill
   */

  export type AggregateResumeTechnicalSkill = {
    _count: ResumeTechnicalSkillCountAggregateOutputType | null
    _min: ResumeTechnicalSkillMinAggregateOutputType | null
    _max: ResumeTechnicalSkillMaxAggregateOutputType | null
  }

  export type ResumeTechnicalSkillMinAggregateOutputType = {
    resumeOwnerEmail: string | null
    skillName: string | null
    skillCategoryName: string | null
    isVisible: boolean | null
  }

  export type ResumeTechnicalSkillMaxAggregateOutputType = {
    resumeOwnerEmail: string | null
    skillName: string | null
    skillCategoryName: string | null
    isVisible: boolean | null
  }

  export type ResumeTechnicalSkillCountAggregateOutputType = {
    resumeOwnerEmail: number
    skillName: number
    skillCategoryName: number
    isVisible: number
    _all: number
  }


  export type ResumeTechnicalSkillMinAggregateInputType = {
    resumeOwnerEmail?: true
    skillName?: true
    skillCategoryName?: true
    isVisible?: true
  }

  export type ResumeTechnicalSkillMaxAggregateInputType = {
    resumeOwnerEmail?: true
    skillName?: true
    skillCategoryName?: true
    isVisible?: true
  }

  export type ResumeTechnicalSkillCountAggregateInputType = {
    resumeOwnerEmail?: true
    skillName?: true
    skillCategoryName?: true
    isVisible?: true
    _all?: true
  }

  export type ResumeTechnicalSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeTechnicalSkill to aggregate.
     */
    where?: ResumeTechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeTechnicalSkills to fetch.
     */
    orderBy?: ResumeTechnicalSkillOrderByWithRelationInput | ResumeTechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeTechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeTechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeTechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeTechnicalSkills
    **/
    _count?: true | ResumeTechnicalSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeTechnicalSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeTechnicalSkillMaxAggregateInputType
  }

  export type GetResumeTechnicalSkillAggregateType<T extends ResumeTechnicalSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeTechnicalSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeTechnicalSkill[P]>
      : GetScalarType<T[P], AggregateResumeTechnicalSkill[P]>
  }




  export type ResumeTechnicalSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeTechnicalSkillWhereInput
    orderBy?: ResumeTechnicalSkillOrderByWithAggregationInput | ResumeTechnicalSkillOrderByWithAggregationInput[]
    by: ResumeTechnicalSkillScalarFieldEnum[] | ResumeTechnicalSkillScalarFieldEnum
    having?: ResumeTechnicalSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeTechnicalSkillCountAggregateInputType | true
    _min?: ResumeTechnicalSkillMinAggregateInputType
    _max?: ResumeTechnicalSkillMaxAggregateInputType
  }

  export type ResumeTechnicalSkillGroupByOutputType = {
    resumeOwnerEmail: string
    skillName: string
    skillCategoryName: string
    isVisible: boolean
    _count: ResumeTechnicalSkillCountAggregateOutputType | null
    _min: ResumeTechnicalSkillMinAggregateOutputType | null
    _max: ResumeTechnicalSkillMaxAggregateOutputType | null
  }

  type GetResumeTechnicalSkillGroupByPayload<T extends ResumeTechnicalSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeTechnicalSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeTechnicalSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeTechnicalSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeTechnicalSkillGroupByOutputType[P]>
        }
      >
    >


  export type ResumeTechnicalSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resumeOwnerEmail?: boolean
    skillName?: boolean
    skillCategoryName?: boolean
    isVisible?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | TechnicalSkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeTechnicalSkill"]>

  export type ResumeTechnicalSkillSelectScalar = {
    resumeOwnerEmail?: boolean
    skillName?: boolean
    skillCategoryName?: boolean
    isVisible?: boolean
  }

  export type ResumeTechnicalSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | TechnicalSkillDefaultArgs<ExtArgs>
  }


  export type $ResumeTechnicalSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeTechnicalSkill"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
      skill: Prisma.$TechnicalSkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resumeOwnerEmail: string
      skillName: string
      skillCategoryName: string
      isVisible: boolean
    }, ExtArgs["result"]["resumeTechnicalSkill"]>
    composites: {}
  }


  type ResumeTechnicalSkillGetPayload<S extends boolean | null | undefined | ResumeTechnicalSkillDefaultArgs> = $Result.GetResult<Prisma.$ResumeTechnicalSkillPayload, S>

  type ResumeTechnicalSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResumeTechnicalSkillFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ResumeTechnicalSkillCountAggregateInputType | true
    }

  export interface ResumeTechnicalSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeTechnicalSkill'], meta: { name: 'ResumeTechnicalSkill' } }
    /**
     * Find zero or one ResumeTechnicalSkill that matches the filter.
     * @param {ResumeTechnicalSkillFindUniqueArgs} args - Arguments to find a ResumeTechnicalSkill
     * @example
     * // Get one ResumeTechnicalSkill
     * const resumeTechnicalSkill = await prisma.resumeTechnicalSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumeTechnicalSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeTechnicalSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__ResumeTechnicalSkillClient<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ResumeTechnicalSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResumeTechnicalSkillFindUniqueOrThrowArgs} args - Arguments to find a ResumeTechnicalSkill
     * @example
     * // Get one ResumeTechnicalSkill
     * const resumeTechnicalSkill = await prisma.resumeTechnicalSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumeTechnicalSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeTechnicalSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeTechnicalSkillClient<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ResumeTechnicalSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTechnicalSkillFindFirstArgs} args - Arguments to find a ResumeTechnicalSkill
     * @example
     * // Get one ResumeTechnicalSkill
     * const resumeTechnicalSkill = await prisma.resumeTechnicalSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumeTechnicalSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeTechnicalSkillFindFirstArgs<ExtArgs>>
    ): Prisma__ResumeTechnicalSkillClient<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ResumeTechnicalSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTechnicalSkillFindFirstOrThrowArgs} args - Arguments to find a ResumeTechnicalSkill
     * @example
     * // Get one ResumeTechnicalSkill
     * const resumeTechnicalSkill = await prisma.resumeTechnicalSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumeTechnicalSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeTechnicalSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeTechnicalSkillClient<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ResumeTechnicalSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTechnicalSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeTechnicalSkills
     * const resumeTechnicalSkills = await prisma.resumeTechnicalSkill.findMany()
     * 
     * // Get first 10 ResumeTechnicalSkills
     * const resumeTechnicalSkills = await prisma.resumeTechnicalSkill.findMany({ take: 10 })
     * 
     * // Only select the `resumeOwnerEmail`
     * const resumeTechnicalSkillWithResumeOwnerEmailOnly = await prisma.resumeTechnicalSkill.findMany({ select: { resumeOwnerEmail: true } })
     * 
    **/
    findMany<T extends ResumeTechnicalSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeTechnicalSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ResumeTechnicalSkill.
     * @param {ResumeTechnicalSkillCreateArgs} args - Arguments to create a ResumeTechnicalSkill.
     * @example
     * // Create one ResumeTechnicalSkill
     * const ResumeTechnicalSkill = await prisma.resumeTechnicalSkill.create({
     *   data: {
     *     // ... data to create a ResumeTechnicalSkill
     *   }
     * })
     * 
    **/
    create<T extends ResumeTechnicalSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeTechnicalSkillCreateArgs<ExtArgs>>
    ): Prisma__ResumeTechnicalSkillClient<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ResumeTechnicalSkills.
     *     @param {ResumeTechnicalSkillCreateManyArgs} args - Arguments to create many ResumeTechnicalSkills.
     *     @example
     *     // Create many ResumeTechnicalSkills
     *     const resumeTechnicalSkill = await prisma.resumeTechnicalSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumeTechnicalSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeTechnicalSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResumeTechnicalSkill.
     * @param {ResumeTechnicalSkillDeleteArgs} args - Arguments to delete one ResumeTechnicalSkill.
     * @example
     * // Delete one ResumeTechnicalSkill
     * const ResumeTechnicalSkill = await prisma.resumeTechnicalSkill.delete({
     *   where: {
     *     // ... filter to delete one ResumeTechnicalSkill
     *   }
     * })
     * 
    **/
    delete<T extends ResumeTechnicalSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeTechnicalSkillDeleteArgs<ExtArgs>>
    ): Prisma__ResumeTechnicalSkillClient<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ResumeTechnicalSkill.
     * @param {ResumeTechnicalSkillUpdateArgs} args - Arguments to update one ResumeTechnicalSkill.
     * @example
     * // Update one ResumeTechnicalSkill
     * const resumeTechnicalSkill = await prisma.resumeTechnicalSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumeTechnicalSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeTechnicalSkillUpdateArgs<ExtArgs>>
    ): Prisma__ResumeTechnicalSkillClient<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ResumeTechnicalSkills.
     * @param {ResumeTechnicalSkillDeleteManyArgs} args - Arguments to filter ResumeTechnicalSkills to delete.
     * @example
     * // Delete a few ResumeTechnicalSkills
     * const { count } = await prisma.resumeTechnicalSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumeTechnicalSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeTechnicalSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeTechnicalSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTechnicalSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeTechnicalSkills
     * const resumeTechnicalSkill = await prisma.resumeTechnicalSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumeTechnicalSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeTechnicalSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumeTechnicalSkill.
     * @param {ResumeTechnicalSkillUpsertArgs} args - Arguments to update or create a ResumeTechnicalSkill.
     * @example
     * // Update or create a ResumeTechnicalSkill
     * const resumeTechnicalSkill = await prisma.resumeTechnicalSkill.upsert({
     *   create: {
     *     // ... data to create a ResumeTechnicalSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeTechnicalSkill we want to update
     *   }
     * })
    **/
    upsert<T extends ResumeTechnicalSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeTechnicalSkillUpsertArgs<ExtArgs>>
    ): Prisma__ResumeTechnicalSkillClient<$Result.GetResult<Prisma.$ResumeTechnicalSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ResumeTechnicalSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTechnicalSkillCountArgs} args - Arguments to filter ResumeTechnicalSkills to count.
     * @example
     * // Count the number of ResumeTechnicalSkills
     * const count = await prisma.resumeTechnicalSkill.count({
     *   where: {
     *     // ... the filter for the ResumeTechnicalSkills we want to count
     *   }
     * })
    **/
    count<T extends ResumeTechnicalSkillCountArgs>(
      args?: Subset<T, ResumeTechnicalSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeTechnicalSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeTechnicalSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTechnicalSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeTechnicalSkillAggregateArgs>(args: Subset<T, ResumeTechnicalSkillAggregateArgs>): Prisma.PrismaPromise<GetResumeTechnicalSkillAggregateType<T>>

    /**
     * Group by ResumeTechnicalSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTechnicalSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeTechnicalSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeTechnicalSkillGroupByArgs['orderBy'] }
        : { orderBy?: ResumeTechnicalSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeTechnicalSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeTechnicalSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeTechnicalSkill model
   */
  readonly fields: ResumeTechnicalSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeTechnicalSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeTechnicalSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    skill<T extends TechnicalSkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TechnicalSkillDefaultArgs<ExtArgs>>): Prisma__TechnicalSkillClient<$Result.GetResult<Prisma.$TechnicalSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ResumeTechnicalSkill model
   */ 
  interface ResumeTechnicalSkillFieldRefs {
    readonly resumeOwnerEmail: FieldRef<"ResumeTechnicalSkill", 'String'>
    readonly skillName: FieldRef<"ResumeTechnicalSkill", 'String'>
    readonly skillCategoryName: FieldRef<"ResumeTechnicalSkill", 'String'>
    readonly isVisible: FieldRef<"ResumeTechnicalSkill", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ResumeTechnicalSkill findUnique
   */
  export type ResumeTechnicalSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTechnicalSkill to fetch.
     */
    where: ResumeTechnicalSkillWhereUniqueInput
  }


  /**
   * ResumeTechnicalSkill findUniqueOrThrow
   */
  export type ResumeTechnicalSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTechnicalSkill to fetch.
     */
    where: ResumeTechnicalSkillWhereUniqueInput
  }


  /**
   * ResumeTechnicalSkill findFirst
   */
  export type ResumeTechnicalSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTechnicalSkill to fetch.
     */
    where?: ResumeTechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeTechnicalSkills to fetch.
     */
    orderBy?: ResumeTechnicalSkillOrderByWithRelationInput | ResumeTechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeTechnicalSkills.
     */
    cursor?: ResumeTechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeTechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeTechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeTechnicalSkills.
     */
    distinct?: ResumeTechnicalSkillScalarFieldEnum | ResumeTechnicalSkillScalarFieldEnum[]
  }


  /**
   * ResumeTechnicalSkill findFirstOrThrow
   */
  export type ResumeTechnicalSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTechnicalSkill to fetch.
     */
    where?: ResumeTechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeTechnicalSkills to fetch.
     */
    orderBy?: ResumeTechnicalSkillOrderByWithRelationInput | ResumeTechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeTechnicalSkills.
     */
    cursor?: ResumeTechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeTechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeTechnicalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeTechnicalSkills.
     */
    distinct?: ResumeTechnicalSkillScalarFieldEnum | ResumeTechnicalSkillScalarFieldEnum[]
  }


  /**
   * ResumeTechnicalSkill findMany
   */
  export type ResumeTechnicalSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTechnicalSkills to fetch.
     */
    where?: ResumeTechnicalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeTechnicalSkills to fetch.
     */
    orderBy?: ResumeTechnicalSkillOrderByWithRelationInput | ResumeTechnicalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeTechnicalSkills.
     */
    cursor?: ResumeTechnicalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeTechnicalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeTechnicalSkills.
     */
    skip?: number
    distinct?: ResumeTechnicalSkillScalarFieldEnum | ResumeTechnicalSkillScalarFieldEnum[]
  }


  /**
   * ResumeTechnicalSkill create
   */
  export type ResumeTechnicalSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeTechnicalSkill.
     */
    data: XOR<ResumeTechnicalSkillCreateInput, ResumeTechnicalSkillUncheckedCreateInput>
  }


  /**
   * ResumeTechnicalSkill createMany
   */
  export type ResumeTechnicalSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeTechnicalSkills.
     */
    data: ResumeTechnicalSkillCreateManyInput | ResumeTechnicalSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ResumeTechnicalSkill update
   */
  export type ResumeTechnicalSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeTechnicalSkill.
     */
    data: XOR<ResumeTechnicalSkillUpdateInput, ResumeTechnicalSkillUncheckedUpdateInput>
    /**
     * Choose, which ResumeTechnicalSkill to update.
     */
    where: ResumeTechnicalSkillWhereUniqueInput
  }


  /**
   * ResumeTechnicalSkill updateMany
   */
  export type ResumeTechnicalSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeTechnicalSkills.
     */
    data: XOR<ResumeTechnicalSkillUpdateManyMutationInput, ResumeTechnicalSkillUncheckedUpdateManyInput>
    /**
     * Filter which ResumeTechnicalSkills to update
     */
    where?: ResumeTechnicalSkillWhereInput
  }


  /**
   * ResumeTechnicalSkill upsert
   */
  export type ResumeTechnicalSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeTechnicalSkill to update in case it exists.
     */
    where: ResumeTechnicalSkillWhereUniqueInput
    /**
     * In case the ResumeTechnicalSkill found by the `where` argument doesn't exist, create a new ResumeTechnicalSkill with this data.
     */
    create: XOR<ResumeTechnicalSkillCreateInput, ResumeTechnicalSkillUncheckedCreateInput>
    /**
     * In case the ResumeTechnicalSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeTechnicalSkillUpdateInput, ResumeTechnicalSkillUncheckedUpdateInput>
  }


  /**
   * ResumeTechnicalSkill delete
   */
  export type ResumeTechnicalSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
    /**
     * Filter which ResumeTechnicalSkill to delete.
     */
    where: ResumeTechnicalSkillWhereUniqueInput
  }


  /**
   * ResumeTechnicalSkill deleteMany
   */
  export type ResumeTechnicalSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeTechnicalSkills to delete
     */
    where?: ResumeTechnicalSkillWhereInput
  }


  /**
   * ResumeTechnicalSkill without action
   */
  export type ResumeTechnicalSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTechnicalSkill
     */
    select?: ResumeTechnicalSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeTechnicalSkillInclude<ExtArgs> | null
  }



  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    name: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    name: string | null
  }

  export type LanguageCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    name?: true
  }

  export type LanguageMaxAggregateInputType = {
    name?: true
  }

  export type LanguageCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    name: string
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    knownBy?: boolean | Language$knownByArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    name?: boolean
  }

  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knownBy?: boolean | Language$knownByArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      knownBy: Prisma.$ResumeLanguagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
    }, ExtArgs["result"]["language"]>
    composites: {}
  }


  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LanguageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LanguageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const languageWithNameOnly = await prisma.language.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends LanguageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
    **/
    create<T extends LanguageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Languages.
     *     @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     *     @example
     *     // Create many Languages
     *     const language = await prisma.language.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LanguageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
    **/
    delete<T extends LanguageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LanguageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LanguageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LanguageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
    **/
    upsert<T extends LanguageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>
    ): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    knownBy<T extends Language$knownByArgs<ExtArgs> = {}>(args?: Subset<T, Language$knownByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly name: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }


  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }


  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }


  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }


  /**
   * Language.knownBy
   */
  export type Language$knownByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    where?: ResumeLanguageWhereInput
    orderBy?: ResumeLanguageOrderByWithRelationInput | ResumeLanguageOrderByWithRelationInput[]
    cursor?: ResumeLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeLanguageScalarFieldEnum | ResumeLanguageScalarFieldEnum[]
  }


  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LanguageInclude<ExtArgs> | null
  }



  /**
   * Model ResumeLanguage
   */

  export type AggregateResumeLanguage = {
    _count: ResumeLanguageCountAggregateOutputType | null
    _avg: ResumeLanguageAvgAggregateOutputType | null
    _sum: ResumeLanguageSumAggregateOutputType | null
    _min: ResumeLanguageMinAggregateOutputType | null
    _max: ResumeLanguageMaxAggregateOutputType | null
  }

  export type ResumeLanguageAvgAggregateOutputType = {
    masteryLevel: number | null
  }

  export type ResumeLanguageSumAggregateOutputType = {
    masteryLevel: number | null
  }

  export type ResumeLanguageMinAggregateOutputType = {
    resumeOwnerEmail: string | null
    languageName: string | null
    masteryLevel: number | null
    isVisible: boolean | null
  }

  export type ResumeLanguageMaxAggregateOutputType = {
    resumeOwnerEmail: string | null
    languageName: string | null
    masteryLevel: number | null
    isVisible: boolean | null
  }

  export type ResumeLanguageCountAggregateOutputType = {
    resumeOwnerEmail: number
    languageName: number
    masteryLevel: number
    isVisible: number
    _all: number
  }


  export type ResumeLanguageAvgAggregateInputType = {
    masteryLevel?: true
  }

  export type ResumeLanguageSumAggregateInputType = {
    masteryLevel?: true
  }

  export type ResumeLanguageMinAggregateInputType = {
    resumeOwnerEmail?: true
    languageName?: true
    masteryLevel?: true
    isVisible?: true
  }

  export type ResumeLanguageMaxAggregateInputType = {
    resumeOwnerEmail?: true
    languageName?: true
    masteryLevel?: true
    isVisible?: true
  }

  export type ResumeLanguageCountAggregateInputType = {
    resumeOwnerEmail?: true
    languageName?: true
    masteryLevel?: true
    isVisible?: true
    _all?: true
  }

  export type ResumeLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeLanguage to aggregate.
     */
    where?: ResumeLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeLanguages to fetch.
     */
    orderBy?: ResumeLanguageOrderByWithRelationInput | ResumeLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeLanguages
    **/
    _count?: true | ResumeLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumeLanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumeLanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeLanguageMaxAggregateInputType
  }

  export type GetResumeLanguageAggregateType<T extends ResumeLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeLanguage[P]>
      : GetScalarType<T[P], AggregateResumeLanguage[P]>
  }




  export type ResumeLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeLanguageWhereInput
    orderBy?: ResumeLanguageOrderByWithAggregationInput | ResumeLanguageOrderByWithAggregationInput[]
    by: ResumeLanguageScalarFieldEnum[] | ResumeLanguageScalarFieldEnum
    having?: ResumeLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeLanguageCountAggregateInputType | true
    _avg?: ResumeLanguageAvgAggregateInputType
    _sum?: ResumeLanguageSumAggregateInputType
    _min?: ResumeLanguageMinAggregateInputType
    _max?: ResumeLanguageMaxAggregateInputType
  }

  export type ResumeLanguageGroupByOutputType = {
    resumeOwnerEmail: string
    languageName: string
    masteryLevel: number
    isVisible: boolean
    _count: ResumeLanguageCountAggregateOutputType | null
    _avg: ResumeLanguageAvgAggregateOutputType | null
    _sum: ResumeLanguageSumAggregateOutputType | null
    _min: ResumeLanguageMinAggregateOutputType | null
    _max: ResumeLanguageMaxAggregateOutputType | null
  }

  type GetResumeLanguageGroupByPayload<T extends ResumeLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeLanguageGroupByOutputType[P]>
        }
      >
    >


  export type ResumeLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resumeOwnerEmail?: boolean
    languageName?: boolean
    masteryLevel?: boolean
    isVisible?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeLanguage"]>

  export type ResumeLanguageSelectScalar = {
    resumeOwnerEmail?: boolean
    languageName?: boolean
    masteryLevel?: boolean
    isVisible?: boolean
  }

  export type ResumeLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }


  export type $ResumeLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeLanguage"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resumeOwnerEmail: string
      languageName: string
      masteryLevel: number
      isVisible: boolean
    }, ExtArgs["result"]["resumeLanguage"]>
    composites: {}
  }


  type ResumeLanguageGetPayload<S extends boolean | null | undefined | ResumeLanguageDefaultArgs> = $Result.GetResult<Prisma.$ResumeLanguagePayload, S>

  type ResumeLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResumeLanguageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ResumeLanguageCountAggregateInputType | true
    }

  export interface ResumeLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeLanguage'], meta: { name: 'ResumeLanguage' } }
    /**
     * Find zero or one ResumeLanguage that matches the filter.
     * @param {ResumeLanguageFindUniqueArgs} args - Arguments to find a ResumeLanguage
     * @example
     * // Get one ResumeLanguage
     * const resumeLanguage = await prisma.resumeLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResumeLanguageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeLanguageFindUniqueArgs<ExtArgs>>
    ): Prisma__ResumeLanguageClient<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ResumeLanguage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResumeLanguageFindUniqueOrThrowArgs} args - Arguments to find a ResumeLanguage
     * @example
     * // Get one ResumeLanguage
     * const resumeLanguage = await prisma.resumeLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResumeLanguageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeLanguageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeLanguageClient<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ResumeLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeLanguageFindFirstArgs} args - Arguments to find a ResumeLanguage
     * @example
     * // Get one ResumeLanguage
     * const resumeLanguage = await prisma.resumeLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResumeLanguageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeLanguageFindFirstArgs<ExtArgs>>
    ): Prisma__ResumeLanguageClient<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ResumeLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeLanguageFindFirstOrThrowArgs} args - Arguments to find a ResumeLanguage
     * @example
     * // Get one ResumeLanguage
     * const resumeLanguage = await prisma.resumeLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResumeLanguageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeLanguageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResumeLanguageClient<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ResumeLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeLanguageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeLanguages
     * const resumeLanguages = await prisma.resumeLanguage.findMany()
     * 
     * // Get first 10 ResumeLanguages
     * const resumeLanguages = await prisma.resumeLanguage.findMany({ take: 10 })
     * 
     * // Only select the `resumeOwnerEmail`
     * const resumeLanguageWithResumeOwnerEmailOnly = await prisma.resumeLanguage.findMany({ select: { resumeOwnerEmail: true } })
     * 
    **/
    findMany<T extends ResumeLanguageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeLanguageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ResumeLanguage.
     * @param {ResumeLanguageCreateArgs} args - Arguments to create a ResumeLanguage.
     * @example
     * // Create one ResumeLanguage
     * const ResumeLanguage = await prisma.resumeLanguage.create({
     *   data: {
     *     // ... data to create a ResumeLanguage
     *   }
     * })
     * 
    **/
    create<T extends ResumeLanguageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeLanguageCreateArgs<ExtArgs>>
    ): Prisma__ResumeLanguageClient<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ResumeLanguages.
     *     @param {ResumeLanguageCreateManyArgs} args - Arguments to create many ResumeLanguages.
     *     @example
     *     // Create many ResumeLanguages
     *     const resumeLanguage = await prisma.resumeLanguage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResumeLanguageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeLanguageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResumeLanguage.
     * @param {ResumeLanguageDeleteArgs} args - Arguments to delete one ResumeLanguage.
     * @example
     * // Delete one ResumeLanguage
     * const ResumeLanguage = await prisma.resumeLanguage.delete({
     *   where: {
     *     // ... filter to delete one ResumeLanguage
     *   }
     * })
     * 
    **/
    delete<T extends ResumeLanguageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeLanguageDeleteArgs<ExtArgs>>
    ): Prisma__ResumeLanguageClient<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ResumeLanguage.
     * @param {ResumeLanguageUpdateArgs} args - Arguments to update one ResumeLanguage.
     * @example
     * // Update one ResumeLanguage
     * const resumeLanguage = await prisma.resumeLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResumeLanguageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeLanguageUpdateArgs<ExtArgs>>
    ): Prisma__ResumeLanguageClient<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ResumeLanguages.
     * @param {ResumeLanguageDeleteManyArgs} args - Arguments to filter ResumeLanguages to delete.
     * @example
     * // Delete a few ResumeLanguages
     * const { count } = await prisma.resumeLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResumeLanguageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResumeLanguageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeLanguages
     * const resumeLanguage = await prisma.resumeLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResumeLanguageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeLanguageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumeLanguage.
     * @param {ResumeLanguageUpsertArgs} args - Arguments to update or create a ResumeLanguage.
     * @example
     * // Update or create a ResumeLanguage
     * const resumeLanguage = await prisma.resumeLanguage.upsert({
     *   create: {
     *     // ... data to create a ResumeLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeLanguage we want to update
     *   }
     * })
    **/
    upsert<T extends ResumeLanguageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResumeLanguageUpsertArgs<ExtArgs>>
    ): Prisma__ResumeLanguageClient<$Result.GetResult<Prisma.$ResumeLanguagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ResumeLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeLanguageCountArgs} args - Arguments to filter ResumeLanguages to count.
     * @example
     * // Count the number of ResumeLanguages
     * const count = await prisma.resumeLanguage.count({
     *   where: {
     *     // ... the filter for the ResumeLanguages we want to count
     *   }
     * })
    **/
    count<T extends ResumeLanguageCountArgs>(
      args?: Subset<T, ResumeLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeLanguageAggregateArgs>(args: Subset<T, ResumeLanguageAggregateArgs>): Prisma.PrismaPromise<GetResumeLanguageAggregateType<T>>

    /**
     * Group by ResumeLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeLanguageGroupByArgs['orderBy'] }
        : { orderBy?: ResumeLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeLanguage model
   */
  readonly fields: ResumeLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ResumeLanguage model
   */ 
  interface ResumeLanguageFieldRefs {
    readonly resumeOwnerEmail: FieldRef<"ResumeLanguage", 'String'>
    readonly languageName: FieldRef<"ResumeLanguage", 'String'>
    readonly masteryLevel: FieldRef<"ResumeLanguage", 'Int'>
    readonly isVisible: FieldRef<"ResumeLanguage", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ResumeLanguage findUnique
   */
  export type ResumeLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ResumeLanguage to fetch.
     */
    where: ResumeLanguageWhereUniqueInput
  }


  /**
   * ResumeLanguage findUniqueOrThrow
   */
  export type ResumeLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ResumeLanguage to fetch.
     */
    where: ResumeLanguageWhereUniqueInput
  }


  /**
   * ResumeLanguage findFirst
   */
  export type ResumeLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ResumeLanguage to fetch.
     */
    where?: ResumeLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeLanguages to fetch.
     */
    orderBy?: ResumeLanguageOrderByWithRelationInput | ResumeLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeLanguages.
     */
    cursor?: ResumeLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeLanguages.
     */
    distinct?: ResumeLanguageScalarFieldEnum | ResumeLanguageScalarFieldEnum[]
  }


  /**
   * ResumeLanguage findFirstOrThrow
   */
  export type ResumeLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ResumeLanguage to fetch.
     */
    where?: ResumeLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeLanguages to fetch.
     */
    orderBy?: ResumeLanguageOrderByWithRelationInput | ResumeLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeLanguages.
     */
    cursor?: ResumeLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeLanguages.
     */
    distinct?: ResumeLanguageScalarFieldEnum | ResumeLanguageScalarFieldEnum[]
  }


  /**
   * ResumeLanguage findMany
   */
  export type ResumeLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ResumeLanguages to fetch.
     */
    where?: ResumeLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeLanguages to fetch.
     */
    orderBy?: ResumeLanguageOrderByWithRelationInput | ResumeLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeLanguages.
     */
    cursor?: ResumeLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeLanguages.
     */
    skip?: number
    distinct?: ResumeLanguageScalarFieldEnum | ResumeLanguageScalarFieldEnum[]
  }


  /**
   * ResumeLanguage create
   */
  export type ResumeLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeLanguage.
     */
    data: XOR<ResumeLanguageCreateInput, ResumeLanguageUncheckedCreateInput>
  }


  /**
   * ResumeLanguage createMany
   */
  export type ResumeLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeLanguages.
     */
    data: ResumeLanguageCreateManyInput | ResumeLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ResumeLanguage update
   */
  export type ResumeLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeLanguage.
     */
    data: XOR<ResumeLanguageUpdateInput, ResumeLanguageUncheckedUpdateInput>
    /**
     * Choose, which ResumeLanguage to update.
     */
    where: ResumeLanguageWhereUniqueInput
  }


  /**
   * ResumeLanguage updateMany
   */
  export type ResumeLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeLanguages.
     */
    data: XOR<ResumeLanguageUpdateManyMutationInput, ResumeLanguageUncheckedUpdateManyInput>
    /**
     * Filter which ResumeLanguages to update
     */
    where?: ResumeLanguageWhereInput
  }


  /**
   * ResumeLanguage upsert
   */
  export type ResumeLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeLanguage to update in case it exists.
     */
    where: ResumeLanguageWhereUniqueInput
    /**
     * In case the ResumeLanguage found by the `where` argument doesn't exist, create a new ResumeLanguage with this data.
     */
    create: XOR<ResumeLanguageCreateInput, ResumeLanguageUncheckedCreateInput>
    /**
     * In case the ResumeLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeLanguageUpdateInput, ResumeLanguageUncheckedUpdateInput>
  }


  /**
   * ResumeLanguage delete
   */
  export type ResumeLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
    /**
     * Filter which ResumeLanguage to delete.
     */
    where: ResumeLanguageWhereUniqueInput
  }


  /**
   * ResumeLanguage deleteMany
   */
  export type ResumeLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeLanguages to delete
     */
    where?: ResumeLanguageWhereInput
  }


  /**
   * ResumeLanguage without action
   */
  export type ResumeLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeLanguage
     */
    select?: ResumeLanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResumeLanguageInclude<ExtArgs> | null
  }



  /**
   * Model PortfolioItem
   */

  export type AggregatePortfolioItem = {
    _count: PortfolioItemCountAggregateOutputType | null
    _min: PortfolioItemMinAggregateOutputType | null
    _max: PortfolioItemMaxAggregateOutputType | null
  }

  export type PortfolioItemMinAggregateOutputType = {
    resumeOwnerEmail: string | null
    title: string | null
    sourceLink: string | null
    isVisible: boolean | null
  }

  export type PortfolioItemMaxAggregateOutputType = {
    resumeOwnerEmail: string | null
    title: string | null
    sourceLink: string | null
    isVisible: boolean | null
  }

  export type PortfolioItemCountAggregateOutputType = {
    resumeOwnerEmail: number
    title: number
    sourceLink: number
    isVisible: number
    _all: number
  }


  export type PortfolioItemMinAggregateInputType = {
    resumeOwnerEmail?: true
    title?: true
    sourceLink?: true
    isVisible?: true
  }

  export type PortfolioItemMaxAggregateInputType = {
    resumeOwnerEmail?: true
    title?: true
    sourceLink?: true
    isVisible?: true
  }

  export type PortfolioItemCountAggregateInputType = {
    resumeOwnerEmail?: true
    title?: true
    sourceLink?: true
    isVisible?: true
    _all?: true
  }

  export type PortfolioItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioItem to aggregate.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioItems
    **/
    _count?: true | PortfolioItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioItemMaxAggregateInputType
  }

  export type GetPortfolioItemAggregateType<T extends PortfolioItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioItem[P]>
      : GetScalarType<T[P], AggregatePortfolioItem[P]>
  }




  export type PortfolioItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioItemWhereInput
    orderBy?: PortfolioItemOrderByWithAggregationInput | PortfolioItemOrderByWithAggregationInput[]
    by: PortfolioItemScalarFieldEnum[] | PortfolioItemScalarFieldEnum
    having?: PortfolioItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioItemCountAggregateInputType | true
    _min?: PortfolioItemMinAggregateInputType
    _max?: PortfolioItemMaxAggregateInputType
  }

  export type PortfolioItemGroupByOutputType = {
    resumeOwnerEmail: string
    title: string
    sourceLink: string
    isVisible: boolean
    _count: PortfolioItemCountAggregateOutputType | null
    _min: PortfolioItemMinAggregateOutputType | null
    _max: PortfolioItemMaxAggregateOutputType | null
  }

  type GetPortfolioItemGroupByPayload<T extends PortfolioItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioItemGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioItemGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resumeOwnerEmail?: boolean
    title?: boolean
    sourceLink?: boolean
    isVisible?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioItem"]>

  export type PortfolioItemSelectScalar = {
    resumeOwnerEmail?: boolean
    title?: boolean
    sourceLink?: boolean
    isVisible?: boolean
  }

  export type PortfolioItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }


  export type $PortfolioItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioItem"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resumeOwnerEmail: string
      title: string
      sourceLink: string
      isVisible: boolean
    }, ExtArgs["result"]["portfolioItem"]>
    composites: {}
  }


  type PortfolioItemGetPayload<S extends boolean | null | undefined | PortfolioItemDefaultArgs> = $Result.GetResult<Prisma.$PortfolioItemPayload, S>

  type PortfolioItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PortfolioItemFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PortfolioItemCountAggregateInputType | true
    }

  export interface PortfolioItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioItem'], meta: { name: 'PortfolioItem' } }
    /**
     * Find zero or one PortfolioItem that matches the filter.
     * @param {PortfolioItemFindUniqueArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PortfolioItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PortfolioItemFindUniqueArgs<ExtArgs>>
    ): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PortfolioItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PortfolioItemFindUniqueOrThrowArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PortfolioItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PortfolioItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PortfolioItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindFirstArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PortfolioItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PortfolioItemFindFirstArgs<ExtArgs>>
    ): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PortfolioItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindFirstOrThrowArgs} args - Arguments to find a PortfolioItem
     * @example
     * // Get one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PortfolioItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PortfolioItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PortfolioItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioItems
     * const portfolioItems = await prisma.portfolioItem.findMany()
     * 
     * // Get first 10 PortfolioItems
     * const portfolioItems = await prisma.portfolioItem.findMany({ take: 10 })
     * 
     * // Only select the `resumeOwnerEmail`
     * const portfolioItemWithResumeOwnerEmailOnly = await prisma.portfolioItem.findMany({ select: { resumeOwnerEmail: true } })
     * 
    **/
    findMany<T extends PortfolioItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PortfolioItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PortfolioItem.
     * @param {PortfolioItemCreateArgs} args - Arguments to create a PortfolioItem.
     * @example
     * // Create one PortfolioItem
     * const PortfolioItem = await prisma.portfolioItem.create({
     *   data: {
     *     // ... data to create a PortfolioItem
     *   }
     * })
     * 
    **/
    create<T extends PortfolioItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PortfolioItemCreateArgs<ExtArgs>>
    ): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PortfolioItems.
     *     @param {PortfolioItemCreateManyArgs} args - Arguments to create many PortfolioItems.
     *     @example
     *     // Create many PortfolioItems
     *     const portfolioItem = await prisma.portfolioItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PortfolioItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PortfolioItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PortfolioItem.
     * @param {PortfolioItemDeleteArgs} args - Arguments to delete one PortfolioItem.
     * @example
     * // Delete one PortfolioItem
     * const PortfolioItem = await prisma.portfolioItem.delete({
     *   where: {
     *     // ... filter to delete one PortfolioItem
     *   }
     * })
     * 
    **/
    delete<T extends PortfolioItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PortfolioItemDeleteArgs<ExtArgs>>
    ): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PortfolioItem.
     * @param {PortfolioItemUpdateArgs} args - Arguments to update one PortfolioItem.
     * @example
     * // Update one PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PortfolioItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PortfolioItemUpdateArgs<ExtArgs>>
    ): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PortfolioItems.
     * @param {PortfolioItemDeleteManyArgs} args - Arguments to filter PortfolioItems to delete.
     * @example
     * // Delete a few PortfolioItems
     * const { count } = await prisma.portfolioItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PortfolioItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PortfolioItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioItems
     * const portfolioItem = await prisma.portfolioItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PortfolioItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PortfolioItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PortfolioItem.
     * @param {PortfolioItemUpsertArgs} args - Arguments to update or create a PortfolioItem.
     * @example
     * // Update or create a PortfolioItem
     * const portfolioItem = await prisma.portfolioItem.upsert({
     *   create: {
     *     // ... data to create a PortfolioItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioItem we want to update
     *   }
     * })
    **/
    upsert<T extends PortfolioItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PortfolioItemUpsertArgs<ExtArgs>>
    ): Prisma__PortfolioItemClient<$Result.GetResult<Prisma.$PortfolioItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PortfolioItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemCountArgs} args - Arguments to filter PortfolioItems to count.
     * @example
     * // Count the number of PortfolioItems
     * const count = await prisma.portfolioItem.count({
     *   where: {
     *     // ... the filter for the PortfolioItems we want to count
     *   }
     * })
    **/
    count<T extends PortfolioItemCountArgs>(
      args?: Subset<T, PortfolioItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioItemAggregateArgs>(args: Subset<T, PortfolioItemAggregateArgs>): Prisma.PrismaPromise<GetPortfolioItemAggregateType<T>>

    /**
     * Group by PortfolioItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioItemGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioItem model
   */
  readonly fields: PortfolioItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PortfolioItem model
   */ 
  interface PortfolioItemFieldRefs {
    readonly resumeOwnerEmail: FieldRef<"PortfolioItem", 'String'>
    readonly title: FieldRef<"PortfolioItem", 'String'>
    readonly sourceLink: FieldRef<"PortfolioItem", 'String'>
    readonly isVisible: FieldRef<"PortfolioItem", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * PortfolioItem findUnique
   */
  export type PortfolioItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where: PortfolioItemWhereUniqueInput
  }


  /**
   * PortfolioItem findUniqueOrThrow
   */
  export type PortfolioItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where: PortfolioItemWhereUniqueInput
  }


  /**
   * PortfolioItem findFirst
   */
  export type PortfolioItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioItems.
     */
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }


  /**
   * PortfolioItem findFirstOrThrow
   */
  export type PortfolioItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItem to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioItems.
     */
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }


  /**
   * PortfolioItem findMany
   */
  export type PortfolioItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioItems to fetch.
     */
    where?: PortfolioItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioItems to fetch.
     */
    orderBy?: PortfolioItemOrderByWithRelationInput | PortfolioItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioItems.
     */
    cursor?: PortfolioItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioItems.
     */
    skip?: number
    distinct?: PortfolioItemScalarFieldEnum | PortfolioItemScalarFieldEnum[]
  }


  /**
   * PortfolioItem create
   */
  export type PortfolioItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioItem.
     */
    data: XOR<PortfolioItemCreateInput, PortfolioItemUncheckedCreateInput>
  }


  /**
   * PortfolioItem createMany
   */
  export type PortfolioItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioItems.
     */
    data: PortfolioItemCreateManyInput | PortfolioItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PortfolioItem update
   */
  export type PortfolioItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioItem.
     */
    data: XOR<PortfolioItemUpdateInput, PortfolioItemUncheckedUpdateInput>
    /**
     * Choose, which PortfolioItem to update.
     */
    where: PortfolioItemWhereUniqueInput
  }


  /**
   * PortfolioItem updateMany
   */
  export type PortfolioItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioItems.
     */
    data: XOR<PortfolioItemUpdateManyMutationInput, PortfolioItemUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioItems to update
     */
    where?: PortfolioItemWhereInput
  }


  /**
   * PortfolioItem upsert
   */
  export type PortfolioItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioItem to update in case it exists.
     */
    where: PortfolioItemWhereUniqueInput
    /**
     * In case the PortfolioItem found by the `where` argument doesn't exist, create a new PortfolioItem with this data.
     */
    create: XOR<PortfolioItemCreateInput, PortfolioItemUncheckedCreateInput>
    /**
     * In case the PortfolioItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioItemUpdateInput, PortfolioItemUncheckedUpdateInput>
  }


  /**
   * PortfolioItem delete
   */
  export type PortfolioItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
    /**
     * Filter which PortfolioItem to delete.
     */
    where: PortfolioItemWhereUniqueInput
  }


  /**
   * PortfolioItem deleteMany
   */
  export type PortfolioItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioItems to delete
     */
    where?: PortfolioItemWhereInput
  }


  /**
   * PortfolioItem without action
   */
  export type PortfolioItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioItem
     */
    select?: PortfolioItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PortfolioItemInclude<ExtArgs> | null
  }



  /**
   * Model HigherEducationStudy
   */

  export type AggregateHigherEducationStudy = {
    _count: HigherEducationStudyCountAggregateOutputType | null
    _min: HigherEducationStudyMinAggregateOutputType | null
    _max: HigherEducationStudyMaxAggregateOutputType | null
  }

  export type HigherEducationStudyMinAggregateOutputType = {
    resumeOwnerEmail: string | null
    title: string | null
    institution: string | null
    endDate: Date | null
    isVisible: boolean | null
  }

  export type HigherEducationStudyMaxAggregateOutputType = {
    resumeOwnerEmail: string | null
    title: string | null
    institution: string | null
    endDate: Date | null
    isVisible: boolean | null
  }

  export type HigherEducationStudyCountAggregateOutputType = {
    resumeOwnerEmail: number
    title: number
    institution: number
    endDate: number
    isVisible: number
    _all: number
  }


  export type HigherEducationStudyMinAggregateInputType = {
    resumeOwnerEmail?: true
    title?: true
    institution?: true
    endDate?: true
    isVisible?: true
  }

  export type HigherEducationStudyMaxAggregateInputType = {
    resumeOwnerEmail?: true
    title?: true
    institution?: true
    endDate?: true
    isVisible?: true
  }

  export type HigherEducationStudyCountAggregateInputType = {
    resumeOwnerEmail?: true
    title?: true
    institution?: true
    endDate?: true
    isVisible?: true
    _all?: true
  }

  export type HigherEducationStudyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HigherEducationStudy to aggregate.
     */
    where?: HigherEducationStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HigherEducationStudies to fetch.
     */
    orderBy?: HigherEducationStudyOrderByWithRelationInput | HigherEducationStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HigherEducationStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HigherEducationStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HigherEducationStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HigherEducationStudies
    **/
    _count?: true | HigherEducationStudyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HigherEducationStudyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HigherEducationStudyMaxAggregateInputType
  }

  export type GetHigherEducationStudyAggregateType<T extends HigherEducationStudyAggregateArgs> = {
        [P in keyof T & keyof AggregateHigherEducationStudy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHigherEducationStudy[P]>
      : GetScalarType<T[P], AggregateHigherEducationStudy[P]>
  }




  export type HigherEducationStudyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HigherEducationStudyWhereInput
    orderBy?: HigherEducationStudyOrderByWithAggregationInput | HigherEducationStudyOrderByWithAggregationInput[]
    by: HigherEducationStudyScalarFieldEnum[] | HigherEducationStudyScalarFieldEnum
    having?: HigherEducationStudyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HigherEducationStudyCountAggregateInputType | true
    _min?: HigherEducationStudyMinAggregateInputType
    _max?: HigherEducationStudyMaxAggregateInputType
  }

  export type HigherEducationStudyGroupByOutputType = {
    resumeOwnerEmail: string
    title: string
    institution: string
    endDate: Date
    isVisible: boolean
    _count: HigherEducationStudyCountAggregateOutputType | null
    _min: HigherEducationStudyMinAggregateOutputType | null
    _max: HigherEducationStudyMaxAggregateOutputType | null
  }

  type GetHigherEducationStudyGroupByPayload<T extends HigherEducationStudyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HigherEducationStudyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HigherEducationStudyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HigherEducationStudyGroupByOutputType[P]>
            : GetScalarType<T[P], HigherEducationStudyGroupByOutputType[P]>
        }
      >
    >


  export type HigherEducationStudySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resumeOwnerEmail?: boolean
    title?: boolean
    institution?: boolean
    endDate?: boolean
    isVisible?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["higherEducationStudy"]>

  export type HigherEducationStudySelectScalar = {
    resumeOwnerEmail?: boolean
    title?: boolean
    institution?: boolean
    endDate?: boolean
    isVisible?: boolean
  }

  export type HigherEducationStudyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }


  export type $HigherEducationStudyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HigherEducationStudy"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resumeOwnerEmail: string
      title: string
      institution: string
      endDate: Date
      isVisible: boolean
    }, ExtArgs["result"]["higherEducationStudy"]>
    composites: {}
  }


  type HigherEducationStudyGetPayload<S extends boolean | null | undefined | HigherEducationStudyDefaultArgs> = $Result.GetResult<Prisma.$HigherEducationStudyPayload, S>

  type HigherEducationStudyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HigherEducationStudyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: HigherEducationStudyCountAggregateInputType | true
    }

  export interface HigherEducationStudyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HigherEducationStudy'], meta: { name: 'HigherEducationStudy' } }
    /**
     * Find zero or one HigherEducationStudy that matches the filter.
     * @param {HigherEducationStudyFindUniqueArgs} args - Arguments to find a HigherEducationStudy
     * @example
     * // Get one HigherEducationStudy
     * const higherEducationStudy = await prisma.higherEducationStudy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HigherEducationStudyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HigherEducationStudyFindUniqueArgs<ExtArgs>>
    ): Prisma__HigherEducationStudyClient<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HigherEducationStudy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HigherEducationStudyFindUniqueOrThrowArgs} args - Arguments to find a HigherEducationStudy
     * @example
     * // Get one HigherEducationStudy
     * const higherEducationStudy = await prisma.higherEducationStudy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HigherEducationStudyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HigherEducationStudyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HigherEducationStudyClient<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HigherEducationStudy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HigherEducationStudyFindFirstArgs} args - Arguments to find a HigherEducationStudy
     * @example
     * // Get one HigherEducationStudy
     * const higherEducationStudy = await prisma.higherEducationStudy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HigherEducationStudyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HigherEducationStudyFindFirstArgs<ExtArgs>>
    ): Prisma__HigherEducationStudyClient<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HigherEducationStudy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HigherEducationStudyFindFirstOrThrowArgs} args - Arguments to find a HigherEducationStudy
     * @example
     * // Get one HigherEducationStudy
     * const higherEducationStudy = await prisma.higherEducationStudy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HigherEducationStudyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HigherEducationStudyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HigherEducationStudyClient<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HigherEducationStudies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HigherEducationStudyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HigherEducationStudies
     * const higherEducationStudies = await prisma.higherEducationStudy.findMany()
     * 
     * // Get first 10 HigherEducationStudies
     * const higherEducationStudies = await prisma.higherEducationStudy.findMany({ take: 10 })
     * 
     * // Only select the `resumeOwnerEmail`
     * const higherEducationStudyWithResumeOwnerEmailOnly = await prisma.higherEducationStudy.findMany({ select: { resumeOwnerEmail: true } })
     * 
    **/
    findMany<T extends HigherEducationStudyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HigherEducationStudyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HigherEducationStudy.
     * @param {HigherEducationStudyCreateArgs} args - Arguments to create a HigherEducationStudy.
     * @example
     * // Create one HigherEducationStudy
     * const HigherEducationStudy = await prisma.higherEducationStudy.create({
     *   data: {
     *     // ... data to create a HigherEducationStudy
     *   }
     * })
     * 
    **/
    create<T extends HigherEducationStudyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HigherEducationStudyCreateArgs<ExtArgs>>
    ): Prisma__HigherEducationStudyClient<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HigherEducationStudies.
     *     @param {HigherEducationStudyCreateManyArgs} args - Arguments to create many HigherEducationStudies.
     *     @example
     *     // Create many HigherEducationStudies
     *     const higherEducationStudy = await prisma.higherEducationStudy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HigherEducationStudyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HigherEducationStudyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HigherEducationStudy.
     * @param {HigherEducationStudyDeleteArgs} args - Arguments to delete one HigherEducationStudy.
     * @example
     * // Delete one HigherEducationStudy
     * const HigherEducationStudy = await prisma.higherEducationStudy.delete({
     *   where: {
     *     // ... filter to delete one HigherEducationStudy
     *   }
     * })
     * 
    **/
    delete<T extends HigherEducationStudyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HigherEducationStudyDeleteArgs<ExtArgs>>
    ): Prisma__HigherEducationStudyClient<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HigherEducationStudy.
     * @param {HigherEducationStudyUpdateArgs} args - Arguments to update one HigherEducationStudy.
     * @example
     * // Update one HigherEducationStudy
     * const higherEducationStudy = await prisma.higherEducationStudy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HigherEducationStudyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HigherEducationStudyUpdateArgs<ExtArgs>>
    ): Prisma__HigherEducationStudyClient<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HigherEducationStudies.
     * @param {HigherEducationStudyDeleteManyArgs} args - Arguments to filter HigherEducationStudies to delete.
     * @example
     * // Delete a few HigherEducationStudies
     * const { count } = await prisma.higherEducationStudy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HigherEducationStudyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HigherEducationStudyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HigherEducationStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HigherEducationStudyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HigherEducationStudies
     * const higherEducationStudy = await prisma.higherEducationStudy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HigherEducationStudyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HigherEducationStudyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HigherEducationStudy.
     * @param {HigherEducationStudyUpsertArgs} args - Arguments to update or create a HigherEducationStudy.
     * @example
     * // Update or create a HigherEducationStudy
     * const higherEducationStudy = await prisma.higherEducationStudy.upsert({
     *   create: {
     *     // ... data to create a HigherEducationStudy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HigherEducationStudy we want to update
     *   }
     * })
    **/
    upsert<T extends HigherEducationStudyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HigherEducationStudyUpsertArgs<ExtArgs>>
    ): Prisma__HigherEducationStudyClient<$Result.GetResult<Prisma.$HigherEducationStudyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HigherEducationStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HigherEducationStudyCountArgs} args - Arguments to filter HigherEducationStudies to count.
     * @example
     * // Count the number of HigherEducationStudies
     * const count = await prisma.higherEducationStudy.count({
     *   where: {
     *     // ... the filter for the HigherEducationStudies we want to count
     *   }
     * })
    **/
    count<T extends HigherEducationStudyCountArgs>(
      args?: Subset<T, HigherEducationStudyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HigherEducationStudyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HigherEducationStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HigherEducationStudyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HigherEducationStudyAggregateArgs>(args: Subset<T, HigherEducationStudyAggregateArgs>): Prisma.PrismaPromise<GetHigherEducationStudyAggregateType<T>>

    /**
     * Group by HigherEducationStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HigherEducationStudyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HigherEducationStudyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HigherEducationStudyGroupByArgs['orderBy'] }
        : { orderBy?: HigherEducationStudyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HigherEducationStudyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHigherEducationStudyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HigherEducationStudy model
   */
  readonly fields: HigherEducationStudyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HigherEducationStudy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HigherEducationStudyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HigherEducationStudy model
   */ 
  interface HigherEducationStudyFieldRefs {
    readonly resumeOwnerEmail: FieldRef<"HigherEducationStudy", 'String'>
    readonly title: FieldRef<"HigherEducationStudy", 'String'>
    readonly institution: FieldRef<"HigherEducationStudy", 'String'>
    readonly endDate: FieldRef<"HigherEducationStudy", 'DateTime'>
    readonly isVisible: FieldRef<"HigherEducationStudy", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * HigherEducationStudy findUnique
   */
  export type HigherEducationStudyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * Filter, which HigherEducationStudy to fetch.
     */
    where: HigherEducationStudyWhereUniqueInput
  }


  /**
   * HigherEducationStudy findUniqueOrThrow
   */
  export type HigherEducationStudyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * Filter, which HigherEducationStudy to fetch.
     */
    where: HigherEducationStudyWhereUniqueInput
  }


  /**
   * HigherEducationStudy findFirst
   */
  export type HigherEducationStudyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * Filter, which HigherEducationStudy to fetch.
     */
    where?: HigherEducationStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HigherEducationStudies to fetch.
     */
    orderBy?: HigherEducationStudyOrderByWithRelationInput | HigherEducationStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HigherEducationStudies.
     */
    cursor?: HigherEducationStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HigherEducationStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HigherEducationStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HigherEducationStudies.
     */
    distinct?: HigherEducationStudyScalarFieldEnum | HigherEducationStudyScalarFieldEnum[]
  }


  /**
   * HigherEducationStudy findFirstOrThrow
   */
  export type HigherEducationStudyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * Filter, which HigherEducationStudy to fetch.
     */
    where?: HigherEducationStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HigherEducationStudies to fetch.
     */
    orderBy?: HigherEducationStudyOrderByWithRelationInput | HigherEducationStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HigherEducationStudies.
     */
    cursor?: HigherEducationStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HigherEducationStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HigherEducationStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HigherEducationStudies.
     */
    distinct?: HigherEducationStudyScalarFieldEnum | HigherEducationStudyScalarFieldEnum[]
  }


  /**
   * HigherEducationStudy findMany
   */
  export type HigherEducationStudyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * Filter, which HigherEducationStudies to fetch.
     */
    where?: HigherEducationStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HigherEducationStudies to fetch.
     */
    orderBy?: HigherEducationStudyOrderByWithRelationInput | HigherEducationStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HigherEducationStudies.
     */
    cursor?: HigherEducationStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HigherEducationStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HigherEducationStudies.
     */
    skip?: number
    distinct?: HigherEducationStudyScalarFieldEnum | HigherEducationStudyScalarFieldEnum[]
  }


  /**
   * HigherEducationStudy create
   */
  export type HigherEducationStudyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * The data needed to create a HigherEducationStudy.
     */
    data: XOR<HigherEducationStudyCreateInput, HigherEducationStudyUncheckedCreateInput>
  }


  /**
   * HigherEducationStudy createMany
   */
  export type HigherEducationStudyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HigherEducationStudies.
     */
    data: HigherEducationStudyCreateManyInput | HigherEducationStudyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * HigherEducationStudy update
   */
  export type HigherEducationStudyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * The data needed to update a HigherEducationStudy.
     */
    data: XOR<HigherEducationStudyUpdateInput, HigherEducationStudyUncheckedUpdateInput>
    /**
     * Choose, which HigherEducationStudy to update.
     */
    where: HigherEducationStudyWhereUniqueInput
  }


  /**
   * HigherEducationStudy updateMany
   */
  export type HigherEducationStudyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HigherEducationStudies.
     */
    data: XOR<HigherEducationStudyUpdateManyMutationInput, HigherEducationStudyUncheckedUpdateManyInput>
    /**
     * Filter which HigherEducationStudies to update
     */
    where?: HigherEducationStudyWhereInput
  }


  /**
   * HigherEducationStudy upsert
   */
  export type HigherEducationStudyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * The filter to search for the HigherEducationStudy to update in case it exists.
     */
    where: HigherEducationStudyWhereUniqueInput
    /**
     * In case the HigherEducationStudy found by the `where` argument doesn't exist, create a new HigherEducationStudy with this data.
     */
    create: XOR<HigherEducationStudyCreateInput, HigherEducationStudyUncheckedCreateInput>
    /**
     * In case the HigherEducationStudy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HigherEducationStudyUpdateInput, HigherEducationStudyUncheckedUpdateInput>
  }


  /**
   * HigherEducationStudy delete
   */
  export type HigherEducationStudyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
    /**
     * Filter which HigherEducationStudy to delete.
     */
    where: HigherEducationStudyWhereUniqueInput
  }


  /**
   * HigherEducationStudy deleteMany
   */
  export type HigherEducationStudyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HigherEducationStudies to delete
     */
    where?: HigherEducationStudyWhereInput
  }


  /**
   * HigherEducationStudy without action
   */
  export type HigherEducationStudyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HigherEducationStudy
     */
    select?: HigherEducationStudySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HigherEducationStudyInclude<ExtArgs> | null
  }



  /**
   * Model PositionOfInterest
   */

  export type AggregatePositionOfInterest = {
    _count: PositionOfInterestCountAggregateOutputType | null
    _min: PositionOfInterestMinAggregateOutputType | null
    _max: PositionOfInterestMaxAggregateOutputType | null
  }

  export type PositionOfInterestMinAggregateOutputType = {
    resumeOwnerEmail: string | null
    positionName: string | null
    isVisible: boolean | null
  }

  export type PositionOfInterestMaxAggregateOutputType = {
    resumeOwnerEmail: string | null
    positionName: string | null
    isVisible: boolean | null
  }

  export type PositionOfInterestCountAggregateOutputType = {
    resumeOwnerEmail: number
    positionName: number
    isVisible: number
    _all: number
  }


  export type PositionOfInterestMinAggregateInputType = {
    resumeOwnerEmail?: true
    positionName?: true
    isVisible?: true
  }

  export type PositionOfInterestMaxAggregateInputType = {
    resumeOwnerEmail?: true
    positionName?: true
    isVisible?: true
  }

  export type PositionOfInterestCountAggregateInputType = {
    resumeOwnerEmail?: true
    positionName?: true
    isVisible?: true
    _all?: true
  }

  export type PositionOfInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PositionOfInterest to aggregate.
     */
    where?: PositionOfInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionOfInterests to fetch.
     */
    orderBy?: PositionOfInterestOrderByWithRelationInput | PositionOfInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionOfInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionOfInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionOfInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PositionOfInterests
    **/
    _count?: true | PositionOfInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionOfInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionOfInterestMaxAggregateInputType
  }

  export type GetPositionOfInterestAggregateType<T extends PositionOfInterestAggregateArgs> = {
        [P in keyof T & keyof AggregatePositionOfInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePositionOfInterest[P]>
      : GetScalarType<T[P], AggregatePositionOfInterest[P]>
  }




  export type PositionOfInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionOfInterestWhereInput
    orderBy?: PositionOfInterestOrderByWithAggregationInput | PositionOfInterestOrderByWithAggregationInput[]
    by: PositionOfInterestScalarFieldEnum[] | PositionOfInterestScalarFieldEnum
    having?: PositionOfInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionOfInterestCountAggregateInputType | true
    _min?: PositionOfInterestMinAggregateInputType
    _max?: PositionOfInterestMaxAggregateInputType
  }

  export type PositionOfInterestGroupByOutputType = {
    resumeOwnerEmail: string
    positionName: string
    isVisible: boolean
    _count: PositionOfInterestCountAggregateOutputType | null
    _min: PositionOfInterestMinAggregateOutputType | null
    _max: PositionOfInterestMaxAggregateOutputType | null
  }

  type GetPositionOfInterestGroupByPayload<T extends PositionOfInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionOfInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionOfInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionOfInterestGroupByOutputType[P]>
            : GetScalarType<T[P], PositionOfInterestGroupByOutputType[P]>
        }
      >
    >


  export type PositionOfInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resumeOwnerEmail?: boolean
    positionName?: boolean
    isVisible?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["positionOfInterest"]>

  export type PositionOfInterestSelectScalar = {
    resumeOwnerEmail?: boolean
    positionName?: boolean
    isVisible?: boolean
  }

  export type PositionOfInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }


  export type $PositionOfInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PositionOfInterest"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resumeOwnerEmail: string
      positionName: string
      isVisible: boolean
    }, ExtArgs["result"]["positionOfInterest"]>
    composites: {}
  }


  type PositionOfInterestGetPayload<S extends boolean | null | undefined | PositionOfInterestDefaultArgs> = $Result.GetResult<Prisma.$PositionOfInterestPayload, S>

  type PositionOfInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PositionOfInterestFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PositionOfInterestCountAggregateInputType | true
    }

  export interface PositionOfInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PositionOfInterest'], meta: { name: 'PositionOfInterest' } }
    /**
     * Find zero or one PositionOfInterest that matches the filter.
     * @param {PositionOfInterestFindUniqueArgs} args - Arguments to find a PositionOfInterest
     * @example
     * // Get one PositionOfInterest
     * const positionOfInterest = await prisma.positionOfInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PositionOfInterestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PositionOfInterestFindUniqueArgs<ExtArgs>>
    ): Prisma__PositionOfInterestClient<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PositionOfInterest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PositionOfInterestFindUniqueOrThrowArgs} args - Arguments to find a PositionOfInterest
     * @example
     * // Get one PositionOfInterest
     * const positionOfInterest = await prisma.positionOfInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PositionOfInterestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PositionOfInterestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PositionOfInterestClient<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PositionOfInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOfInterestFindFirstArgs} args - Arguments to find a PositionOfInterest
     * @example
     * // Get one PositionOfInterest
     * const positionOfInterest = await prisma.positionOfInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PositionOfInterestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PositionOfInterestFindFirstArgs<ExtArgs>>
    ): Prisma__PositionOfInterestClient<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PositionOfInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOfInterestFindFirstOrThrowArgs} args - Arguments to find a PositionOfInterest
     * @example
     * // Get one PositionOfInterest
     * const positionOfInterest = await prisma.positionOfInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PositionOfInterestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PositionOfInterestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PositionOfInterestClient<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PositionOfInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOfInterestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PositionOfInterests
     * const positionOfInterests = await prisma.positionOfInterest.findMany()
     * 
     * // Get first 10 PositionOfInterests
     * const positionOfInterests = await prisma.positionOfInterest.findMany({ take: 10 })
     * 
     * // Only select the `resumeOwnerEmail`
     * const positionOfInterestWithResumeOwnerEmailOnly = await prisma.positionOfInterest.findMany({ select: { resumeOwnerEmail: true } })
     * 
    **/
    findMany<T extends PositionOfInterestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PositionOfInterestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PositionOfInterest.
     * @param {PositionOfInterestCreateArgs} args - Arguments to create a PositionOfInterest.
     * @example
     * // Create one PositionOfInterest
     * const PositionOfInterest = await prisma.positionOfInterest.create({
     *   data: {
     *     // ... data to create a PositionOfInterest
     *   }
     * })
     * 
    **/
    create<T extends PositionOfInterestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PositionOfInterestCreateArgs<ExtArgs>>
    ): Prisma__PositionOfInterestClient<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PositionOfInterests.
     *     @param {PositionOfInterestCreateManyArgs} args - Arguments to create many PositionOfInterests.
     *     @example
     *     // Create many PositionOfInterests
     *     const positionOfInterest = await prisma.positionOfInterest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PositionOfInterestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PositionOfInterestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PositionOfInterest.
     * @param {PositionOfInterestDeleteArgs} args - Arguments to delete one PositionOfInterest.
     * @example
     * // Delete one PositionOfInterest
     * const PositionOfInterest = await prisma.positionOfInterest.delete({
     *   where: {
     *     // ... filter to delete one PositionOfInterest
     *   }
     * })
     * 
    **/
    delete<T extends PositionOfInterestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PositionOfInterestDeleteArgs<ExtArgs>>
    ): Prisma__PositionOfInterestClient<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PositionOfInterest.
     * @param {PositionOfInterestUpdateArgs} args - Arguments to update one PositionOfInterest.
     * @example
     * // Update one PositionOfInterest
     * const positionOfInterest = await prisma.positionOfInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PositionOfInterestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PositionOfInterestUpdateArgs<ExtArgs>>
    ): Prisma__PositionOfInterestClient<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PositionOfInterests.
     * @param {PositionOfInterestDeleteManyArgs} args - Arguments to filter PositionOfInterests to delete.
     * @example
     * // Delete a few PositionOfInterests
     * const { count } = await prisma.positionOfInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PositionOfInterestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PositionOfInterestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PositionOfInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOfInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PositionOfInterests
     * const positionOfInterest = await prisma.positionOfInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PositionOfInterestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PositionOfInterestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PositionOfInterest.
     * @param {PositionOfInterestUpsertArgs} args - Arguments to update or create a PositionOfInterest.
     * @example
     * // Update or create a PositionOfInterest
     * const positionOfInterest = await prisma.positionOfInterest.upsert({
     *   create: {
     *     // ... data to create a PositionOfInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PositionOfInterest we want to update
     *   }
     * })
    **/
    upsert<T extends PositionOfInterestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PositionOfInterestUpsertArgs<ExtArgs>>
    ): Prisma__PositionOfInterestClient<$Result.GetResult<Prisma.$PositionOfInterestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PositionOfInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOfInterestCountArgs} args - Arguments to filter PositionOfInterests to count.
     * @example
     * // Count the number of PositionOfInterests
     * const count = await prisma.positionOfInterest.count({
     *   where: {
     *     // ... the filter for the PositionOfInterests we want to count
     *   }
     * })
    **/
    count<T extends PositionOfInterestCountArgs>(
      args?: Subset<T, PositionOfInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionOfInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PositionOfInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOfInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionOfInterestAggregateArgs>(args: Subset<T, PositionOfInterestAggregateArgs>): Prisma.PrismaPromise<GetPositionOfInterestAggregateType<T>>

    /**
     * Group by PositionOfInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOfInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionOfInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionOfInterestGroupByArgs['orderBy'] }
        : { orderBy?: PositionOfInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionOfInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionOfInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PositionOfInterest model
   */
  readonly fields: PositionOfInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PositionOfInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionOfInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PositionOfInterest model
   */ 
  interface PositionOfInterestFieldRefs {
    readonly resumeOwnerEmail: FieldRef<"PositionOfInterest", 'String'>
    readonly positionName: FieldRef<"PositionOfInterest", 'String'>
    readonly isVisible: FieldRef<"PositionOfInterest", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * PositionOfInterest findUnique
   */
  export type PositionOfInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which PositionOfInterest to fetch.
     */
    where: PositionOfInterestWhereUniqueInput
  }


  /**
   * PositionOfInterest findUniqueOrThrow
   */
  export type PositionOfInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which PositionOfInterest to fetch.
     */
    where: PositionOfInterestWhereUniqueInput
  }


  /**
   * PositionOfInterest findFirst
   */
  export type PositionOfInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which PositionOfInterest to fetch.
     */
    where?: PositionOfInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionOfInterests to fetch.
     */
    orderBy?: PositionOfInterestOrderByWithRelationInput | PositionOfInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PositionOfInterests.
     */
    cursor?: PositionOfInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionOfInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionOfInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PositionOfInterests.
     */
    distinct?: PositionOfInterestScalarFieldEnum | PositionOfInterestScalarFieldEnum[]
  }


  /**
   * PositionOfInterest findFirstOrThrow
   */
  export type PositionOfInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which PositionOfInterest to fetch.
     */
    where?: PositionOfInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionOfInterests to fetch.
     */
    orderBy?: PositionOfInterestOrderByWithRelationInput | PositionOfInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PositionOfInterests.
     */
    cursor?: PositionOfInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionOfInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionOfInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PositionOfInterests.
     */
    distinct?: PositionOfInterestScalarFieldEnum | PositionOfInterestScalarFieldEnum[]
  }


  /**
   * PositionOfInterest findMany
   */
  export type PositionOfInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which PositionOfInterests to fetch.
     */
    where?: PositionOfInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionOfInterests to fetch.
     */
    orderBy?: PositionOfInterestOrderByWithRelationInput | PositionOfInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PositionOfInterests.
     */
    cursor?: PositionOfInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionOfInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionOfInterests.
     */
    skip?: number
    distinct?: PositionOfInterestScalarFieldEnum | PositionOfInterestScalarFieldEnum[]
  }


  /**
   * PositionOfInterest create
   */
  export type PositionOfInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a PositionOfInterest.
     */
    data: XOR<PositionOfInterestCreateInput, PositionOfInterestUncheckedCreateInput>
  }


  /**
   * PositionOfInterest createMany
   */
  export type PositionOfInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PositionOfInterests.
     */
    data: PositionOfInterestCreateManyInput | PositionOfInterestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PositionOfInterest update
   */
  export type PositionOfInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a PositionOfInterest.
     */
    data: XOR<PositionOfInterestUpdateInput, PositionOfInterestUncheckedUpdateInput>
    /**
     * Choose, which PositionOfInterest to update.
     */
    where: PositionOfInterestWhereUniqueInput
  }


  /**
   * PositionOfInterest updateMany
   */
  export type PositionOfInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PositionOfInterests.
     */
    data: XOR<PositionOfInterestUpdateManyMutationInput, PositionOfInterestUncheckedUpdateManyInput>
    /**
     * Filter which PositionOfInterests to update
     */
    where?: PositionOfInterestWhereInput
  }


  /**
   * PositionOfInterest upsert
   */
  export type PositionOfInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the PositionOfInterest to update in case it exists.
     */
    where: PositionOfInterestWhereUniqueInput
    /**
     * In case the PositionOfInterest found by the `where` argument doesn't exist, create a new PositionOfInterest with this data.
     */
    create: XOR<PositionOfInterestCreateInput, PositionOfInterestUncheckedCreateInput>
    /**
     * In case the PositionOfInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionOfInterestUpdateInput, PositionOfInterestUncheckedUpdateInput>
  }


  /**
   * PositionOfInterest delete
   */
  export type PositionOfInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
    /**
     * Filter which PositionOfInterest to delete.
     */
    where: PositionOfInterestWhereUniqueInput
  }


  /**
   * PositionOfInterest deleteMany
   */
  export type PositionOfInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PositionOfInterests to delete
     */
    where?: PositionOfInterestWhereInput
  }


  /**
   * PositionOfInterest without action
   */
  export type PositionOfInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionOfInterest
     */
    select?: PositionOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionOfInterestInclude<ExtArgs> | null
  }



  /**
   * Model IndustryOfInterest
   */

  export type AggregateIndustryOfInterest = {
    _count: IndustryOfInterestCountAggregateOutputType | null
    _min: IndustryOfInterestMinAggregateOutputType | null
    _max: IndustryOfInterestMaxAggregateOutputType | null
  }

  export type IndustryOfInterestMinAggregateOutputType = {
    resumeOwnerEmail: string | null
    industryName: string | null
    isVisible: boolean | null
  }

  export type IndustryOfInterestMaxAggregateOutputType = {
    resumeOwnerEmail: string | null
    industryName: string | null
    isVisible: boolean | null
  }

  export type IndustryOfInterestCountAggregateOutputType = {
    resumeOwnerEmail: number
    industryName: number
    isVisible: number
    _all: number
  }


  export type IndustryOfInterestMinAggregateInputType = {
    resumeOwnerEmail?: true
    industryName?: true
    isVisible?: true
  }

  export type IndustryOfInterestMaxAggregateInputType = {
    resumeOwnerEmail?: true
    industryName?: true
    isVisible?: true
  }

  export type IndustryOfInterestCountAggregateInputType = {
    resumeOwnerEmail?: true
    industryName?: true
    isVisible?: true
    _all?: true
  }

  export type IndustryOfInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndustryOfInterest to aggregate.
     */
    where?: IndustryOfInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndustryOfInterests to fetch.
     */
    orderBy?: IndustryOfInterestOrderByWithRelationInput | IndustryOfInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndustryOfInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndustryOfInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndustryOfInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndustryOfInterests
    **/
    _count?: true | IndustryOfInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndustryOfInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndustryOfInterestMaxAggregateInputType
  }

  export type GetIndustryOfInterestAggregateType<T extends IndustryOfInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustryOfInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustryOfInterest[P]>
      : GetScalarType<T[P], AggregateIndustryOfInterest[P]>
  }




  export type IndustryOfInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndustryOfInterestWhereInput
    orderBy?: IndustryOfInterestOrderByWithAggregationInput | IndustryOfInterestOrderByWithAggregationInput[]
    by: IndustryOfInterestScalarFieldEnum[] | IndustryOfInterestScalarFieldEnum
    having?: IndustryOfInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndustryOfInterestCountAggregateInputType | true
    _min?: IndustryOfInterestMinAggregateInputType
    _max?: IndustryOfInterestMaxAggregateInputType
  }

  export type IndustryOfInterestGroupByOutputType = {
    resumeOwnerEmail: string
    industryName: string
    isVisible: boolean
    _count: IndustryOfInterestCountAggregateOutputType | null
    _min: IndustryOfInterestMinAggregateOutputType | null
    _max: IndustryOfInterestMaxAggregateOutputType | null
  }

  type GetIndustryOfInterestGroupByPayload<T extends IndustryOfInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndustryOfInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndustryOfInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndustryOfInterestGroupByOutputType[P]>
            : GetScalarType<T[P], IndustryOfInterestGroupByOutputType[P]>
        }
      >
    >


  export type IndustryOfInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resumeOwnerEmail?: boolean
    industryName?: boolean
    isVisible?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["industryOfInterest"]>

  export type IndustryOfInterestSelectScalar = {
    resumeOwnerEmail?: boolean
    industryName?: boolean
    isVisible?: boolean
  }

  export type IndustryOfInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }


  export type $IndustryOfInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndustryOfInterest"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resumeOwnerEmail: string
      industryName: string
      isVisible: boolean
    }, ExtArgs["result"]["industryOfInterest"]>
    composites: {}
  }


  type IndustryOfInterestGetPayload<S extends boolean | null | undefined | IndustryOfInterestDefaultArgs> = $Result.GetResult<Prisma.$IndustryOfInterestPayload, S>

  type IndustryOfInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndustryOfInterestFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IndustryOfInterestCountAggregateInputType | true
    }

  export interface IndustryOfInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndustryOfInterest'], meta: { name: 'IndustryOfInterest' } }
    /**
     * Find zero or one IndustryOfInterest that matches the filter.
     * @param {IndustryOfInterestFindUniqueArgs} args - Arguments to find a IndustryOfInterest
     * @example
     * // Get one IndustryOfInterest
     * const industryOfInterest = await prisma.industryOfInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IndustryOfInterestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IndustryOfInterestFindUniqueArgs<ExtArgs>>
    ): Prisma__IndustryOfInterestClient<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IndustryOfInterest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IndustryOfInterestFindUniqueOrThrowArgs} args - Arguments to find a IndustryOfInterest
     * @example
     * // Get one IndustryOfInterest
     * const industryOfInterest = await prisma.industryOfInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IndustryOfInterestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IndustryOfInterestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IndustryOfInterestClient<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IndustryOfInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryOfInterestFindFirstArgs} args - Arguments to find a IndustryOfInterest
     * @example
     * // Get one IndustryOfInterest
     * const industryOfInterest = await prisma.industryOfInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IndustryOfInterestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IndustryOfInterestFindFirstArgs<ExtArgs>>
    ): Prisma__IndustryOfInterestClient<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IndustryOfInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryOfInterestFindFirstOrThrowArgs} args - Arguments to find a IndustryOfInterest
     * @example
     * // Get one IndustryOfInterest
     * const industryOfInterest = await prisma.industryOfInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IndustryOfInterestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IndustryOfInterestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IndustryOfInterestClient<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IndustryOfInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryOfInterestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndustryOfInterests
     * const industryOfInterests = await prisma.industryOfInterest.findMany()
     * 
     * // Get first 10 IndustryOfInterests
     * const industryOfInterests = await prisma.industryOfInterest.findMany({ take: 10 })
     * 
     * // Only select the `resumeOwnerEmail`
     * const industryOfInterestWithResumeOwnerEmailOnly = await prisma.industryOfInterest.findMany({ select: { resumeOwnerEmail: true } })
     * 
    **/
    findMany<T extends IndustryOfInterestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IndustryOfInterestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IndustryOfInterest.
     * @param {IndustryOfInterestCreateArgs} args - Arguments to create a IndustryOfInterest.
     * @example
     * // Create one IndustryOfInterest
     * const IndustryOfInterest = await prisma.industryOfInterest.create({
     *   data: {
     *     // ... data to create a IndustryOfInterest
     *   }
     * })
     * 
    **/
    create<T extends IndustryOfInterestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IndustryOfInterestCreateArgs<ExtArgs>>
    ): Prisma__IndustryOfInterestClient<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IndustryOfInterests.
     *     @param {IndustryOfInterestCreateManyArgs} args - Arguments to create many IndustryOfInterests.
     *     @example
     *     // Create many IndustryOfInterests
     *     const industryOfInterest = await prisma.industryOfInterest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IndustryOfInterestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IndustryOfInterestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IndustryOfInterest.
     * @param {IndustryOfInterestDeleteArgs} args - Arguments to delete one IndustryOfInterest.
     * @example
     * // Delete one IndustryOfInterest
     * const IndustryOfInterest = await prisma.industryOfInterest.delete({
     *   where: {
     *     // ... filter to delete one IndustryOfInterest
     *   }
     * })
     * 
    **/
    delete<T extends IndustryOfInterestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IndustryOfInterestDeleteArgs<ExtArgs>>
    ): Prisma__IndustryOfInterestClient<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IndustryOfInterest.
     * @param {IndustryOfInterestUpdateArgs} args - Arguments to update one IndustryOfInterest.
     * @example
     * // Update one IndustryOfInterest
     * const industryOfInterest = await prisma.industryOfInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IndustryOfInterestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IndustryOfInterestUpdateArgs<ExtArgs>>
    ): Prisma__IndustryOfInterestClient<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IndustryOfInterests.
     * @param {IndustryOfInterestDeleteManyArgs} args - Arguments to filter IndustryOfInterests to delete.
     * @example
     * // Delete a few IndustryOfInterests
     * const { count } = await prisma.industryOfInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IndustryOfInterestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IndustryOfInterestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndustryOfInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryOfInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndustryOfInterests
     * const industryOfInterest = await prisma.industryOfInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IndustryOfInterestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IndustryOfInterestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndustryOfInterest.
     * @param {IndustryOfInterestUpsertArgs} args - Arguments to update or create a IndustryOfInterest.
     * @example
     * // Update or create a IndustryOfInterest
     * const industryOfInterest = await prisma.industryOfInterest.upsert({
     *   create: {
     *     // ... data to create a IndustryOfInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndustryOfInterest we want to update
     *   }
     * })
    **/
    upsert<T extends IndustryOfInterestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IndustryOfInterestUpsertArgs<ExtArgs>>
    ): Prisma__IndustryOfInterestClient<$Result.GetResult<Prisma.$IndustryOfInterestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IndustryOfInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryOfInterestCountArgs} args - Arguments to filter IndustryOfInterests to count.
     * @example
     * // Count the number of IndustryOfInterests
     * const count = await prisma.industryOfInterest.count({
     *   where: {
     *     // ... the filter for the IndustryOfInterests we want to count
     *   }
     * })
    **/
    count<T extends IndustryOfInterestCountArgs>(
      args?: Subset<T, IndustryOfInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndustryOfInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndustryOfInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryOfInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndustryOfInterestAggregateArgs>(args: Subset<T, IndustryOfInterestAggregateArgs>): Prisma.PrismaPromise<GetIndustryOfInterestAggregateType<T>>

    /**
     * Group by IndustryOfInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryOfInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndustryOfInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndustryOfInterestGroupByArgs['orderBy'] }
        : { orderBy?: IndustryOfInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndustryOfInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustryOfInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndustryOfInterest model
   */
  readonly fields: IndustryOfInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndustryOfInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndustryOfInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IndustryOfInterest model
   */ 
  interface IndustryOfInterestFieldRefs {
    readonly resumeOwnerEmail: FieldRef<"IndustryOfInterest", 'String'>
    readonly industryName: FieldRef<"IndustryOfInterest", 'String'>
    readonly isVisible: FieldRef<"IndustryOfInterest", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * IndustryOfInterest findUnique
   */
  export type IndustryOfInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which IndustryOfInterest to fetch.
     */
    where: IndustryOfInterestWhereUniqueInput
  }


  /**
   * IndustryOfInterest findUniqueOrThrow
   */
  export type IndustryOfInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which IndustryOfInterest to fetch.
     */
    where: IndustryOfInterestWhereUniqueInput
  }


  /**
   * IndustryOfInterest findFirst
   */
  export type IndustryOfInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which IndustryOfInterest to fetch.
     */
    where?: IndustryOfInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndustryOfInterests to fetch.
     */
    orderBy?: IndustryOfInterestOrderByWithRelationInput | IndustryOfInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndustryOfInterests.
     */
    cursor?: IndustryOfInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndustryOfInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndustryOfInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndustryOfInterests.
     */
    distinct?: IndustryOfInterestScalarFieldEnum | IndustryOfInterestScalarFieldEnum[]
  }


  /**
   * IndustryOfInterest findFirstOrThrow
   */
  export type IndustryOfInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which IndustryOfInterest to fetch.
     */
    where?: IndustryOfInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndustryOfInterests to fetch.
     */
    orderBy?: IndustryOfInterestOrderByWithRelationInput | IndustryOfInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndustryOfInterests.
     */
    cursor?: IndustryOfInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndustryOfInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndustryOfInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndustryOfInterests.
     */
    distinct?: IndustryOfInterestScalarFieldEnum | IndustryOfInterestScalarFieldEnum[]
  }


  /**
   * IndustryOfInterest findMany
   */
  export type IndustryOfInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * Filter, which IndustryOfInterests to fetch.
     */
    where?: IndustryOfInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndustryOfInterests to fetch.
     */
    orderBy?: IndustryOfInterestOrderByWithRelationInput | IndustryOfInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndustryOfInterests.
     */
    cursor?: IndustryOfInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndustryOfInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndustryOfInterests.
     */
    skip?: number
    distinct?: IndustryOfInterestScalarFieldEnum | IndustryOfInterestScalarFieldEnum[]
  }


  /**
   * IndustryOfInterest create
   */
  export type IndustryOfInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a IndustryOfInterest.
     */
    data: XOR<IndustryOfInterestCreateInput, IndustryOfInterestUncheckedCreateInput>
  }


  /**
   * IndustryOfInterest createMany
   */
  export type IndustryOfInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndustryOfInterests.
     */
    data: IndustryOfInterestCreateManyInput | IndustryOfInterestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IndustryOfInterest update
   */
  export type IndustryOfInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a IndustryOfInterest.
     */
    data: XOR<IndustryOfInterestUpdateInput, IndustryOfInterestUncheckedUpdateInput>
    /**
     * Choose, which IndustryOfInterest to update.
     */
    where: IndustryOfInterestWhereUniqueInput
  }


  /**
   * IndustryOfInterest updateMany
   */
  export type IndustryOfInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndustryOfInterests.
     */
    data: XOR<IndustryOfInterestUpdateManyMutationInput, IndustryOfInterestUncheckedUpdateManyInput>
    /**
     * Filter which IndustryOfInterests to update
     */
    where?: IndustryOfInterestWhereInput
  }


  /**
   * IndustryOfInterest upsert
   */
  export type IndustryOfInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the IndustryOfInterest to update in case it exists.
     */
    where: IndustryOfInterestWhereUniqueInput
    /**
     * In case the IndustryOfInterest found by the `where` argument doesn't exist, create a new IndustryOfInterest with this data.
     */
    create: XOR<IndustryOfInterestCreateInput, IndustryOfInterestUncheckedCreateInput>
    /**
     * In case the IndustryOfInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndustryOfInterestUpdateInput, IndustryOfInterestUncheckedUpdateInput>
  }


  /**
   * IndustryOfInterest delete
   */
  export type IndustryOfInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
    /**
     * Filter which IndustryOfInterest to delete.
     */
    where: IndustryOfInterestWhereUniqueInput
  }


  /**
   * IndustryOfInterest deleteMany
   */
  export type IndustryOfInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndustryOfInterests to delete
     */
    where?: IndustryOfInterestWhereInput
  }


  /**
   * IndustryOfInterest without action
   */
  export type IndustryOfInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryOfInterest
     */
    select?: IndustryOfInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IndustryOfInterestInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const JobOfferScalarFieldEnum: {
    id: 'id',
    description: 'description',
    companyName: 'companyName',
    companyContact: 'companyContact',
    companyLogo: 'companyLogo',
    department: 'department',
    position: 'position',
    offerLocation: 'offerLocation',
    offerTimestamp: 'offerTimestamp',
    isVisible: 'isVisible',
    visibleSince: 'visibleSince',
    careerName: 'careerName',
    contractTypeName: 'contractTypeName'
  };

  export type JobOfferScalarFieldEnum = (typeof JobOfferScalarFieldEnum)[keyof typeof JobOfferScalarFieldEnum]


  export const JobOfferTechnicalSkillScalarFieldEnum: {
    jobOfferId: 'jobOfferId',
    technicalSkillName: 'technicalSkillName',
    technicalSkillCategoryName: 'technicalSkillCategoryName'
  };

  export type JobOfferTechnicalSkillScalarFieldEnum = (typeof JobOfferTechnicalSkillScalarFieldEnum)[keyof typeof JobOfferTechnicalSkillScalarFieldEnum]


  export const ContractTypeScalarFieldEnum: {
    name: 'name'
  };

  export type ContractTypeScalarFieldEnum = (typeof ContractTypeScalarFieldEnum)[keyof typeof ContractTypeScalarFieldEnum]


  export const CareerScalarFieldEnum: {
    name: 'name'
  };

  export type CareerScalarFieldEnum = (typeof CareerScalarFieldEnum)[keyof typeof CareerScalarFieldEnum]


  export const UserScalarFieldEnum: {
    email: 'email',
    password: 'password',
    names: 'names',
    surnames: 'surnames',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AlumniScalarFieldEnum: {
    email: 'email',
    address: 'address',
    telephoneNumber: 'telephoneNumber'
  };

  export type AlumniScalarFieldEnum = (typeof AlumniScalarFieldEnum)[keyof typeof AlumniScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sid: 'sid',
    data: 'data',
    expiresAt: 'expiresAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const GraduationScalarFieldEnum: {
    careerName: 'careerName',
    alumniEmail: 'alumniEmail',
    graduationDate: 'graduationDate'
  };

  export type GraduationScalarFieldEnum = (typeof GraduationScalarFieldEnum)[keyof typeof GraduationScalarFieldEnum]


  export const JobApplicationScalarFieldEnum: {
    jobOfferId: 'jobOfferId',
    alumniWhoAppliedEmail: 'alumniWhoAppliedEmail',
    applicationTimestamp: 'applicationTimestamp'
  };

  export type JobApplicationScalarFieldEnum = (typeof JobApplicationScalarFieldEnum)[keyof typeof JobApplicationScalarFieldEnum]


  export const ResumeScalarFieldEnum: {
    ownerEmail: 'ownerEmail',
    numberOfDownloads: 'numberOfDownloads',
    isVisible: 'isVisible',
    visibleSince: 'visibleSince',
    aboutMe: 'aboutMe'
  };

  export type ResumeScalarFieldEnum = (typeof ResumeScalarFieldEnum)[keyof typeof ResumeScalarFieldEnum]


  export const CiapCourseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    date: 'date'
  };

  export type CiapCourseScalarFieldEnum = (typeof CiapCourseScalarFieldEnum)[keyof typeof CiapCourseScalarFieldEnum]


  export const ResumeCiapCourseScalarFieldEnum: {
    resumeOwnerEmail: 'resumeOwnerEmail',
    courseId: 'courseId',
    isVisible: 'isVisible'
  };

  export type ResumeCiapCourseScalarFieldEnum = (typeof ResumeCiapCourseScalarFieldEnum)[keyof typeof ResumeCiapCourseScalarFieldEnum]


  export const SoftSkillScalarFieldEnum: {
    name: 'name'
  };

  export type SoftSkillScalarFieldEnum = (typeof SoftSkillScalarFieldEnum)[keyof typeof SoftSkillScalarFieldEnum]


  export const ResumeSoftSkillScalarFieldEnum: {
    resumeOwnerEmail: 'resumeOwnerEmail',
    skillName: 'skillName',
    isVisible: 'isVisible'
  };

  export type ResumeSoftSkillScalarFieldEnum = (typeof ResumeSoftSkillScalarFieldEnum)[keyof typeof ResumeSoftSkillScalarFieldEnum]


  export const SkillCategoryScalarFieldEnum: {
    name: 'name'
  };

  export type SkillCategoryScalarFieldEnum = (typeof SkillCategoryScalarFieldEnum)[keyof typeof SkillCategoryScalarFieldEnum]


  export const TechnicalSkillScalarFieldEnum: {
    name: 'name',
    categoryName: 'categoryName'
  };

  export type TechnicalSkillScalarFieldEnum = (typeof TechnicalSkillScalarFieldEnum)[keyof typeof TechnicalSkillScalarFieldEnum]


  export const ResumeTechnicalSkillScalarFieldEnum: {
    resumeOwnerEmail: 'resumeOwnerEmail',
    skillName: 'skillName',
    skillCategoryName: 'skillCategoryName',
    isVisible: 'isVisible'
  };

  export type ResumeTechnicalSkillScalarFieldEnum = (typeof ResumeTechnicalSkillScalarFieldEnum)[keyof typeof ResumeTechnicalSkillScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    name: 'name'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const ResumeLanguageScalarFieldEnum: {
    resumeOwnerEmail: 'resumeOwnerEmail',
    languageName: 'languageName',
    masteryLevel: 'masteryLevel',
    isVisible: 'isVisible'
  };

  export type ResumeLanguageScalarFieldEnum = (typeof ResumeLanguageScalarFieldEnum)[keyof typeof ResumeLanguageScalarFieldEnum]


  export const PortfolioItemScalarFieldEnum: {
    resumeOwnerEmail: 'resumeOwnerEmail',
    title: 'title',
    sourceLink: 'sourceLink',
    isVisible: 'isVisible'
  };

  export type PortfolioItemScalarFieldEnum = (typeof PortfolioItemScalarFieldEnum)[keyof typeof PortfolioItemScalarFieldEnum]


  export const HigherEducationStudyScalarFieldEnum: {
    resumeOwnerEmail: 'resumeOwnerEmail',
    title: 'title',
    institution: 'institution',
    endDate: 'endDate',
    isVisible: 'isVisible'
  };

  export type HigherEducationStudyScalarFieldEnum = (typeof HigherEducationStudyScalarFieldEnum)[keyof typeof HigherEducationStudyScalarFieldEnum]


  export const PositionOfInterestScalarFieldEnum: {
    resumeOwnerEmail: 'resumeOwnerEmail',
    positionName: 'positionName',
    isVisible: 'isVisible'
  };

  export type PositionOfInterestScalarFieldEnum = (typeof PositionOfInterestScalarFieldEnum)[keyof typeof PositionOfInterestScalarFieldEnum]


  export const IndustryOfInterestScalarFieldEnum: {
    resumeOwnerEmail: 'resumeOwnerEmail',
    industryName: 'industryName',
    isVisible: 'isVisible'
  };

  export type IndustryOfInterestScalarFieldEnum = (typeof IndustryOfInterestScalarFieldEnum)[keyof typeof IndustryOfInterestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type JobOfferWhereInput = {
    AND?: JobOfferWhereInput | JobOfferWhereInput[]
    OR?: JobOfferWhereInput[]
    NOT?: JobOfferWhereInput | JobOfferWhereInput[]
    id?: UuidFilter<"JobOffer"> | string
    description?: StringFilter<"JobOffer"> | string
    companyName?: StringFilter<"JobOffer"> | string
    companyContact?: StringFilter<"JobOffer"> | string
    companyLogo?: StringFilter<"JobOffer"> | string
    department?: StringFilter<"JobOffer"> | string
    position?: StringFilter<"JobOffer"> | string
    offerLocation?: StringFilter<"JobOffer"> | string
    offerTimestamp?: DateTimeFilter<"JobOffer"> | Date | string
    isVisible?: BoolFilter<"JobOffer"> | boolean
    visibleSince?: DateTimeFilter<"JobOffer"> | Date | string
    careerName?: StringFilter<"JobOffer"> | string
    contractTypeName?: StringFilter<"JobOffer"> | string
    career?: XOR<CareerRelationFilter, CareerWhereInput>
    applications?: JobApplicationListRelationFilter
    contractType?: XOR<ContractTypeRelationFilter, ContractTypeWhereInput>
    technicalSkills?: JobOfferTechnicalSkillListRelationFilter
  }

  export type JobOfferOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    companyContact?: SortOrder
    companyLogo?: SortOrder
    department?: SortOrder
    position?: SortOrder
    offerLocation?: SortOrder
    offerTimestamp?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    careerName?: SortOrder
    contractTypeName?: SortOrder
    career?: CareerOrderByWithRelationInput
    applications?: JobApplicationOrderByRelationAggregateInput
    contractType?: ContractTypeOrderByWithRelationInput
    technicalSkills?: JobOfferTechnicalSkillOrderByRelationAggregateInput
  }

  export type JobOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobOfferWhereInput | JobOfferWhereInput[]
    OR?: JobOfferWhereInput[]
    NOT?: JobOfferWhereInput | JobOfferWhereInput[]
    description?: StringFilter<"JobOffer"> | string
    companyName?: StringFilter<"JobOffer"> | string
    companyContact?: StringFilter<"JobOffer"> | string
    companyLogo?: StringFilter<"JobOffer"> | string
    department?: StringFilter<"JobOffer"> | string
    position?: StringFilter<"JobOffer"> | string
    offerLocation?: StringFilter<"JobOffer"> | string
    offerTimestamp?: DateTimeFilter<"JobOffer"> | Date | string
    isVisible?: BoolFilter<"JobOffer"> | boolean
    visibleSince?: DateTimeFilter<"JobOffer"> | Date | string
    careerName?: StringFilter<"JobOffer"> | string
    contractTypeName?: StringFilter<"JobOffer"> | string
    career?: XOR<CareerRelationFilter, CareerWhereInput>
    applications?: JobApplicationListRelationFilter
    contractType?: XOR<ContractTypeRelationFilter, ContractTypeWhereInput>
    technicalSkills?: JobOfferTechnicalSkillListRelationFilter
  }, "id">

  export type JobOfferOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    companyContact?: SortOrder
    companyLogo?: SortOrder
    department?: SortOrder
    position?: SortOrder
    offerLocation?: SortOrder
    offerTimestamp?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    careerName?: SortOrder
    contractTypeName?: SortOrder
    _count?: JobOfferCountOrderByAggregateInput
    _max?: JobOfferMaxOrderByAggregateInput
    _min?: JobOfferMinOrderByAggregateInput
  }

  export type JobOfferScalarWhereWithAggregatesInput = {
    AND?: JobOfferScalarWhereWithAggregatesInput | JobOfferScalarWhereWithAggregatesInput[]
    OR?: JobOfferScalarWhereWithAggregatesInput[]
    NOT?: JobOfferScalarWhereWithAggregatesInput | JobOfferScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"JobOffer"> | string
    description?: StringWithAggregatesFilter<"JobOffer"> | string
    companyName?: StringWithAggregatesFilter<"JobOffer"> | string
    companyContact?: StringWithAggregatesFilter<"JobOffer"> | string
    companyLogo?: StringWithAggregatesFilter<"JobOffer"> | string
    department?: StringWithAggregatesFilter<"JobOffer"> | string
    position?: StringWithAggregatesFilter<"JobOffer"> | string
    offerLocation?: StringWithAggregatesFilter<"JobOffer"> | string
    offerTimestamp?: DateTimeWithAggregatesFilter<"JobOffer"> | Date | string
    isVisible?: BoolWithAggregatesFilter<"JobOffer"> | boolean
    visibleSince?: DateTimeWithAggregatesFilter<"JobOffer"> | Date | string
    careerName?: StringWithAggregatesFilter<"JobOffer"> | string
    contractTypeName?: StringWithAggregatesFilter<"JobOffer"> | string
  }

  export type JobOfferTechnicalSkillWhereInput = {
    AND?: JobOfferTechnicalSkillWhereInput | JobOfferTechnicalSkillWhereInput[]
    OR?: JobOfferTechnicalSkillWhereInput[]
    NOT?: JobOfferTechnicalSkillWhereInput | JobOfferTechnicalSkillWhereInput[]
    jobOfferId?: UuidFilter<"JobOfferTechnicalSkill"> | string
    technicalSkillName?: StringFilter<"JobOfferTechnicalSkill"> | string
    technicalSkillCategoryName?: StringFilter<"JobOfferTechnicalSkill"> | string
    jobOffer?: XOR<JobOfferRelationFilter, JobOfferWhereInput>
    technicalSkill?: XOR<TechnicalSkillRelationFilter, TechnicalSkillWhereInput>
  }

  export type JobOfferTechnicalSkillOrderByWithRelationInput = {
    jobOfferId?: SortOrder
    technicalSkillName?: SortOrder
    technicalSkillCategoryName?: SortOrder
    jobOffer?: JobOfferOrderByWithRelationInput
    technicalSkill?: TechnicalSkillOrderByWithRelationInput
  }

  export type JobOfferTechnicalSkillWhereUniqueInput = Prisma.AtLeast<{
    jobOfferId_technicalSkillName_technicalSkillCategoryName?: JobOfferTechnicalSkillJobOfferIdTechnicalSkillNameTechnicalSkillCategoryNameCompoundUniqueInput
    AND?: JobOfferTechnicalSkillWhereInput | JobOfferTechnicalSkillWhereInput[]
    OR?: JobOfferTechnicalSkillWhereInput[]
    NOT?: JobOfferTechnicalSkillWhereInput | JobOfferTechnicalSkillWhereInput[]
    jobOfferId?: UuidFilter<"JobOfferTechnicalSkill"> | string
    technicalSkillName?: StringFilter<"JobOfferTechnicalSkill"> | string
    technicalSkillCategoryName?: StringFilter<"JobOfferTechnicalSkill"> | string
    jobOffer?: XOR<JobOfferRelationFilter, JobOfferWhereInput>
    technicalSkill?: XOR<TechnicalSkillRelationFilter, TechnicalSkillWhereInput>
  }, "jobOfferId_technicalSkillName_technicalSkillCategoryName">

  export type JobOfferTechnicalSkillOrderByWithAggregationInput = {
    jobOfferId?: SortOrder
    technicalSkillName?: SortOrder
    technicalSkillCategoryName?: SortOrder
    _count?: JobOfferTechnicalSkillCountOrderByAggregateInput
    _max?: JobOfferTechnicalSkillMaxOrderByAggregateInput
    _min?: JobOfferTechnicalSkillMinOrderByAggregateInput
  }

  export type JobOfferTechnicalSkillScalarWhereWithAggregatesInput = {
    AND?: JobOfferTechnicalSkillScalarWhereWithAggregatesInput | JobOfferTechnicalSkillScalarWhereWithAggregatesInput[]
    OR?: JobOfferTechnicalSkillScalarWhereWithAggregatesInput[]
    NOT?: JobOfferTechnicalSkillScalarWhereWithAggregatesInput | JobOfferTechnicalSkillScalarWhereWithAggregatesInput[]
    jobOfferId?: UuidWithAggregatesFilter<"JobOfferTechnicalSkill"> | string
    technicalSkillName?: StringWithAggregatesFilter<"JobOfferTechnicalSkill"> | string
    technicalSkillCategoryName?: StringWithAggregatesFilter<"JobOfferTechnicalSkill"> | string
  }

  export type ContractTypeWhereInput = {
    AND?: ContractTypeWhereInput | ContractTypeWhereInput[]
    OR?: ContractTypeWhereInput[]
    NOT?: ContractTypeWhereInput | ContractTypeWhereInput[]
    name?: StringFilter<"ContractType"> | string
    contractsOfThisType?: JobOfferListRelationFilter
  }

  export type ContractTypeOrderByWithRelationInput = {
    name?: SortOrder
    contractsOfThisType?: JobOfferOrderByRelationAggregateInput
  }

  export type ContractTypeWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: ContractTypeWhereInput | ContractTypeWhereInput[]
    OR?: ContractTypeWhereInput[]
    NOT?: ContractTypeWhereInput | ContractTypeWhereInput[]
    contractsOfThisType?: JobOfferListRelationFilter
  }, "name">

  export type ContractTypeOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: ContractTypeCountOrderByAggregateInput
    _max?: ContractTypeMaxOrderByAggregateInput
    _min?: ContractTypeMinOrderByAggregateInput
  }

  export type ContractTypeScalarWhereWithAggregatesInput = {
    AND?: ContractTypeScalarWhereWithAggregatesInput | ContractTypeScalarWhereWithAggregatesInput[]
    OR?: ContractTypeScalarWhereWithAggregatesInput[]
    NOT?: ContractTypeScalarWhereWithAggregatesInput | ContractTypeScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"ContractType"> | string
  }

  export type CareerWhereInput = {
    AND?: CareerWhereInput | CareerWhereInput[]
    OR?: CareerWhereInput[]
    NOT?: CareerWhereInput | CareerWhereInput[]
    name?: StringFilter<"Career"> | string
    jobOffers?: JobOfferListRelationFilter
    graduations?: GraduationListRelationFilter
    skillCategories?: SkillCategoryListRelationFilter
  }

  export type CareerOrderByWithRelationInput = {
    name?: SortOrder
    jobOffers?: JobOfferOrderByRelationAggregateInput
    graduations?: GraduationOrderByRelationAggregateInput
    skillCategories?: SkillCategoryOrderByRelationAggregateInput
  }

  export type CareerWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: CareerWhereInput | CareerWhereInput[]
    OR?: CareerWhereInput[]
    NOT?: CareerWhereInput | CareerWhereInput[]
    jobOffers?: JobOfferListRelationFilter
    graduations?: GraduationListRelationFilter
    skillCategories?: SkillCategoryListRelationFilter
  }, "name">

  export type CareerOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: CareerCountOrderByAggregateInput
    _max?: CareerMaxOrderByAggregateInput
    _min?: CareerMinOrderByAggregateInput
  }

  export type CareerScalarWhereWithAggregatesInput = {
    AND?: CareerScalarWhereWithAggregatesInput | CareerScalarWhereWithAggregatesInput[]
    OR?: CareerScalarWhereWithAggregatesInput[]
    NOT?: CareerScalarWhereWithAggregatesInput | CareerScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Career"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    names?: StringFilter<"User"> | string
    surnames?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    associatedAlumni?: XOR<AlumniNullableRelationFilter, AlumniWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    email?: SortOrder
    password?: SortOrder
    names?: SortOrder
    surnames?: SortOrder
    role?: SortOrder
    associatedAlumni?: AlumniOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    names?: StringFilter<"User"> | string
    surnames?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    associatedAlumni?: XOR<AlumniNullableRelationFilter, AlumniWhereInput> | null
  }, "email">

  export type UserOrderByWithAggregationInput = {
    email?: SortOrder
    password?: SortOrder
    names?: SortOrder
    surnames?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    names?: StringWithAggregatesFilter<"User"> | string
    surnames?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
  }

  export type AlumniWhereInput = {
    AND?: AlumniWhereInput | AlumniWhereInput[]
    OR?: AlumniWhereInput[]
    NOT?: AlumniWhereInput | AlumniWhereInput[]
    email?: StringFilter<"Alumni"> | string
    address?: StringNullableFilter<"Alumni"> | string | null
    telephoneNumber?: StringNullableFilter<"Alumni"> | string | null
    associatedUser?: XOR<UserRelationFilter, UserWhereInput>
    jobApplications?: JobApplicationListRelationFilter
    resume?: XOR<ResumeNullableRelationFilter, ResumeWhereInput> | null
    graduations?: GraduationListRelationFilter
  }

  export type AlumniOrderByWithRelationInput = {
    email?: SortOrder
    address?: SortOrderInput | SortOrder
    telephoneNumber?: SortOrderInput | SortOrder
    associatedUser?: UserOrderByWithRelationInput
    jobApplications?: JobApplicationOrderByRelationAggregateInput
    resume?: ResumeOrderByWithRelationInput
    graduations?: GraduationOrderByRelationAggregateInput
  }

  export type AlumniWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: AlumniWhereInput | AlumniWhereInput[]
    OR?: AlumniWhereInput[]
    NOT?: AlumniWhereInput | AlumniWhereInput[]
    address?: StringNullableFilter<"Alumni"> | string | null
    telephoneNumber?: StringNullableFilter<"Alumni"> | string | null
    associatedUser?: XOR<UserRelationFilter, UserWhereInput>
    jobApplications?: JobApplicationListRelationFilter
    resume?: XOR<ResumeNullableRelationFilter, ResumeWhereInput> | null
    graduations?: GraduationListRelationFilter
  }, "email">

  export type AlumniOrderByWithAggregationInput = {
    email?: SortOrder
    address?: SortOrderInput | SortOrder
    telephoneNumber?: SortOrderInput | SortOrder
    _count?: AlumniCountOrderByAggregateInput
    _max?: AlumniMaxOrderByAggregateInput
    _min?: AlumniMinOrderByAggregateInput
  }

  export type AlumniScalarWhereWithAggregatesInput = {
    AND?: AlumniScalarWhereWithAggregatesInput | AlumniScalarWhereWithAggregatesInput[]
    OR?: AlumniScalarWhereWithAggregatesInput[]
    NOT?: AlumniScalarWhereWithAggregatesInput | AlumniScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"Alumni"> | string
    address?: StringNullableWithAggregatesFilter<"Alumni"> | string | null
    telephoneNumber?: StringNullableWithAggregatesFilter<"Alumni"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sid?: StringFilter<"Session"> | string
    data?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sid?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    data?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
  }, "id" | "sid">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sid?: StringWithAggregatesFilter<"Session"> | string
    data?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type GraduationWhereInput = {
    AND?: GraduationWhereInput | GraduationWhereInput[]
    OR?: GraduationWhereInput[]
    NOT?: GraduationWhereInput | GraduationWhereInput[]
    careerName?: StringFilter<"Graduation"> | string
    alumniEmail?: StringFilter<"Graduation"> | string
    graduationDate?: DateTimeFilter<"Graduation"> | Date | string
    career?: XOR<CareerRelationFilter, CareerWhereInput>
    alumni?: XOR<AlumniRelationFilter, AlumniWhereInput>
  }

  export type GraduationOrderByWithRelationInput = {
    careerName?: SortOrder
    alumniEmail?: SortOrder
    graduationDate?: SortOrder
    career?: CareerOrderByWithRelationInput
    alumni?: AlumniOrderByWithRelationInput
  }

  export type GraduationWhereUniqueInput = Prisma.AtLeast<{
    careerName_alumniEmail?: GraduationCareerNameAlumniEmailCompoundUniqueInput
    AND?: GraduationWhereInput | GraduationWhereInput[]
    OR?: GraduationWhereInput[]
    NOT?: GraduationWhereInput | GraduationWhereInput[]
    careerName?: StringFilter<"Graduation"> | string
    alumniEmail?: StringFilter<"Graduation"> | string
    graduationDate?: DateTimeFilter<"Graduation"> | Date | string
    career?: XOR<CareerRelationFilter, CareerWhereInput>
    alumni?: XOR<AlumniRelationFilter, AlumniWhereInput>
  }, "careerName_alumniEmail">

  export type GraduationOrderByWithAggregationInput = {
    careerName?: SortOrder
    alumniEmail?: SortOrder
    graduationDate?: SortOrder
    _count?: GraduationCountOrderByAggregateInput
    _max?: GraduationMaxOrderByAggregateInput
    _min?: GraduationMinOrderByAggregateInput
  }

  export type GraduationScalarWhereWithAggregatesInput = {
    AND?: GraduationScalarWhereWithAggregatesInput | GraduationScalarWhereWithAggregatesInput[]
    OR?: GraduationScalarWhereWithAggregatesInput[]
    NOT?: GraduationScalarWhereWithAggregatesInput | GraduationScalarWhereWithAggregatesInput[]
    careerName?: StringWithAggregatesFilter<"Graduation"> | string
    alumniEmail?: StringWithAggregatesFilter<"Graduation"> | string
    graduationDate?: DateTimeWithAggregatesFilter<"Graduation"> | Date | string
  }

  export type JobApplicationWhereInput = {
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    jobOfferId?: UuidFilter<"JobApplication"> | string
    alumniWhoAppliedEmail?: StringFilter<"JobApplication"> | string
    applicationTimestamp?: DateTimeFilter<"JobApplication"> | Date | string
    jobOffer?: XOR<JobOfferRelationFilter, JobOfferWhereInput>
    alumniWhoApplied?: XOR<AlumniRelationFilter, AlumniWhereInput>
  }

  export type JobApplicationOrderByWithRelationInput = {
    jobOfferId?: SortOrder
    alumniWhoAppliedEmail?: SortOrder
    applicationTimestamp?: SortOrder
    jobOffer?: JobOfferOrderByWithRelationInput
    alumniWhoApplied?: AlumniOrderByWithRelationInput
  }

  export type JobApplicationWhereUniqueInput = Prisma.AtLeast<{
    jobOfferId_alumniWhoAppliedEmail?: JobApplicationJobOfferIdAlumniWhoAppliedEmailCompoundUniqueInput
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    jobOfferId?: UuidFilter<"JobApplication"> | string
    alumniWhoAppliedEmail?: StringFilter<"JobApplication"> | string
    applicationTimestamp?: DateTimeFilter<"JobApplication"> | Date | string
    jobOffer?: XOR<JobOfferRelationFilter, JobOfferWhereInput>
    alumniWhoApplied?: XOR<AlumniRelationFilter, AlumniWhereInput>
  }, "jobOfferId_alumniWhoAppliedEmail">

  export type JobApplicationOrderByWithAggregationInput = {
    jobOfferId?: SortOrder
    alumniWhoAppliedEmail?: SortOrder
    applicationTimestamp?: SortOrder
    _count?: JobApplicationCountOrderByAggregateInput
    _max?: JobApplicationMaxOrderByAggregateInput
    _min?: JobApplicationMinOrderByAggregateInput
  }

  export type JobApplicationScalarWhereWithAggregatesInput = {
    AND?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    OR?: JobApplicationScalarWhereWithAggregatesInput[]
    NOT?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    jobOfferId?: UuidWithAggregatesFilter<"JobApplication"> | string
    alumniWhoAppliedEmail?: StringWithAggregatesFilter<"JobApplication"> | string
    applicationTimestamp?: DateTimeWithAggregatesFilter<"JobApplication"> | Date | string
  }

  export type ResumeWhereInput = {
    AND?: ResumeWhereInput | ResumeWhereInput[]
    OR?: ResumeWhereInput[]
    NOT?: ResumeWhereInput | ResumeWhereInput[]
    ownerEmail?: StringFilter<"Resume"> | string
    numberOfDownloads?: IntFilter<"Resume"> | number
    isVisible?: BoolFilter<"Resume"> | boolean
    visibleSince?: DateTimeFilter<"Resume"> | Date | string
    aboutMe?: StringNullableFilter<"Resume"> | string | null
    owner?: XOR<AlumniRelationFilter, AlumniWhereInput>
    knownLanguages?: ResumeLanguageListRelationFilter
    portfolio?: PortfolioItemListRelationFilter
    higherEducationStudies?: HigherEducationStudyListRelationFilter
    technicalSkills?: ResumeTechnicalSkillListRelationFilter
    softSkills?: ResumeSoftSkillListRelationFilter
    ciapCourses?: ResumeCiapCourseListRelationFilter
    positionsOfInterest?: PositionOfInterestListRelationFilter
    industriesOfInterest?: IndustryOfInterestListRelationFilter
  }

  export type ResumeOrderByWithRelationInput = {
    ownerEmail?: SortOrder
    numberOfDownloads?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    aboutMe?: SortOrderInput | SortOrder
    owner?: AlumniOrderByWithRelationInput
    knownLanguages?: ResumeLanguageOrderByRelationAggregateInput
    portfolio?: PortfolioItemOrderByRelationAggregateInput
    higherEducationStudies?: HigherEducationStudyOrderByRelationAggregateInput
    technicalSkills?: ResumeTechnicalSkillOrderByRelationAggregateInput
    softSkills?: ResumeSoftSkillOrderByRelationAggregateInput
    ciapCourses?: ResumeCiapCourseOrderByRelationAggregateInput
    positionsOfInterest?: PositionOfInterestOrderByRelationAggregateInput
    industriesOfInterest?: IndustryOfInterestOrderByRelationAggregateInput
  }

  export type ResumeWhereUniqueInput = Prisma.AtLeast<{
    ownerEmail?: string
    AND?: ResumeWhereInput | ResumeWhereInput[]
    OR?: ResumeWhereInput[]
    NOT?: ResumeWhereInput | ResumeWhereInput[]
    numberOfDownloads?: IntFilter<"Resume"> | number
    isVisible?: BoolFilter<"Resume"> | boolean
    visibleSince?: DateTimeFilter<"Resume"> | Date | string
    aboutMe?: StringNullableFilter<"Resume"> | string | null
    owner?: XOR<AlumniRelationFilter, AlumniWhereInput>
    knownLanguages?: ResumeLanguageListRelationFilter
    portfolio?: PortfolioItemListRelationFilter
    higherEducationStudies?: HigherEducationStudyListRelationFilter
    technicalSkills?: ResumeTechnicalSkillListRelationFilter
    softSkills?: ResumeSoftSkillListRelationFilter
    ciapCourses?: ResumeCiapCourseListRelationFilter
    positionsOfInterest?: PositionOfInterestListRelationFilter
    industriesOfInterest?: IndustryOfInterestListRelationFilter
  }, "ownerEmail">

  export type ResumeOrderByWithAggregationInput = {
    ownerEmail?: SortOrder
    numberOfDownloads?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    aboutMe?: SortOrderInput | SortOrder
    _count?: ResumeCountOrderByAggregateInput
    _avg?: ResumeAvgOrderByAggregateInput
    _max?: ResumeMaxOrderByAggregateInput
    _min?: ResumeMinOrderByAggregateInput
    _sum?: ResumeSumOrderByAggregateInput
  }

  export type ResumeScalarWhereWithAggregatesInput = {
    AND?: ResumeScalarWhereWithAggregatesInput | ResumeScalarWhereWithAggregatesInput[]
    OR?: ResumeScalarWhereWithAggregatesInput[]
    NOT?: ResumeScalarWhereWithAggregatesInput | ResumeScalarWhereWithAggregatesInput[]
    ownerEmail?: StringWithAggregatesFilter<"Resume"> | string
    numberOfDownloads?: IntWithAggregatesFilter<"Resume"> | number
    isVisible?: BoolWithAggregatesFilter<"Resume"> | boolean
    visibleSince?: DateTimeWithAggregatesFilter<"Resume"> | Date | string
    aboutMe?: StringNullableWithAggregatesFilter<"Resume"> | string | null
  }

  export type CiapCourseWhereInput = {
    AND?: CiapCourseWhereInput | CiapCourseWhereInput[]
    OR?: CiapCourseWhereInput[]
    NOT?: CiapCourseWhereInput | CiapCourseWhereInput[]
    id?: UuidFilter<"CiapCourse"> | string
    name?: StringFilter<"CiapCourse"> | string
    date?: DateTimeFilter<"CiapCourse"> | Date | string
    resumesListingThis?: ResumeCiapCourseListRelationFilter
  }

  export type CiapCourseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    resumesListingThis?: ResumeCiapCourseOrderByRelationAggregateInput
  }

  export type CiapCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_date?: CiapCourseNameDateCompoundUniqueInput
    AND?: CiapCourseWhereInput | CiapCourseWhereInput[]
    OR?: CiapCourseWhereInput[]
    NOT?: CiapCourseWhereInput | CiapCourseWhereInput[]
    name?: StringFilter<"CiapCourse"> | string
    date?: DateTimeFilter<"CiapCourse"> | Date | string
    resumesListingThis?: ResumeCiapCourseListRelationFilter
  }, "id" | "name_date">

  export type CiapCourseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    _count?: CiapCourseCountOrderByAggregateInput
    _max?: CiapCourseMaxOrderByAggregateInput
    _min?: CiapCourseMinOrderByAggregateInput
  }

  export type CiapCourseScalarWhereWithAggregatesInput = {
    AND?: CiapCourseScalarWhereWithAggregatesInput | CiapCourseScalarWhereWithAggregatesInput[]
    OR?: CiapCourseScalarWhereWithAggregatesInput[]
    NOT?: CiapCourseScalarWhereWithAggregatesInput | CiapCourseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CiapCourse"> | string
    name?: StringWithAggregatesFilter<"CiapCourse"> | string
    date?: DateTimeWithAggregatesFilter<"CiapCourse"> | Date | string
  }

  export type ResumeCiapCourseWhereInput = {
    AND?: ResumeCiapCourseWhereInput | ResumeCiapCourseWhereInput[]
    OR?: ResumeCiapCourseWhereInput[]
    NOT?: ResumeCiapCourseWhereInput | ResumeCiapCourseWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeCiapCourse"> | string
    courseId?: UuidFilter<"ResumeCiapCourse"> | string
    isVisible?: BoolFilter<"ResumeCiapCourse"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
    course?: XOR<CiapCourseRelationFilter, CiapCourseWhereInput>
  }

  export type ResumeCiapCourseOrderByWithRelationInput = {
    resumeOwnerEmail?: SortOrder
    courseId?: SortOrder
    isVisible?: SortOrder
    resume?: ResumeOrderByWithRelationInput
    course?: CiapCourseOrderByWithRelationInput
  }

  export type ResumeCiapCourseWhereUniqueInput = Prisma.AtLeast<{
    resumeOwnerEmail_courseId?: ResumeCiapCourseResumeOwnerEmailCourseIdCompoundUniqueInput
    AND?: ResumeCiapCourseWhereInput | ResumeCiapCourseWhereInput[]
    OR?: ResumeCiapCourseWhereInput[]
    NOT?: ResumeCiapCourseWhereInput | ResumeCiapCourseWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeCiapCourse"> | string
    courseId?: UuidFilter<"ResumeCiapCourse"> | string
    isVisible?: BoolFilter<"ResumeCiapCourse"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
    course?: XOR<CiapCourseRelationFilter, CiapCourseWhereInput>
  }, "resumeOwnerEmail_courseId">

  export type ResumeCiapCourseOrderByWithAggregationInput = {
    resumeOwnerEmail?: SortOrder
    courseId?: SortOrder
    isVisible?: SortOrder
    _count?: ResumeCiapCourseCountOrderByAggregateInput
    _max?: ResumeCiapCourseMaxOrderByAggregateInput
    _min?: ResumeCiapCourseMinOrderByAggregateInput
  }

  export type ResumeCiapCourseScalarWhereWithAggregatesInput = {
    AND?: ResumeCiapCourseScalarWhereWithAggregatesInput | ResumeCiapCourseScalarWhereWithAggregatesInput[]
    OR?: ResumeCiapCourseScalarWhereWithAggregatesInput[]
    NOT?: ResumeCiapCourseScalarWhereWithAggregatesInput | ResumeCiapCourseScalarWhereWithAggregatesInput[]
    resumeOwnerEmail?: StringWithAggregatesFilter<"ResumeCiapCourse"> | string
    courseId?: UuidWithAggregatesFilter<"ResumeCiapCourse"> | string
    isVisible?: BoolWithAggregatesFilter<"ResumeCiapCourse"> | boolean
  }

  export type SoftSkillWhereInput = {
    AND?: SoftSkillWhereInput | SoftSkillWhereInput[]
    OR?: SoftSkillWhereInput[]
    NOT?: SoftSkillWhereInput | SoftSkillWhereInput[]
    name?: StringFilter<"SoftSkill"> | string
    resumesListingThis?: ResumeSoftSkillListRelationFilter
  }

  export type SoftSkillOrderByWithRelationInput = {
    name?: SortOrder
    resumesListingThis?: ResumeSoftSkillOrderByRelationAggregateInput
  }

  export type SoftSkillWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: SoftSkillWhereInput | SoftSkillWhereInput[]
    OR?: SoftSkillWhereInput[]
    NOT?: SoftSkillWhereInput | SoftSkillWhereInput[]
    resumesListingThis?: ResumeSoftSkillListRelationFilter
  }, "name">

  export type SoftSkillOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: SoftSkillCountOrderByAggregateInput
    _max?: SoftSkillMaxOrderByAggregateInput
    _min?: SoftSkillMinOrderByAggregateInput
  }

  export type SoftSkillScalarWhereWithAggregatesInput = {
    AND?: SoftSkillScalarWhereWithAggregatesInput | SoftSkillScalarWhereWithAggregatesInput[]
    OR?: SoftSkillScalarWhereWithAggregatesInput[]
    NOT?: SoftSkillScalarWhereWithAggregatesInput | SoftSkillScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"SoftSkill"> | string
  }

  export type ResumeSoftSkillWhereInput = {
    AND?: ResumeSoftSkillWhereInput | ResumeSoftSkillWhereInput[]
    OR?: ResumeSoftSkillWhereInput[]
    NOT?: ResumeSoftSkillWhereInput | ResumeSoftSkillWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeSoftSkill"> | string
    skillName?: StringFilter<"ResumeSoftSkill"> | string
    isVisible?: BoolFilter<"ResumeSoftSkill"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
    skill?: XOR<SoftSkillRelationFilter, SoftSkillWhereInput>
  }

  export type ResumeSoftSkillOrderByWithRelationInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    isVisible?: SortOrder
    resume?: ResumeOrderByWithRelationInput
    skill?: SoftSkillOrderByWithRelationInput
  }

  export type ResumeSoftSkillWhereUniqueInput = Prisma.AtLeast<{
    resumeOwnerEmail_skillName?: ResumeSoftSkillResumeOwnerEmailSkillNameCompoundUniqueInput
    AND?: ResumeSoftSkillWhereInput | ResumeSoftSkillWhereInput[]
    OR?: ResumeSoftSkillWhereInput[]
    NOT?: ResumeSoftSkillWhereInput | ResumeSoftSkillWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeSoftSkill"> | string
    skillName?: StringFilter<"ResumeSoftSkill"> | string
    isVisible?: BoolFilter<"ResumeSoftSkill"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
    skill?: XOR<SoftSkillRelationFilter, SoftSkillWhereInput>
  }, "resumeOwnerEmail_skillName">

  export type ResumeSoftSkillOrderByWithAggregationInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    isVisible?: SortOrder
    _count?: ResumeSoftSkillCountOrderByAggregateInput
    _max?: ResumeSoftSkillMaxOrderByAggregateInput
    _min?: ResumeSoftSkillMinOrderByAggregateInput
  }

  export type ResumeSoftSkillScalarWhereWithAggregatesInput = {
    AND?: ResumeSoftSkillScalarWhereWithAggregatesInput | ResumeSoftSkillScalarWhereWithAggregatesInput[]
    OR?: ResumeSoftSkillScalarWhereWithAggregatesInput[]
    NOT?: ResumeSoftSkillScalarWhereWithAggregatesInput | ResumeSoftSkillScalarWhereWithAggregatesInput[]
    resumeOwnerEmail?: StringWithAggregatesFilter<"ResumeSoftSkill"> | string
    skillName?: StringWithAggregatesFilter<"ResumeSoftSkill"> | string
    isVisible?: BoolWithAggregatesFilter<"ResumeSoftSkill"> | boolean
  }

  export type SkillCategoryWhereInput = {
    AND?: SkillCategoryWhereInput | SkillCategoryWhereInput[]
    OR?: SkillCategoryWhereInput[]
    NOT?: SkillCategoryWhereInput | SkillCategoryWhereInput[]
    name?: StringFilter<"SkillCategory"> | string
    technicalSkills?: TechnicalSkillListRelationFilter
    relatedCareers?: CareerListRelationFilter
  }

  export type SkillCategoryOrderByWithRelationInput = {
    name?: SortOrder
    technicalSkills?: TechnicalSkillOrderByRelationAggregateInput
    relatedCareers?: CareerOrderByRelationAggregateInput
  }

  export type SkillCategoryWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: SkillCategoryWhereInput | SkillCategoryWhereInput[]
    OR?: SkillCategoryWhereInput[]
    NOT?: SkillCategoryWhereInput | SkillCategoryWhereInput[]
    technicalSkills?: TechnicalSkillListRelationFilter
    relatedCareers?: CareerListRelationFilter
  }, "name">

  export type SkillCategoryOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: SkillCategoryCountOrderByAggregateInput
    _max?: SkillCategoryMaxOrderByAggregateInput
    _min?: SkillCategoryMinOrderByAggregateInput
  }

  export type SkillCategoryScalarWhereWithAggregatesInput = {
    AND?: SkillCategoryScalarWhereWithAggregatesInput | SkillCategoryScalarWhereWithAggregatesInput[]
    OR?: SkillCategoryScalarWhereWithAggregatesInput[]
    NOT?: SkillCategoryScalarWhereWithAggregatesInput | SkillCategoryScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"SkillCategory"> | string
  }

  export type TechnicalSkillWhereInput = {
    AND?: TechnicalSkillWhereInput | TechnicalSkillWhereInput[]
    OR?: TechnicalSkillWhereInput[]
    NOT?: TechnicalSkillWhereInput | TechnicalSkillWhereInput[]
    name?: StringFilter<"TechnicalSkill"> | string
    categoryName?: StringFilter<"TechnicalSkill"> | string
    category?: XOR<SkillCategoryRelationFilter, SkillCategoryWhereInput>
    resumesListingThis?: ResumeTechnicalSkillListRelationFilter
    jobOffersListingThis?: JobOfferTechnicalSkillListRelationFilter
  }

  export type TechnicalSkillOrderByWithRelationInput = {
    name?: SortOrder
    categoryName?: SortOrder
    category?: SkillCategoryOrderByWithRelationInput
    resumesListingThis?: ResumeTechnicalSkillOrderByRelationAggregateInput
    jobOffersListingThis?: JobOfferTechnicalSkillOrderByRelationAggregateInput
  }

  export type TechnicalSkillWhereUniqueInput = Prisma.AtLeast<{
    name_categoryName?: TechnicalSkillNameCategoryNameCompoundUniqueInput
    AND?: TechnicalSkillWhereInput | TechnicalSkillWhereInput[]
    OR?: TechnicalSkillWhereInput[]
    NOT?: TechnicalSkillWhereInput | TechnicalSkillWhereInput[]
    name?: StringFilter<"TechnicalSkill"> | string
    categoryName?: StringFilter<"TechnicalSkill"> | string
    category?: XOR<SkillCategoryRelationFilter, SkillCategoryWhereInput>
    resumesListingThis?: ResumeTechnicalSkillListRelationFilter
    jobOffersListingThis?: JobOfferTechnicalSkillListRelationFilter
  }, "name_categoryName">

  export type TechnicalSkillOrderByWithAggregationInput = {
    name?: SortOrder
    categoryName?: SortOrder
    _count?: TechnicalSkillCountOrderByAggregateInput
    _max?: TechnicalSkillMaxOrderByAggregateInput
    _min?: TechnicalSkillMinOrderByAggregateInput
  }

  export type TechnicalSkillScalarWhereWithAggregatesInput = {
    AND?: TechnicalSkillScalarWhereWithAggregatesInput | TechnicalSkillScalarWhereWithAggregatesInput[]
    OR?: TechnicalSkillScalarWhereWithAggregatesInput[]
    NOT?: TechnicalSkillScalarWhereWithAggregatesInput | TechnicalSkillScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"TechnicalSkill"> | string
    categoryName?: StringWithAggregatesFilter<"TechnicalSkill"> | string
  }

  export type ResumeTechnicalSkillWhereInput = {
    AND?: ResumeTechnicalSkillWhereInput | ResumeTechnicalSkillWhereInput[]
    OR?: ResumeTechnicalSkillWhereInput[]
    NOT?: ResumeTechnicalSkillWhereInput | ResumeTechnicalSkillWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeTechnicalSkill"> | string
    skillName?: StringFilter<"ResumeTechnicalSkill"> | string
    skillCategoryName?: StringFilter<"ResumeTechnicalSkill"> | string
    isVisible?: BoolFilter<"ResumeTechnicalSkill"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
    skill?: XOR<TechnicalSkillRelationFilter, TechnicalSkillWhereInput>
  }

  export type ResumeTechnicalSkillOrderByWithRelationInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    skillCategoryName?: SortOrder
    isVisible?: SortOrder
    resume?: ResumeOrderByWithRelationInput
    skill?: TechnicalSkillOrderByWithRelationInput
  }

  export type ResumeTechnicalSkillWhereUniqueInput = Prisma.AtLeast<{
    resumeOwnerEmail_skillName_skillCategoryName?: ResumeTechnicalSkillResumeOwnerEmailSkillNameSkillCategoryNameCompoundUniqueInput
    AND?: ResumeTechnicalSkillWhereInput | ResumeTechnicalSkillWhereInput[]
    OR?: ResumeTechnicalSkillWhereInput[]
    NOT?: ResumeTechnicalSkillWhereInput | ResumeTechnicalSkillWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeTechnicalSkill"> | string
    skillName?: StringFilter<"ResumeTechnicalSkill"> | string
    skillCategoryName?: StringFilter<"ResumeTechnicalSkill"> | string
    isVisible?: BoolFilter<"ResumeTechnicalSkill"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
    skill?: XOR<TechnicalSkillRelationFilter, TechnicalSkillWhereInput>
  }, "resumeOwnerEmail_skillName_skillCategoryName">

  export type ResumeTechnicalSkillOrderByWithAggregationInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    skillCategoryName?: SortOrder
    isVisible?: SortOrder
    _count?: ResumeTechnicalSkillCountOrderByAggregateInput
    _max?: ResumeTechnicalSkillMaxOrderByAggregateInput
    _min?: ResumeTechnicalSkillMinOrderByAggregateInput
  }

  export type ResumeTechnicalSkillScalarWhereWithAggregatesInput = {
    AND?: ResumeTechnicalSkillScalarWhereWithAggregatesInput | ResumeTechnicalSkillScalarWhereWithAggregatesInput[]
    OR?: ResumeTechnicalSkillScalarWhereWithAggregatesInput[]
    NOT?: ResumeTechnicalSkillScalarWhereWithAggregatesInput | ResumeTechnicalSkillScalarWhereWithAggregatesInput[]
    resumeOwnerEmail?: StringWithAggregatesFilter<"ResumeTechnicalSkill"> | string
    skillName?: StringWithAggregatesFilter<"ResumeTechnicalSkill"> | string
    skillCategoryName?: StringWithAggregatesFilter<"ResumeTechnicalSkill"> | string
    isVisible?: BoolWithAggregatesFilter<"ResumeTechnicalSkill"> | boolean
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    name?: StringFilter<"Language"> | string
    knownBy?: ResumeLanguageListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    name?: SortOrder
    knownBy?: ResumeLanguageOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    knownBy?: ResumeLanguageListRelationFilter
  }, "name">

  export type LanguageOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Language"> | string
  }

  export type ResumeLanguageWhereInput = {
    AND?: ResumeLanguageWhereInput | ResumeLanguageWhereInput[]
    OR?: ResumeLanguageWhereInput[]
    NOT?: ResumeLanguageWhereInput | ResumeLanguageWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeLanguage"> | string
    languageName?: StringFilter<"ResumeLanguage"> | string
    masteryLevel?: IntFilter<"ResumeLanguage"> | number
    isVisible?: BoolFilter<"ResumeLanguage"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }

  export type ResumeLanguageOrderByWithRelationInput = {
    resumeOwnerEmail?: SortOrder
    languageName?: SortOrder
    masteryLevel?: SortOrder
    isVisible?: SortOrder
    resume?: ResumeOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
  }

  export type ResumeLanguageWhereUniqueInput = Prisma.AtLeast<{
    resumeOwnerEmail_languageName?: ResumeLanguageResumeOwnerEmailLanguageNameCompoundUniqueInput
    AND?: ResumeLanguageWhereInput | ResumeLanguageWhereInput[]
    OR?: ResumeLanguageWhereInput[]
    NOT?: ResumeLanguageWhereInput | ResumeLanguageWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeLanguage"> | string
    languageName?: StringFilter<"ResumeLanguage"> | string
    masteryLevel?: IntFilter<"ResumeLanguage"> | number
    isVisible?: BoolFilter<"ResumeLanguage"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }, "resumeOwnerEmail_languageName">

  export type ResumeLanguageOrderByWithAggregationInput = {
    resumeOwnerEmail?: SortOrder
    languageName?: SortOrder
    masteryLevel?: SortOrder
    isVisible?: SortOrder
    _count?: ResumeLanguageCountOrderByAggregateInput
    _avg?: ResumeLanguageAvgOrderByAggregateInput
    _max?: ResumeLanguageMaxOrderByAggregateInput
    _min?: ResumeLanguageMinOrderByAggregateInput
    _sum?: ResumeLanguageSumOrderByAggregateInput
  }

  export type ResumeLanguageScalarWhereWithAggregatesInput = {
    AND?: ResumeLanguageScalarWhereWithAggregatesInput | ResumeLanguageScalarWhereWithAggregatesInput[]
    OR?: ResumeLanguageScalarWhereWithAggregatesInput[]
    NOT?: ResumeLanguageScalarWhereWithAggregatesInput | ResumeLanguageScalarWhereWithAggregatesInput[]
    resumeOwnerEmail?: StringWithAggregatesFilter<"ResumeLanguage"> | string
    languageName?: StringWithAggregatesFilter<"ResumeLanguage"> | string
    masteryLevel?: IntWithAggregatesFilter<"ResumeLanguage"> | number
    isVisible?: BoolWithAggregatesFilter<"ResumeLanguage"> | boolean
  }

  export type PortfolioItemWhereInput = {
    AND?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    OR?: PortfolioItemWhereInput[]
    NOT?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    resumeOwnerEmail?: StringFilter<"PortfolioItem"> | string
    title?: StringFilter<"PortfolioItem"> | string
    sourceLink?: StringFilter<"PortfolioItem"> | string
    isVisible?: BoolFilter<"PortfolioItem"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
  }

  export type PortfolioItemOrderByWithRelationInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    sourceLink?: SortOrder
    isVisible?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type PortfolioItemWhereUniqueInput = Prisma.AtLeast<{
    resumeOwnerEmail_title?: PortfolioItemResumeOwnerEmailTitleCompoundUniqueInput
    AND?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    OR?: PortfolioItemWhereInput[]
    NOT?: PortfolioItemWhereInput | PortfolioItemWhereInput[]
    resumeOwnerEmail?: StringFilter<"PortfolioItem"> | string
    title?: StringFilter<"PortfolioItem"> | string
    sourceLink?: StringFilter<"PortfolioItem"> | string
    isVisible?: BoolFilter<"PortfolioItem"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
  }, "resumeOwnerEmail_title">

  export type PortfolioItemOrderByWithAggregationInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    sourceLink?: SortOrder
    isVisible?: SortOrder
    _count?: PortfolioItemCountOrderByAggregateInput
    _max?: PortfolioItemMaxOrderByAggregateInput
    _min?: PortfolioItemMinOrderByAggregateInput
  }

  export type PortfolioItemScalarWhereWithAggregatesInput = {
    AND?: PortfolioItemScalarWhereWithAggregatesInput | PortfolioItemScalarWhereWithAggregatesInput[]
    OR?: PortfolioItemScalarWhereWithAggregatesInput[]
    NOT?: PortfolioItemScalarWhereWithAggregatesInput | PortfolioItemScalarWhereWithAggregatesInput[]
    resumeOwnerEmail?: StringWithAggregatesFilter<"PortfolioItem"> | string
    title?: StringWithAggregatesFilter<"PortfolioItem"> | string
    sourceLink?: StringWithAggregatesFilter<"PortfolioItem"> | string
    isVisible?: BoolWithAggregatesFilter<"PortfolioItem"> | boolean
  }

  export type HigherEducationStudyWhereInput = {
    AND?: HigherEducationStudyWhereInput | HigherEducationStudyWhereInput[]
    OR?: HigherEducationStudyWhereInput[]
    NOT?: HigherEducationStudyWhereInput | HigherEducationStudyWhereInput[]
    resumeOwnerEmail?: StringFilter<"HigherEducationStudy"> | string
    title?: StringFilter<"HigherEducationStudy"> | string
    institution?: StringFilter<"HigherEducationStudy"> | string
    endDate?: DateTimeFilter<"HigherEducationStudy"> | Date | string
    isVisible?: BoolFilter<"HigherEducationStudy"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
  }

  export type HigherEducationStudyOrderByWithRelationInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    institution?: SortOrder
    endDate?: SortOrder
    isVisible?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type HigherEducationStudyWhereUniqueInput = Prisma.AtLeast<{
    resumeOwnerEmail_title?: HigherEducationStudyResumeOwnerEmailTitleCompoundUniqueInput
    AND?: HigherEducationStudyWhereInput | HigherEducationStudyWhereInput[]
    OR?: HigherEducationStudyWhereInput[]
    NOT?: HigherEducationStudyWhereInput | HigherEducationStudyWhereInput[]
    resumeOwnerEmail?: StringFilter<"HigherEducationStudy"> | string
    title?: StringFilter<"HigherEducationStudy"> | string
    institution?: StringFilter<"HigherEducationStudy"> | string
    endDate?: DateTimeFilter<"HigherEducationStudy"> | Date | string
    isVisible?: BoolFilter<"HigherEducationStudy"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
  }, "resumeOwnerEmail_title">

  export type HigherEducationStudyOrderByWithAggregationInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    institution?: SortOrder
    endDate?: SortOrder
    isVisible?: SortOrder
    _count?: HigherEducationStudyCountOrderByAggregateInput
    _max?: HigherEducationStudyMaxOrderByAggregateInput
    _min?: HigherEducationStudyMinOrderByAggregateInput
  }

  export type HigherEducationStudyScalarWhereWithAggregatesInput = {
    AND?: HigherEducationStudyScalarWhereWithAggregatesInput | HigherEducationStudyScalarWhereWithAggregatesInput[]
    OR?: HigherEducationStudyScalarWhereWithAggregatesInput[]
    NOT?: HigherEducationStudyScalarWhereWithAggregatesInput | HigherEducationStudyScalarWhereWithAggregatesInput[]
    resumeOwnerEmail?: StringWithAggregatesFilter<"HigherEducationStudy"> | string
    title?: StringWithAggregatesFilter<"HigherEducationStudy"> | string
    institution?: StringWithAggregatesFilter<"HigherEducationStudy"> | string
    endDate?: DateTimeWithAggregatesFilter<"HigherEducationStudy"> | Date | string
    isVisible?: BoolWithAggregatesFilter<"HigherEducationStudy"> | boolean
  }

  export type PositionOfInterestWhereInput = {
    AND?: PositionOfInterestWhereInput | PositionOfInterestWhereInput[]
    OR?: PositionOfInterestWhereInput[]
    NOT?: PositionOfInterestWhereInput | PositionOfInterestWhereInput[]
    resumeOwnerEmail?: StringFilter<"PositionOfInterest"> | string
    positionName?: StringFilter<"PositionOfInterest"> | string
    isVisible?: BoolFilter<"PositionOfInterest"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
  }

  export type PositionOfInterestOrderByWithRelationInput = {
    resumeOwnerEmail?: SortOrder
    positionName?: SortOrder
    isVisible?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type PositionOfInterestWhereUniqueInput = Prisma.AtLeast<{
    resumeOwnerEmail_positionName?: PositionOfInterestResumeOwnerEmailPositionNameCompoundUniqueInput
    AND?: PositionOfInterestWhereInput | PositionOfInterestWhereInput[]
    OR?: PositionOfInterestWhereInput[]
    NOT?: PositionOfInterestWhereInput | PositionOfInterestWhereInput[]
    resumeOwnerEmail?: StringFilter<"PositionOfInterest"> | string
    positionName?: StringFilter<"PositionOfInterest"> | string
    isVisible?: BoolFilter<"PositionOfInterest"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
  }, "resumeOwnerEmail_positionName">

  export type PositionOfInterestOrderByWithAggregationInput = {
    resumeOwnerEmail?: SortOrder
    positionName?: SortOrder
    isVisible?: SortOrder
    _count?: PositionOfInterestCountOrderByAggregateInput
    _max?: PositionOfInterestMaxOrderByAggregateInput
    _min?: PositionOfInterestMinOrderByAggregateInput
  }

  export type PositionOfInterestScalarWhereWithAggregatesInput = {
    AND?: PositionOfInterestScalarWhereWithAggregatesInput | PositionOfInterestScalarWhereWithAggregatesInput[]
    OR?: PositionOfInterestScalarWhereWithAggregatesInput[]
    NOT?: PositionOfInterestScalarWhereWithAggregatesInput | PositionOfInterestScalarWhereWithAggregatesInput[]
    resumeOwnerEmail?: StringWithAggregatesFilter<"PositionOfInterest"> | string
    positionName?: StringWithAggregatesFilter<"PositionOfInterest"> | string
    isVisible?: BoolWithAggregatesFilter<"PositionOfInterest"> | boolean
  }

  export type IndustryOfInterestWhereInput = {
    AND?: IndustryOfInterestWhereInput | IndustryOfInterestWhereInput[]
    OR?: IndustryOfInterestWhereInput[]
    NOT?: IndustryOfInterestWhereInput | IndustryOfInterestWhereInput[]
    resumeOwnerEmail?: StringFilter<"IndustryOfInterest"> | string
    industryName?: StringFilter<"IndustryOfInterest"> | string
    isVisible?: BoolFilter<"IndustryOfInterest"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
  }

  export type IndustryOfInterestOrderByWithRelationInput = {
    resumeOwnerEmail?: SortOrder
    industryName?: SortOrder
    isVisible?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type IndustryOfInterestWhereUniqueInput = Prisma.AtLeast<{
    resumeOwnerEmail_industryName?: IndustryOfInterestResumeOwnerEmailIndustryNameCompoundUniqueInput
    AND?: IndustryOfInterestWhereInput | IndustryOfInterestWhereInput[]
    OR?: IndustryOfInterestWhereInput[]
    NOT?: IndustryOfInterestWhereInput | IndustryOfInterestWhereInput[]
    resumeOwnerEmail?: StringFilter<"IndustryOfInterest"> | string
    industryName?: StringFilter<"IndustryOfInterest"> | string
    isVisible?: BoolFilter<"IndustryOfInterest"> | boolean
    resume?: XOR<ResumeRelationFilter, ResumeWhereInput>
  }, "resumeOwnerEmail_industryName">

  export type IndustryOfInterestOrderByWithAggregationInput = {
    resumeOwnerEmail?: SortOrder
    industryName?: SortOrder
    isVisible?: SortOrder
    _count?: IndustryOfInterestCountOrderByAggregateInput
    _max?: IndustryOfInterestMaxOrderByAggregateInput
    _min?: IndustryOfInterestMinOrderByAggregateInput
  }

  export type IndustryOfInterestScalarWhereWithAggregatesInput = {
    AND?: IndustryOfInterestScalarWhereWithAggregatesInput | IndustryOfInterestScalarWhereWithAggregatesInput[]
    OR?: IndustryOfInterestScalarWhereWithAggregatesInput[]
    NOT?: IndustryOfInterestScalarWhereWithAggregatesInput | IndustryOfInterestScalarWhereWithAggregatesInput[]
    resumeOwnerEmail?: StringWithAggregatesFilter<"IndustryOfInterest"> | string
    industryName?: StringWithAggregatesFilter<"IndustryOfInterest"> | string
    isVisible?: BoolWithAggregatesFilter<"IndustryOfInterest"> | boolean
  }

  export type JobOfferCreateInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    career: CareerCreateNestedOneWithoutJobOffersInput
    applications?: JobApplicationCreateNestedManyWithoutJobOfferInput
    contractType: ContractTypeCreateNestedOneWithoutContractsOfThisTypeInput
    technicalSkills?: JobOfferTechnicalSkillCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferUncheckedCreateInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    careerName: string
    contractTypeName: string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobOfferInput
    technicalSkills?: JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutJobOffersNestedInput
    applications?: JobApplicationUpdateManyWithoutJobOfferNestedInput
    contractType?: ContractTypeUpdateOneRequiredWithoutContractsOfThisTypeNestedInput
    technicalSkills?: JobOfferTechnicalSkillUpdateManyWithoutJobOfferNestedInput
  }

  export type JobOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    careerName?: StringFieldUpdateOperationsInput | string
    contractTypeName?: StringFieldUpdateOperationsInput | string
    applications?: JobApplicationUncheckedUpdateManyWithoutJobOfferNestedInput
    technicalSkills?: JobOfferTechnicalSkillUncheckedUpdateManyWithoutJobOfferNestedInput
  }

  export type JobOfferCreateManyInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    careerName: string
    contractTypeName: string
  }

  export type JobOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    careerName?: StringFieldUpdateOperationsInput | string
    contractTypeName?: StringFieldUpdateOperationsInput | string
  }

  export type JobOfferTechnicalSkillCreateInput = {
    jobOffer: JobOfferCreateNestedOneWithoutTechnicalSkillsInput
    technicalSkill: TechnicalSkillCreateNestedOneWithoutJobOffersListingThisInput
  }

  export type JobOfferTechnicalSkillUncheckedCreateInput = {
    jobOfferId: string
    technicalSkillName: string
    technicalSkillCategoryName: string
  }

  export type JobOfferTechnicalSkillUpdateInput = {
    jobOffer?: JobOfferUpdateOneRequiredWithoutTechnicalSkillsNestedInput
    technicalSkill?: TechnicalSkillUpdateOneRequiredWithoutJobOffersListingThisNestedInput
  }

  export type JobOfferTechnicalSkillUncheckedUpdateInput = {
    jobOfferId?: StringFieldUpdateOperationsInput | string
    technicalSkillName?: StringFieldUpdateOperationsInput | string
    technicalSkillCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type JobOfferTechnicalSkillCreateManyInput = {
    jobOfferId: string
    technicalSkillName: string
    technicalSkillCategoryName: string
  }

  export type JobOfferTechnicalSkillUpdateManyMutationInput = {

  }

  export type JobOfferTechnicalSkillUncheckedUpdateManyInput = {
    jobOfferId?: StringFieldUpdateOperationsInput | string
    technicalSkillName?: StringFieldUpdateOperationsInput | string
    technicalSkillCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type ContractTypeCreateInput = {
    name: string
    contractsOfThisType?: JobOfferCreateNestedManyWithoutContractTypeInput
  }

  export type ContractTypeUncheckedCreateInput = {
    name: string
    contractsOfThisType?: JobOfferUncheckedCreateNestedManyWithoutContractTypeInput
  }

  export type ContractTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contractsOfThisType?: JobOfferUpdateManyWithoutContractTypeNestedInput
  }

  export type ContractTypeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contractsOfThisType?: JobOfferUncheckedUpdateManyWithoutContractTypeNestedInput
  }

  export type ContractTypeCreateManyInput = {
    name: string
  }

  export type ContractTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ContractTypeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CareerCreateInput = {
    name: string
    jobOffers?: JobOfferCreateNestedManyWithoutCareerInput
    graduations?: GraduationCreateNestedManyWithoutCareerInput
    skillCategories?: SkillCategoryCreateNestedManyWithoutRelatedCareersInput
  }

  export type CareerUncheckedCreateInput = {
    name: string
    jobOffers?: JobOfferUncheckedCreateNestedManyWithoutCareerInput
    graduations?: GraduationUncheckedCreateNestedManyWithoutCareerInput
    skillCategories?: SkillCategoryUncheckedCreateNestedManyWithoutRelatedCareersInput
  }

  export type CareerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobOffers?: JobOfferUpdateManyWithoutCareerNestedInput
    graduations?: GraduationUpdateManyWithoutCareerNestedInput
    skillCategories?: SkillCategoryUpdateManyWithoutRelatedCareersNestedInput
  }

  export type CareerUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobOffers?: JobOfferUncheckedUpdateManyWithoutCareerNestedInput
    graduations?: GraduationUncheckedUpdateManyWithoutCareerNestedInput
    skillCategories?: SkillCategoryUncheckedUpdateManyWithoutRelatedCareersNestedInput
  }

  export type CareerCreateManyInput = {
    name: string
  }

  export type CareerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CareerUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    names: string
    surnames: string
    role: $Enums.Role
    associatedAlumni?: AlumniCreateNestedOneWithoutAssociatedUserInput
  }

  export type UserUncheckedCreateInput = {
    email: string
    password: string
    names: string
    surnames: string
    role: $Enums.Role
    associatedAlumni?: AlumniUncheckedCreateNestedOneWithoutAssociatedUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    names?: StringFieldUpdateOperationsInput | string
    surnames?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    associatedAlumni?: AlumniUpdateOneWithoutAssociatedUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    names?: StringFieldUpdateOperationsInput | string
    surnames?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    associatedAlumni?: AlumniUncheckedUpdateOneWithoutAssociatedUserNestedInput
  }

  export type UserCreateManyInput = {
    email: string
    password: string
    names: string
    surnames: string
    role: $Enums.Role
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    names?: StringFieldUpdateOperationsInput | string
    surnames?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    names?: StringFieldUpdateOperationsInput | string
    surnames?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AlumniCreateInput = {
    address?: string | null
    telephoneNumber?: string | null
    associatedUser: UserCreateNestedOneWithoutAssociatedAlumniInput
    jobApplications?: JobApplicationCreateNestedManyWithoutAlumniWhoAppliedInput
    resume?: ResumeCreateNestedOneWithoutOwnerInput
    graduations?: GraduationCreateNestedManyWithoutAlumniInput
  }

  export type AlumniUncheckedCreateInput = {
    email: string
    address?: string | null
    telephoneNumber?: string | null
    jobApplications?: JobApplicationUncheckedCreateNestedManyWithoutAlumniWhoAppliedInput
    resume?: ResumeUncheckedCreateNestedOneWithoutOwnerInput
    graduations?: GraduationUncheckedCreateNestedManyWithoutAlumniInput
  }

  export type AlumniUpdateInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    associatedUser?: UserUpdateOneRequiredWithoutAssociatedAlumniNestedInput
    jobApplications?: JobApplicationUpdateManyWithoutAlumniWhoAppliedNestedInput
    resume?: ResumeUpdateOneWithoutOwnerNestedInput
    graduations?: GraduationUpdateManyWithoutAlumniNestedInput
  }

  export type AlumniUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    jobApplications?: JobApplicationUncheckedUpdateManyWithoutAlumniWhoAppliedNestedInput
    resume?: ResumeUncheckedUpdateOneWithoutOwnerNestedInput
    graduations?: GraduationUncheckedUpdateManyWithoutAlumniNestedInput
  }

  export type AlumniCreateManyInput = {
    email: string
    address?: string | null
    telephoneNumber?: string | null
  }

  export type AlumniUpdateManyMutationInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlumniUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
  }

  export type SessionUncheckedCreateInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GraduationCreateInput = {
    graduationDate: Date | string
    career: CareerCreateNestedOneWithoutGraduationsInput
    alumni: AlumniCreateNestedOneWithoutGraduationsInput
  }

  export type GraduationUncheckedCreateInput = {
    careerName: string
    alumniEmail: string
    graduationDate: Date | string
  }

  export type GraduationUpdateInput = {
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutGraduationsNestedInput
    alumni?: AlumniUpdateOneRequiredWithoutGraduationsNestedInput
  }

  export type GraduationUncheckedUpdateInput = {
    careerName?: StringFieldUpdateOperationsInput | string
    alumniEmail?: StringFieldUpdateOperationsInput | string
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GraduationCreateManyInput = {
    careerName: string
    alumniEmail: string
    graduationDate: Date | string
  }

  export type GraduationUpdateManyMutationInput = {
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GraduationUncheckedUpdateManyInput = {
    careerName?: StringFieldUpdateOperationsInput | string
    alumniEmail?: StringFieldUpdateOperationsInput | string
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateInput = {
    applicationTimestamp: Date | string
    jobOffer: JobOfferCreateNestedOneWithoutApplicationsInput
    alumniWhoApplied: AlumniCreateNestedOneWithoutJobApplicationsInput
  }

  export type JobApplicationUncheckedCreateInput = {
    jobOfferId: string
    alumniWhoAppliedEmail: string
    applicationTimestamp: Date | string
  }

  export type JobApplicationUpdateInput = {
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOffer?: JobOfferUpdateOneRequiredWithoutApplicationsNestedInput
    alumniWhoApplied?: AlumniUpdateOneRequiredWithoutJobApplicationsNestedInput
  }

  export type JobApplicationUncheckedUpdateInput = {
    jobOfferId?: StringFieldUpdateOperationsInput | string
    alumniWhoAppliedEmail?: StringFieldUpdateOperationsInput | string
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateManyInput = {
    jobOfferId: string
    alumniWhoAppliedEmail: string
    applicationTimestamp: Date | string
  }

  export type JobApplicationUpdateManyMutationInput = {
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyInput = {
    jobOfferId?: StringFieldUpdateOperationsInput | string
    alumniWhoAppliedEmail?: StringFieldUpdateOperationsInput | string
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeCreateInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeUpdateInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateManyInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
  }

  export type ResumeUpdateManyMutationInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResumeUncheckedUpdateManyInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CiapCourseCreateInput = {
    id?: string
    name: string
    date: Date | string
    resumesListingThis?: ResumeCiapCourseCreateNestedManyWithoutCourseInput
  }

  export type CiapCourseUncheckedCreateInput = {
    id?: string
    name: string
    date: Date | string
    resumesListingThis?: ResumeCiapCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CiapCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesListingThis?: ResumeCiapCourseUpdateManyWithoutCourseNestedInput
  }

  export type CiapCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesListingThis?: ResumeCiapCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CiapCourseCreateManyInput = {
    id?: string
    name: string
    date: Date | string
  }

  export type CiapCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CiapCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeCiapCourseCreateInput = {
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutCiapCoursesInput
    course: CiapCourseCreateNestedOneWithoutResumesListingThisInput
  }

  export type ResumeCiapCourseUncheckedCreateInput = {
    resumeOwnerEmail: string
    courseId: string
    isVisible: boolean
  }

  export type ResumeCiapCourseUpdateInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutCiapCoursesNestedInput
    course?: CiapCourseUpdateOneRequiredWithoutResumesListingThisNestedInput
  }

  export type ResumeCiapCourseUncheckedUpdateInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeCiapCourseCreateManyInput = {
    resumeOwnerEmail: string
    courseId: string
    isVisible: boolean
  }

  export type ResumeCiapCourseUpdateManyMutationInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeCiapCourseUncheckedUpdateManyInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SoftSkillCreateInput = {
    name: string
    resumesListingThis?: ResumeSoftSkillCreateNestedManyWithoutSkillInput
  }

  export type SoftSkillUncheckedCreateInput = {
    name: string
    resumesListingThis?: ResumeSoftSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SoftSkillUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    resumesListingThis?: ResumeSoftSkillUpdateManyWithoutSkillNestedInput
  }

  export type SoftSkillUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    resumesListingThis?: ResumeSoftSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SoftSkillCreateManyInput = {
    name: string
  }

  export type SoftSkillUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SoftSkillUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeSoftSkillCreateInput = {
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutSoftSkillsInput
    skill: SoftSkillCreateNestedOneWithoutResumesListingThisInput
  }

  export type ResumeSoftSkillUncheckedCreateInput = {
    resumeOwnerEmail: string
    skillName: string
    isVisible: boolean
  }

  export type ResumeSoftSkillUpdateInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutSoftSkillsNestedInput
    skill?: SoftSkillUpdateOneRequiredWithoutResumesListingThisNestedInput
  }

  export type ResumeSoftSkillUncheckedUpdateInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeSoftSkillCreateManyInput = {
    resumeOwnerEmail: string
    skillName: string
    isVisible: boolean
  }

  export type ResumeSoftSkillUpdateManyMutationInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeSoftSkillUncheckedUpdateManyInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SkillCategoryCreateInput = {
    name: string
    technicalSkills?: TechnicalSkillCreateNestedManyWithoutCategoryInput
    relatedCareers?: CareerCreateNestedManyWithoutSkillCategoriesInput
  }

  export type SkillCategoryUncheckedCreateInput = {
    name: string
    technicalSkills?: TechnicalSkillUncheckedCreateNestedManyWithoutCategoryInput
    relatedCareers?: CareerUncheckedCreateNestedManyWithoutSkillCategoriesInput
  }

  export type SkillCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    technicalSkills?: TechnicalSkillUpdateManyWithoutCategoryNestedInput
    relatedCareers?: CareerUpdateManyWithoutSkillCategoriesNestedInput
  }

  export type SkillCategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    technicalSkills?: TechnicalSkillUncheckedUpdateManyWithoutCategoryNestedInput
    relatedCareers?: CareerUncheckedUpdateManyWithoutSkillCategoriesNestedInput
  }

  export type SkillCategoryCreateManyInput = {
    name: string
  }

  export type SkillCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SkillCategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicalSkillCreateInput = {
    name: string
    category: SkillCategoryCreateNestedOneWithoutTechnicalSkillsInput
    resumesListingThis?: ResumeTechnicalSkillCreateNestedManyWithoutSkillInput
    jobOffersListingThis?: JobOfferTechnicalSkillCreateNestedManyWithoutTechnicalSkillInput
  }

  export type TechnicalSkillUncheckedCreateInput = {
    name: string
    categoryName: string
    resumesListingThis?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutSkillInput
    jobOffersListingThis?: JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutTechnicalSkillInput
  }

  export type TechnicalSkillUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: SkillCategoryUpdateOneRequiredWithoutTechnicalSkillsNestedInput
    resumesListingThis?: ResumeTechnicalSkillUpdateManyWithoutSkillNestedInput
    jobOffersListingThis?: JobOfferTechnicalSkillUpdateManyWithoutTechnicalSkillNestedInput
  }

  export type TechnicalSkillUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    resumesListingThis?: ResumeTechnicalSkillUncheckedUpdateManyWithoutSkillNestedInput
    jobOffersListingThis?: JobOfferTechnicalSkillUncheckedUpdateManyWithoutTechnicalSkillNestedInput
  }

  export type TechnicalSkillCreateManyInput = {
    name: string
    categoryName: string
  }

  export type TechnicalSkillUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicalSkillUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeTechnicalSkillCreateInput = {
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutTechnicalSkillsInput
    skill: TechnicalSkillCreateNestedOneWithoutResumesListingThisInput
  }

  export type ResumeTechnicalSkillUncheckedCreateInput = {
    resumeOwnerEmail: string
    skillName: string
    skillCategoryName: string
    isVisible: boolean
  }

  export type ResumeTechnicalSkillUpdateInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutTechnicalSkillsNestedInput
    skill?: TechnicalSkillUpdateOneRequiredWithoutResumesListingThisNestedInput
  }

  export type ResumeTechnicalSkillUncheckedUpdateInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    skillCategoryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeTechnicalSkillCreateManyInput = {
    resumeOwnerEmail: string
    skillName: string
    skillCategoryName: string
    isVisible: boolean
  }

  export type ResumeTechnicalSkillUpdateManyMutationInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeTechnicalSkillUncheckedUpdateManyInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    skillCategoryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LanguageCreateInput = {
    name: string
    knownBy?: ResumeLanguageCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    name: string
    knownBy?: ResumeLanguageUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    knownBy?: ResumeLanguageUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    knownBy?: ResumeLanguageUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    name: string
  }

  export type LanguageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeLanguageCreateInput = {
    masteryLevel: number
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutKnownLanguagesInput
    language: LanguageCreateNestedOneWithoutKnownByInput
  }

  export type ResumeLanguageUncheckedCreateInput = {
    resumeOwnerEmail: string
    languageName: string
    masteryLevel: number
    isVisible: boolean
  }

  export type ResumeLanguageUpdateInput = {
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutKnownLanguagesNestedInput
    language?: LanguageUpdateOneRequiredWithoutKnownByNestedInput
  }

  export type ResumeLanguageUncheckedUpdateInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    languageName?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeLanguageCreateManyInput = {
    resumeOwnerEmail: string
    languageName: string
    masteryLevel: number
    isVisible: boolean
  }

  export type ResumeLanguageUpdateManyMutationInput = {
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeLanguageUncheckedUpdateManyInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    languageName?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PortfolioItemCreateInput = {
    title: string
    sourceLink: string
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutPortfolioInput
  }

  export type PortfolioItemUncheckedCreateInput = {
    resumeOwnerEmail: string
    title: string
    sourceLink: string
    isVisible: boolean
  }

  export type PortfolioItemUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    sourceLink?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutPortfolioNestedInput
  }

  export type PortfolioItemUncheckedUpdateInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceLink?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PortfolioItemCreateManyInput = {
    resumeOwnerEmail: string
    title: string
    sourceLink: string
    isVisible: boolean
  }

  export type PortfolioItemUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    sourceLink?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PortfolioItemUncheckedUpdateManyInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceLink?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HigherEducationStudyCreateInput = {
    title: string
    institution: string
    endDate: Date | string
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutHigherEducationStudiesInput
  }

  export type HigherEducationStudyUncheckedCreateInput = {
    resumeOwnerEmail: string
    title: string
    institution: string
    endDate: Date | string
    isVisible: boolean
  }

  export type HigherEducationStudyUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutHigherEducationStudiesNestedInput
  }

  export type HigherEducationStudyUncheckedUpdateInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HigherEducationStudyCreateManyInput = {
    resumeOwnerEmail: string
    title: string
    institution: string
    endDate: Date | string
    isVisible: boolean
  }

  export type HigherEducationStudyUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HigherEducationStudyUncheckedUpdateManyInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PositionOfInterestCreateInput = {
    positionName: string
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutPositionsOfInterestInput
  }

  export type PositionOfInterestUncheckedCreateInput = {
    resumeOwnerEmail: string
    positionName: string
    isVisible: boolean
  }

  export type PositionOfInterestUpdateInput = {
    positionName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutPositionsOfInterestNestedInput
  }

  export type PositionOfInterestUncheckedUpdateInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    positionName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PositionOfInterestCreateManyInput = {
    resumeOwnerEmail: string
    positionName: string
    isVisible: boolean
  }

  export type PositionOfInterestUpdateManyMutationInput = {
    positionName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PositionOfInterestUncheckedUpdateManyInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    positionName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IndustryOfInterestCreateInput = {
    industryName: string
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutIndustriesOfInterestInput
  }

  export type IndustryOfInterestUncheckedCreateInput = {
    resumeOwnerEmail: string
    industryName: string
    isVisible: boolean
  }

  export type IndustryOfInterestUpdateInput = {
    industryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutIndustriesOfInterestNestedInput
  }

  export type IndustryOfInterestUncheckedUpdateInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    industryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IndustryOfInterestCreateManyInput = {
    resumeOwnerEmail: string
    industryName: string
    isVisible: boolean
  }

  export type IndustryOfInterestUpdateManyMutationInput = {
    industryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IndustryOfInterestUncheckedUpdateManyInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    industryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CareerRelationFilter = {
    is?: CareerWhereInput
    isNot?: CareerWhereInput
  }

  export type JobApplicationListRelationFilter = {
    every?: JobApplicationWhereInput
    some?: JobApplicationWhereInput
    none?: JobApplicationWhereInput
  }

  export type ContractTypeRelationFilter = {
    is?: ContractTypeWhereInput
    isNot?: ContractTypeWhereInput
  }

  export type JobOfferTechnicalSkillListRelationFilter = {
    every?: JobOfferTechnicalSkillWhereInput
    some?: JobOfferTechnicalSkillWhereInput
    none?: JobOfferTechnicalSkillWhereInput
  }

  export type JobApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOfferTechnicalSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOfferCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    companyContact?: SortOrder
    companyLogo?: SortOrder
    department?: SortOrder
    position?: SortOrder
    offerLocation?: SortOrder
    offerTimestamp?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    careerName?: SortOrder
    contractTypeName?: SortOrder
  }

  export type JobOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    companyContact?: SortOrder
    companyLogo?: SortOrder
    department?: SortOrder
    position?: SortOrder
    offerLocation?: SortOrder
    offerTimestamp?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    careerName?: SortOrder
    contractTypeName?: SortOrder
  }

  export type JobOfferMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    companyContact?: SortOrder
    companyLogo?: SortOrder
    department?: SortOrder
    position?: SortOrder
    offerLocation?: SortOrder
    offerTimestamp?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    careerName?: SortOrder
    contractTypeName?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type JobOfferRelationFilter = {
    is?: JobOfferWhereInput
    isNot?: JobOfferWhereInput
  }

  export type TechnicalSkillRelationFilter = {
    is?: TechnicalSkillWhereInput
    isNot?: TechnicalSkillWhereInput
  }

  export type JobOfferTechnicalSkillJobOfferIdTechnicalSkillNameTechnicalSkillCategoryNameCompoundUniqueInput = {
    jobOfferId: string
    technicalSkillName: string
    technicalSkillCategoryName: string
  }

  export type JobOfferTechnicalSkillCountOrderByAggregateInput = {
    jobOfferId?: SortOrder
    technicalSkillName?: SortOrder
    technicalSkillCategoryName?: SortOrder
  }

  export type JobOfferTechnicalSkillMaxOrderByAggregateInput = {
    jobOfferId?: SortOrder
    technicalSkillName?: SortOrder
    technicalSkillCategoryName?: SortOrder
  }

  export type JobOfferTechnicalSkillMinOrderByAggregateInput = {
    jobOfferId?: SortOrder
    technicalSkillName?: SortOrder
    technicalSkillCategoryName?: SortOrder
  }

  export type JobOfferListRelationFilter = {
    every?: JobOfferWhereInput
    some?: JobOfferWhereInput
    none?: JobOfferWhereInput
  }

  export type JobOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractTypeCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type ContractTypeMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type ContractTypeMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type GraduationListRelationFilter = {
    every?: GraduationWhereInput
    some?: GraduationWhereInput
    none?: GraduationWhereInput
  }

  export type SkillCategoryListRelationFilter = {
    every?: SkillCategoryWhereInput
    some?: SkillCategoryWhereInput
    none?: SkillCategoryWhereInput
  }

  export type GraduationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CareerCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type CareerMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type CareerMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type AlumniNullableRelationFilter = {
    is?: AlumniWhereInput | null
    isNot?: AlumniWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    names?: SortOrder
    surnames?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    names?: SortOrder
    surnames?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    names?: SortOrder
    surnames?: SortOrder
    role?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ResumeNullableRelationFilter = {
    is?: ResumeWhereInput | null
    isNot?: ResumeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AlumniCountOrderByAggregateInput = {
    email?: SortOrder
    address?: SortOrder
    telephoneNumber?: SortOrder
  }

  export type AlumniMaxOrderByAggregateInput = {
    email?: SortOrder
    address?: SortOrder
    telephoneNumber?: SortOrder
  }

  export type AlumniMinOrderByAggregateInput = {
    email?: SortOrder
    address?: SortOrder
    telephoneNumber?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
  }

  export type AlumniRelationFilter = {
    is?: AlumniWhereInput
    isNot?: AlumniWhereInput
  }

  export type GraduationCareerNameAlumniEmailCompoundUniqueInput = {
    careerName: string
    alumniEmail: string
  }

  export type GraduationCountOrderByAggregateInput = {
    careerName?: SortOrder
    alumniEmail?: SortOrder
    graduationDate?: SortOrder
  }

  export type GraduationMaxOrderByAggregateInput = {
    careerName?: SortOrder
    alumniEmail?: SortOrder
    graduationDate?: SortOrder
  }

  export type GraduationMinOrderByAggregateInput = {
    careerName?: SortOrder
    alumniEmail?: SortOrder
    graduationDate?: SortOrder
  }

  export type JobApplicationJobOfferIdAlumniWhoAppliedEmailCompoundUniqueInput = {
    jobOfferId: string
    alumniWhoAppliedEmail: string
  }

  export type JobApplicationCountOrderByAggregateInput = {
    jobOfferId?: SortOrder
    alumniWhoAppliedEmail?: SortOrder
    applicationTimestamp?: SortOrder
  }

  export type JobApplicationMaxOrderByAggregateInput = {
    jobOfferId?: SortOrder
    alumniWhoAppliedEmail?: SortOrder
    applicationTimestamp?: SortOrder
  }

  export type JobApplicationMinOrderByAggregateInput = {
    jobOfferId?: SortOrder
    alumniWhoAppliedEmail?: SortOrder
    applicationTimestamp?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ResumeLanguageListRelationFilter = {
    every?: ResumeLanguageWhereInput
    some?: ResumeLanguageWhereInput
    none?: ResumeLanguageWhereInput
  }

  export type PortfolioItemListRelationFilter = {
    every?: PortfolioItemWhereInput
    some?: PortfolioItemWhereInput
    none?: PortfolioItemWhereInput
  }

  export type HigherEducationStudyListRelationFilter = {
    every?: HigherEducationStudyWhereInput
    some?: HigherEducationStudyWhereInput
    none?: HigherEducationStudyWhereInput
  }

  export type ResumeTechnicalSkillListRelationFilter = {
    every?: ResumeTechnicalSkillWhereInput
    some?: ResumeTechnicalSkillWhereInput
    none?: ResumeTechnicalSkillWhereInput
  }

  export type ResumeSoftSkillListRelationFilter = {
    every?: ResumeSoftSkillWhereInput
    some?: ResumeSoftSkillWhereInput
    none?: ResumeSoftSkillWhereInput
  }

  export type ResumeCiapCourseListRelationFilter = {
    every?: ResumeCiapCourseWhereInput
    some?: ResumeCiapCourseWhereInput
    none?: ResumeCiapCourseWhereInput
  }

  export type PositionOfInterestListRelationFilter = {
    every?: PositionOfInterestWhereInput
    some?: PositionOfInterestWhereInput
    none?: PositionOfInterestWhereInput
  }

  export type IndustryOfInterestListRelationFilter = {
    every?: IndustryOfInterestWhereInput
    some?: IndustryOfInterestWhereInput
    none?: IndustryOfInterestWhereInput
  }

  export type ResumeLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HigherEducationStudyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeTechnicalSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeSoftSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeCiapCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionOfInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndustryOfInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeCountOrderByAggregateInput = {
    ownerEmail?: SortOrder
    numberOfDownloads?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    aboutMe?: SortOrder
  }

  export type ResumeAvgOrderByAggregateInput = {
    numberOfDownloads?: SortOrder
  }

  export type ResumeMaxOrderByAggregateInput = {
    ownerEmail?: SortOrder
    numberOfDownloads?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    aboutMe?: SortOrder
  }

  export type ResumeMinOrderByAggregateInput = {
    ownerEmail?: SortOrder
    numberOfDownloads?: SortOrder
    isVisible?: SortOrder
    visibleSince?: SortOrder
    aboutMe?: SortOrder
  }

  export type ResumeSumOrderByAggregateInput = {
    numberOfDownloads?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CiapCourseNameDateCompoundUniqueInput = {
    name: string
    date: Date | string
  }

  export type CiapCourseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
  }

  export type CiapCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
  }

  export type CiapCourseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
  }

  export type ResumeRelationFilter = {
    is?: ResumeWhereInput
    isNot?: ResumeWhereInput
  }

  export type CiapCourseRelationFilter = {
    is?: CiapCourseWhereInput
    isNot?: CiapCourseWhereInput
  }

  export type ResumeCiapCourseResumeOwnerEmailCourseIdCompoundUniqueInput = {
    resumeOwnerEmail: string
    courseId: string
  }

  export type ResumeCiapCourseCountOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    courseId?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeCiapCourseMaxOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    courseId?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeCiapCourseMinOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    courseId?: SortOrder
    isVisible?: SortOrder
  }

  export type SoftSkillCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SoftSkillMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SoftSkillMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SoftSkillRelationFilter = {
    is?: SoftSkillWhereInput
    isNot?: SoftSkillWhereInput
  }

  export type ResumeSoftSkillResumeOwnerEmailSkillNameCompoundUniqueInput = {
    resumeOwnerEmail: string
    skillName: string
  }

  export type ResumeSoftSkillCountOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeSoftSkillMaxOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeSoftSkillMinOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    isVisible?: SortOrder
  }

  export type TechnicalSkillListRelationFilter = {
    every?: TechnicalSkillWhereInput
    some?: TechnicalSkillWhereInput
    none?: TechnicalSkillWhereInput
  }

  export type CareerListRelationFilter = {
    every?: CareerWhereInput
    some?: CareerWhereInput
    none?: CareerWhereInput
  }

  export type TechnicalSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CareerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillCategoryCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SkillCategoryMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SkillCategoryMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SkillCategoryRelationFilter = {
    is?: SkillCategoryWhereInput
    isNot?: SkillCategoryWhereInput
  }

  export type TechnicalSkillNameCategoryNameCompoundUniqueInput = {
    name: string
    categoryName: string
  }

  export type TechnicalSkillCountOrderByAggregateInput = {
    name?: SortOrder
    categoryName?: SortOrder
  }

  export type TechnicalSkillMaxOrderByAggregateInput = {
    name?: SortOrder
    categoryName?: SortOrder
  }

  export type TechnicalSkillMinOrderByAggregateInput = {
    name?: SortOrder
    categoryName?: SortOrder
  }

  export type ResumeTechnicalSkillResumeOwnerEmailSkillNameSkillCategoryNameCompoundUniqueInput = {
    resumeOwnerEmail: string
    skillName: string
    skillCategoryName: string
  }

  export type ResumeTechnicalSkillCountOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    skillCategoryName?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeTechnicalSkillMaxOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    skillCategoryName?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeTechnicalSkillMinOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    skillName?: SortOrder
    skillCategoryName?: SortOrder
    isVisible?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type LanguageRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type ResumeLanguageResumeOwnerEmailLanguageNameCompoundUniqueInput = {
    resumeOwnerEmail: string
    languageName: string
  }

  export type ResumeLanguageCountOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    languageName?: SortOrder
    masteryLevel?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeLanguageAvgOrderByAggregateInput = {
    masteryLevel?: SortOrder
  }

  export type ResumeLanguageMaxOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    languageName?: SortOrder
    masteryLevel?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeLanguageMinOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    languageName?: SortOrder
    masteryLevel?: SortOrder
    isVisible?: SortOrder
  }

  export type ResumeLanguageSumOrderByAggregateInput = {
    masteryLevel?: SortOrder
  }

  export type PortfolioItemResumeOwnerEmailTitleCompoundUniqueInput = {
    resumeOwnerEmail: string
    title: string
  }

  export type PortfolioItemCountOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    sourceLink?: SortOrder
    isVisible?: SortOrder
  }

  export type PortfolioItemMaxOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    sourceLink?: SortOrder
    isVisible?: SortOrder
  }

  export type PortfolioItemMinOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    sourceLink?: SortOrder
    isVisible?: SortOrder
  }

  export type HigherEducationStudyResumeOwnerEmailTitleCompoundUniqueInput = {
    resumeOwnerEmail: string
    title: string
  }

  export type HigherEducationStudyCountOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    institution?: SortOrder
    endDate?: SortOrder
    isVisible?: SortOrder
  }

  export type HigherEducationStudyMaxOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    institution?: SortOrder
    endDate?: SortOrder
    isVisible?: SortOrder
  }

  export type HigherEducationStudyMinOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    title?: SortOrder
    institution?: SortOrder
    endDate?: SortOrder
    isVisible?: SortOrder
  }

  export type PositionOfInterestResumeOwnerEmailPositionNameCompoundUniqueInput = {
    resumeOwnerEmail: string
    positionName: string
  }

  export type PositionOfInterestCountOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    positionName?: SortOrder
    isVisible?: SortOrder
  }

  export type PositionOfInterestMaxOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    positionName?: SortOrder
    isVisible?: SortOrder
  }

  export type PositionOfInterestMinOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    positionName?: SortOrder
    isVisible?: SortOrder
  }

  export type IndustryOfInterestResumeOwnerEmailIndustryNameCompoundUniqueInput = {
    resumeOwnerEmail: string
    industryName: string
  }

  export type IndustryOfInterestCountOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    industryName?: SortOrder
    isVisible?: SortOrder
  }

  export type IndustryOfInterestMaxOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    industryName?: SortOrder
    isVisible?: SortOrder
  }

  export type IndustryOfInterestMinOrderByAggregateInput = {
    resumeOwnerEmail?: SortOrder
    industryName?: SortOrder
    isVisible?: SortOrder
  }

  export type CareerCreateNestedOneWithoutJobOffersInput = {
    create?: XOR<CareerCreateWithoutJobOffersInput, CareerUncheckedCreateWithoutJobOffersInput>
    connectOrCreate?: CareerCreateOrConnectWithoutJobOffersInput
    connect?: CareerWhereUniqueInput
  }

  export type JobApplicationCreateNestedManyWithoutJobOfferInput = {
    create?: XOR<JobApplicationCreateWithoutJobOfferInput, JobApplicationUncheckedCreateWithoutJobOfferInput> | JobApplicationCreateWithoutJobOfferInput[] | JobApplicationUncheckedCreateWithoutJobOfferInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobOfferInput | JobApplicationCreateOrConnectWithoutJobOfferInput[]
    createMany?: JobApplicationCreateManyJobOfferInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type ContractTypeCreateNestedOneWithoutContractsOfThisTypeInput = {
    create?: XOR<ContractTypeCreateWithoutContractsOfThisTypeInput, ContractTypeUncheckedCreateWithoutContractsOfThisTypeInput>
    connectOrCreate?: ContractTypeCreateOrConnectWithoutContractsOfThisTypeInput
    connect?: ContractTypeWhereUniqueInput
  }

  export type JobOfferTechnicalSkillCreateNestedManyWithoutJobOfferInput = {
    create?: XOR<JobOfferTechnicalSkillCreateWithoutJobOfferInput, JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput> | JobOfferTechnicalSkillCreateWithoutJobOfferInput[] | JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput[]
    connectOrCreate?: JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput | JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput[]
    createMany?: JobOfferTechnicalSkillCreateManyJobOfferInputEnvelope
    connect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutJobOfferInput = {
    create?: XOR<JobApplicationCreateWithoutJobOfferInput, JobApplicationUncheckedCreateWithoutJobOfferInput> | JobApplicationCreateWithoutJobOfferInput[] | JobApplicationUncheckedCreateWithoutJobOfferInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobOfferInput | JobApplicationCreateOrConnectWithoutJobOfferInput[]
    createMany?: JobApplicationCreateManyJobOfferInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutJobOfferInput = {
    create?: XOR<JobOfferTechnicalSkillCreateWithoutJobOfferInput, JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput> | JobOfferTechnicalSkillCreateWithoutJobOfferInput[] | JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput[]
    connectOrCreate?: JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput | JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput[]
    createMany?: JobOfferTechnicalSkillCreateManyJobOfferInputEnvelope
    connect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CareerUpdateOneRequiredWithoutJobOffersNestedInput = {
    create?: XOR<CareerCreateWithoutJobOffersInput, CareerUncheckedCreateWithoutJobOffersInput>
    connectOrCreate?: CareerCreateOrConnectWithoutJobOffersInput
    upsert?: CareerUpsertWithoutJobOffersInput
    connect?: CareerWhereUniqueInput
    update?: XOR<XOR<CareerUpdateToOneWithWhereWithoutJobOffersInput, CareerUpdateWithoutJobOffersInput>, CareerUncheckedUpdateWithoutJobOffersInput>
  }

  export type JobApplicationUpdateManyWithoutJobOfferNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobOfferInput, JobApplicationUncheckedCreateWithoutJobOfferInput> | JobApplicationCreateWithoutJobOfferInput[] | JobApplicationUncheckedCreateWithoutJobOfferInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobOfferInput | JobApplicationCreateOrConnectWithoutJobOfferInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobOfferInput | JobApplicationUpsertWithWhereUniqueWithoutJobOfferInput[]
    createMany?: JobApplicationCreateManyJobOfferInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobOfferInput | JobApplicationUpdateWithWhereUniqueWithoutJobOfferInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobOfferInput | JobApplicationUpdateManyWithWhereWithoutJobOfferInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type ContractTypeUpdateOneRequiredWithoutContractsOfThisTypeNestedInput = {
    create?: XOR<ContractTypeCreateWithoutContractsOfThisTypeInput, ContractTypeUncheckedCreateWithoutContractsOfThisTypeInput>
    connectOrCreate?: ContractTypeCreateOrConnectWithoutContractsOfThisTypeInput
    upsert?: ContractTypeUpsertWithoutContractsOfThisTypeInput
    connect?: ContractTypeWhereUniqueInput
    update?: XOR<XOR<ContractTypeUpdateToOneWithWhereWithoutContractsOfThisTypeInput, ContractTypeUpdateWithoutContractsOfThisTypeInput>, ContractTypeUncheckedUpdateWithoutContractsOfThisTypeInput>
  }

  export type JobOfferTechnicalSkillUpdateManyWithoutJobOfferNestedInput = {
    create?: XOR<JobOfferTechnicalSkillCreateWithoutJobOfferInput, JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput> | JobOfferTechnicalSkillCreateWithoutJobOfferInput[] | JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput[]
    connectOrCreate?: JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput | JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput[]
    upsert?: JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutJobOfferInput | JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutJobOfferInput[]
    createMany?: JobOfferTechnicalSkillCreateManyJobOfferInputEnvelope
    set?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    disconnect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    delete?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    connect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    update?: JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutJobOfferInput | JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutJobOfferInput[]
    updateMany?: JobOfferTechnicalSkillUpdateManyWithWhereWithoutJobOfferInput | JobOfferTechnicalSkillUpdateManyWithWhereWithoutJobOfferInput[]
    deleteMany?: JobOfferTechnicalSkillScalarWhereInput | JobOfferTechnicalSkillScalarWhereInput[]
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobOfferNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobOfferInput, JobApplicationUncheckedCreateWithoutJobOfferInput> | JobApplicationCreateWithoutJobOfferInput[] | JobApplicationUncheckedCreateWithoutJobOfferInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobOfferInput | JobApplicationCreateOrConnectWithoutJobOfferInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobOfferInput | JobApplicationUpsertWithWhereUniqueWithoutJobOfferInput[]
    createMany?: JobApplicationCreateManyJobOfferInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobOfferInput | JobApplicationUpdateWithWhereUniqueWithoutJobOfferInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobOfferInput | JobApplicationUpdateManyWithWhereWithoutJobOfferInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type JobOfferTechnicalSkillUncheckedUpdateManyWithoutJobOfferNestedInput = {
    create?: XOR<JobOfferTechnicalSkillCreateWithoutJobOfferInput, JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput> | JobOfferTechnicalSkillCreateWithoutJobOfferInput[] | JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput[]
    connectOrCreate?: JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput | JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput[]
    upsert?: JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutJobOfferInput | JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutJobOfferInput[]
    createMany?: JobOfferTechnicalSkillCreateManyJobOfferInputEnvelope
    set?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    disconnect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    delete?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    connect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    update?: JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutJobOfferInput | JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutJobOfferInput[]
    updateMany?: JobOfferTechnicalSkillUpdateManyWithWhereWithoutJobOfferInput | JobOfferTechnicalSkillUpdateManyWithWhereWithoutJobOfferInput[]
    deleteMany?: JobOfferTechnicalSkillScalarWhereInput | JobOfferTechnicalSkillScalarWhereInput[]
  }

  export type JobOfferCreateNestedOneWithoutTechnicalSkillsInput = {
    create?: XOR<JobOfferCreateWithoutTechnicalSkillsInput, JobOfferUncheckedCreateWithoutTechnicalSkillsInput>
    connectOrCreate?: JobOfferCreateOrConnectWithoutTechnicalSkillsInput
    connect?: JobOfferWhereUniqueInput
  }

  export type TechnicalSkillCreateNestedOneWithoutJobOffersListingThisInput = {
    create?: XOR<TechnicalSkillCreateWithoutJobOffersListingThisInput, TechnicalSkillUncheckedCreateWithoutJobOffersListingThisInput>
    connectOrCreate?: TechnicalSkillCreateOrConnectWithoutJobOffersListingThisInput
    connect?: TechnicalSkillWhereUniqueInput
  }

  export type JobOfferUpdateOneRequiredWithoutTechnicalSkillsNestedInput = {
    create?: XOR<JobOfferCreateWithoutTechnicalSkillsInput, JobOfferUncheckedCreateWithoutTechnicalSkillsInput>
    connectOrCreate?: JobOfferCreateOrConnectWithoutTechnicalSkillsInput
    upsert?: JobOfferUpsertWithoutTechnicalSkillsInput
    connect?: JobOfferWhereUniqueInput
    update?: XOR<XOR<JobOfferUpdateToOneWithWhereWithoutTechnicalSkillsInput, JobOfferUpdateWithoutTechnicalSkillsInput>, JobOfferUncheckedUpdateWithoutTechnicalSkillsInput>
  }

  export type TechnicalSkillUpdateOneRequiredWithoutJobOffersListingThisNestedInput = {
    create?: XOR<TechnicalSkillCreateWithoutJobOffersListingThisInput, TechnicalSkillUncheckedCreateWithoutJobOffersListingThisInput>
    connectOrCreate?: TechnicalSkillCreateOrConnectWithoutJobOffersListingThisInput
    upsert?: TechnicalSkillUpsertWithoutJobOffersListingThisInput
    connect?: TechnicalSkillWhereUniqueInput
    update?: XOR<XOR<TechnicalSkillUpdateToOneWithWhereWithoutJobOffersListingThisInput, TechnicalSkillUpdateWithoutJobOffersListingThisInput>, TechnicalSkillUncheckedUpdateWithoutJobOffersListingThisInput>
  }

  export type JobOfferCreateNestedManyWithoutContractTypeInput = {
    create?: XOR<JobOfferCreateWithoutContractTypeInput, JobOfferUncheckedCreateWithoutContractTypeInput> | JobOfferCreateWithoutContractTypeInput[] | JobOfferUncheckedCreateWithoutContractTypeInput[]
    connectOrCreate?: JobOfferCreateOrConnectWithoutContractTypeInput | JobOfferCreateOrConnectWithoutContractTypeInput[]
    createMany?: JobOfferCreateManyContractTypeInputEnvelope
    connect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
  }

  export type JobOfferUncheckedCreateNestedManyWithoutContractTypeInput = {
    create?: XOR<JobOfferCreateWithoutContractTypeInput, JobOfferUncheckedCreateWithoutContractTypeInput> | JobOfferCreateWithoutContractTypeInput[] | JobOfferUncheckedCreateWithoutContractTypeInput[]
    connectOrCreate?: JobOfferCreateOrConnectWithoutContractTypeInput | JobOfferCreateOrConnectWithoutContractTypeInput[]
    createMany?: JobOfferCreateManyContractTypeInputEnvelope
    connect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
  }

  export type JobOfferUpdateManyWithoutContractTypeNestedInput = {
    create?: XOR<JobOfferCreateWithoutContractTypeInput, JobOfferUncheckedCreateWithoutContractTypeInput> | JobOfferCreateWithoutContractTypeInput[] | JobOfferUncheckedCreateWithoutContractTypeInput[]
    connectOrCreate?: JobOfferCreateOrConnectWithoutContractTypeInput | JobOfferCreateOrConnectWithoutContractTypeInput[]
    upsert?: JobOfferUpsertWithWhereUniqueWithoutContractTypeInput | JobOfferUpsertWithWhereUniqueWithoutContractTypeInput[]
    createMany?: JobOfferCreateManyContractTypeInputEnvelope
    set?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    disconnect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    delete?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    connect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    update?: JobOfferUpdateWithWhereUniqueWithoutContractTypeInput | JobOfferUpdateWithWhereUniqueWithoutContractTypeInput[]
    updateMany?: JobOfferUpdateManyWithWhereWithoutContractTypeInput | JobOfferUpdateManyWithWhereWithoutContractTypeInput[]
    deleteMany?: JobOfferScalarWhereInput | JobOfferScalarWhereInput[]
  }

  export type JobOfferUncheckedUpdateManyWithoutContractTypeNestedInput = {
    create?: XOR<JobOfferCreateWithoutContractTypeInput, JobOfferUncheckedCreateWithoutContractTypeInput> | JobOfferCreateWithoutContractTypeInput[] | JobOfferUncheckedCreateWithoutContractTypeInput[]
    connectOrCreate?: JobOfferCreateOrConnectWithoutContractTypeInput | JobOfferCreateOrConnectWithoutContractTypeInput[]
    upsert?: JobOfferUpsertWithWhereUniqueWithoutContractTypeInput | JobOfferUpsertWithWhereUniqueWithoutContractTypeInput[]
    createMany?: JobOfferCreateManyContractTypeInputEnvelope
    set?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    disconnect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    delete?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    connect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    update?: JobOfferUpdateWithWhereUniqueWithoutContractTypeInput | JobOfferUpdateWithWhereUniqueWithoutContractTypeInput[]
    updateMany?: JobOfferUpdateManyWithWhereWithoutContractTypeInput | JobOfferUpdateManyWithWhereWithoutContractTypeInput[]
    deleteMany?: JobOfferScalarWhereInput | JobOfferScalarWhereInput[]
  }

  export type JobOfferCreateNestedManyWithoutCareerInput = {
    create?: XOR<JobOfferCreateWithoutCareerInput, JobOfferUncheckedCreateWithoutCareerInput> | JobOfferCreateWithoutCareerInput[] | JobOfferUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: JobOfferCreateOrConnectWithoutCareerInput | JobOfferCreateOrConnectWithoutCareerInput[]
    createMany?: JobOfferCreateManyCareerInputEnvelope
    connect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
  }

  export type GraduationCreateNestedManyWithoutCareerInput = {
    create?: XOR<GraduationCreateWithoutCareerInput, GraduationUncheckedCreateWithoutCareerInput> | GraduationCreateWithoutCareerInput[] | GraduationUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: GraduationCreateOrConnectWithoutCareerInput | GraduationCreateOrConnectWithoutCareerInput[]
    createMany?: GraduationCreateManyCareerInputEnvelope
    connect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
  }

  export type SkillCategoryCreateNestedManyWithoutRelatedCareersInput = {
    create?: XOR<SkillCategoryCreateWithoutRelatedCareersInput, SkillCategoryUncheckedCreateWithoutRelatedCareersInput> | SkillCategoryCreateWithoutRelatedCareersInput[] | SkillCategoryUncheckedCreateWithoutRelatedCareersInput[]
    connectOrCreate?: SkillCategoryCreateOrConnectWithoutRelatedCareersInput | SkillCategoryCreateOrConnectWithoutRelatedCareersInput[]
    connect?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
  }

  export type JobOfferUncheckedCreateNestedManyWithoutCareerInput = {
    create?: XOR<JobOfferCreateWithoutCareerInput, JobOfferUncheckedCreateWithoutCareerInput> | JobOfferCreateWithoutCareerInput[] | JobOfferUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: JobOfferCreateOrConnectWithoutCareerInput | JobOfferCreateOrConnectWithoutCareerInput[]
    createMany?: JobOfferCreateManyCareerInputEnvelope
    connect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
  }

  export type GraduationUncheckedCreateNestedManyWithoutCareerInput = {
    create?: XOR<GraduationCreateWithoutCareerInput, GraduationUncheckedCreateWithoutCareerInput> | GraduationCreateWithoutCareerInput[] | GraduationUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: GraduationCreateOrConnectWithoutCareerInput | GraduationCreateOrConnectWithoutCareerInput[]
    createMany?: GraduationCreateManyCareerInputEnvelope
    connect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
  }

  export type SkillCategoryUncheckedCreateNestedManyWithoutRelatedCareersInput = {
    create?: XOR<SkillCategoryCreateWithoutRelatedCareersInput, SkillCategoryUncheckedCreateWithoutRelatedCareersInput> | SkillCategoryCreateWithoutRelatedCareersInput[] | SkillCategoryUncheckedCreateWithoutRelatedCareersInput[]
    connectOrCreate?: SkillCategoryCreateOrConnectWithoutRelatedCareersInput | SkillCategoryCreateOrConnectWithoutRelatedCareersInput[]
    connect?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
  }

  export type JobOfferUpdateManyWithoutCareerNestedInput = {
    create?: XOR<JobOfferCreateWithoutCareerInput, JobOfferUncheckedCreateWithoutCareerInput> | JobOfferCreateWithoutCareerInput[] | JobOfferUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: JobOfferCreateOrConnectWithoutCareerInput | JobOfferCreateOrConnectWithoutCareerInput[]
    upsert?: JobOfferUpsertWithWhereUniqueWithoutCareerInput | JobOfferUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: JobOfferCreateManyCareerInputEnvelope
    set?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    disconnect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    delete?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    connect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    update?: JobOfferUpdateWithWhereUniqueWithoutCareerInput | JobOfferUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: JobOfferUpdateManyWithWhereWithoutCareerInput | JobOfferUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: JobOfferScalarWhereInput | JobOfferScalarWhereInput[]
  }

  export type GraduationUpdateManyWithoutCareerNestedInput = {
    create?: XOR<GraduationCreateWithoutCareerInput, GraduationUncheckedCreateWithoutCareerInput> | GraduationCreateWithoutCareerInput[] | GraduationUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: GraduationCreateOrConnectWithoutCareerInput | GraduationCreateOrConnectWithoutCareerInput[]
    upsert?: GraduationUpsertWithWhereUniqueWithoutCareerInput | GraduationUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: GraduationCreateManyCareerInputEnvelope
    set?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    disconnect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    delete?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    connect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    update?: GraduationUpdateWithWhereUniqueWithoutCareerInput | GraduationUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: GraduationUpdateManyWithWhereWithoutCareerInput | GraduationUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: GraduationScalarWhereInput | GraduationScalarWhereInput[]
  }

  export type SkillCategoryUpdateManyWithoutRelatedCareersNestedInput = {
    create?: XOR<SkillCategoryCreateWithoutRelatedCareersInput, SkillCategoryUncheckedCreateWithoutRelatedCareersInput> | SkillCategoryCreateWithoutRelatedCareersInput[] | SkillCategoryUncheckedCreateWithoutRelatedCareersInput[]
    connectOrCreate?: SkillCategoryCreateOrConnectWithoutRelatedCareersInput | SkillCategoryCreateOrConnectWithoutRelatedCareersInput[]
    upsert?: SkillCategoryUpsertWithWhereUniqueWithoutRelatedCareersInput | SkillCategoryUpsertWithWhereUniqueWithoutRelatedCareersInput[]
    set?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
    disconnect?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
    delete?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
    connect?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
    update?: SkillCategoryUpdateWithWhereUniqueWithoutRelatedCareersInput | SkillCategoryUpdateWithWhereUniqueWithoutRelatedCareersInput[]
    updateMany?: SkillCategoryUpdateManyWithWhereWithoutRelatedCareersInput | SkillCategoryUpdateManyWithWhereWithoutRelatedCareersInput[]
    deleteMany?: SkillCategoryScalarWhereInput | SkillCategoryScalarWhereInput[]
  }

  export type JobOfferUncheckedUpdateManyWithoutCareerNestedInput = {
    create?: XOR<JobOfferCreateWithoutCareerInput, JobOfferUncheckedCreateWithoutCareerInput> | JobOfferCreateWithoutCareerInput[] | JobOfferUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: JobOfferCreateOrConnectWithoutCareerInput | JobOfferCreateOrConnectWithoutCareerInput[]
    upsert?: JobOfferUpsertWithWhereUniqueWithoutCareerInput | JobOfferUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: JobOfferCreateManyCareerInputEnvelope
    set?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    disconnect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    delete?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    connect?: JobOfferWhereUniqueInput | JobOfferWhereUniqueInput[]
    update?: JobOfferUpdateWithWhereUniqueWithoutCareerInput | JobOfferUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: JobOfferUpdateManyWithWhereWithoutCareerInput | JobOfferUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: JobOfferScalarWhereInput | JobOfferScalarWhereInput[]
  }

  export type GraduationUncheckedUpdateManyWithoutCareerNestedInput = {
    create?: XOR<GraduationCreateWithoutCareerInput, GraduationUncheckedCreateWithoutCareerInput> | GraduationCreateWithoutCareerInput[] | GraduationUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: GraduationCreateOrConnectWithoutCareerInput | GraduationCreateOrConnectWithoutCareerInput[]
    upsert?: GraduationUpsertWithWhereUniqueWithoutCareerInput | GraduationUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: GraduationCreateManyCareerInputEnvelope
    set?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    disconnect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    delete?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    connect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    update?: GraduationUpdateWithWhereUniqueWithoutCareerInput | GraduationUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: GraduationUpdateManyWithWhereWithoutCareerInput | GraduationUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: GraduationScalarWhereInput | GraduationScalarWhereInput[]
  }

  export type SkillCategoryUncheckedUpdateManyWithoutRelatedCareersNestedInput = {
    create?: XOR<SkillCategoryCreateWithoutRelatedCareersInput, SkillCategoryUncheckedCreateWithoutRelatedCareersInput> | SkillCategoryCreateWithoutRelatedCareersInput[] | SkillCategoryUncheckedCreateWithoutRelatedCareersInput[]
    connectOrCreate?: SkillCategoryCreateOrConnectWithoutRelatedCareersInput | SkillCategoryCreateOrConnectWithoutRelatedCareersInput[]
    upsert?: SkillCategoryUpsertWithWhereUniqueWithoutRelatedCareersInput | SkillCategoryUpsertWithWhereUniqueWithoutRelatedCareersInput[]
    set?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
    disconnect?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
    delete?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
    connect?: SkillCategoryWhereUniqueInput | SkillCategoryWhereUniqueInput[]
    update?: SkillCategoryUpdateWithWhereUniqueWithoutRelatedCareersInput | SkillCategoryUpdateWithWhereUniqueWithoutRelatedCareersInput[]
    updateMany?: SkillCategoryUpdateManyWithWhereWithoutRelatedCareersInput | SkillCategoryUpdateManyWithWhereWithoutRelatedCareersInput[]
    deleteMany?: SkillCategoryScalarWhereInput | SkillCategoryScalarWhereInput[]
  }

  export type AlumniCreateNestedOneWithoutAssociatedUserInput = {
    create?: XOR<AlumniCreateWithoutAssociatedUserInput, AlumniUncheckedCreateWithoutAssociatedUserInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutAssociatedUserInput
    connect?: AlumniWhereUniqueInput
  }

  export type AlumniUncheckedCreateNestedOneWithoutAssociatedUserInput = {
    create?: XOR<AlumniCreateWithoutAssociatedUserInput, AlumniUncheckedCreateWithoutAssociatedUserInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutAssociatedUserInput
    connect?: AlumniWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AlumniUpdateOneWithoutAssociatedUserNestedInput = {
    create?: XOR<AlumniCreateWithoutAssociatedUserInput, AlumniUncheckedCreateWithoutAssociatedUserInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutAssociatedUserInput
    upsert?: AlumniUpsertWithoutAssociatedUserInput
    disconnect?: AlumniWhereInput | boolean
    delete?: AlumniWhereInput | boolean
    connect?: AlumniWhereUniqueInput
    update?: XOR<XOR<AlumniUpdateToOneWithWhereWithoutAssociatedUserInput, AlumniUpdateWithoutAssociatedUserInput>, AlumniUncheckedUpdateWithoutAssociatedUserInput>
  }

  export type AlumniUncheckedUpdateOneWithoutAssociatedUserNestedInput = {
    create?: XOR<AlumniCreateWithoutAssociatedUserInput, AlumniUncheckedCreateWithoutAssociatedUserInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutAssociatedUserInput
    upsert?: AlumniUpsertWithoutAssociatedUserInput
    disconnect?: AlumniWhereInput | boolean
    delete?: AlumniWhereInput | boolean
    connect?: AlumniWhereUniqueInput
    update?: XOR<XOR<AlumniUpdateToOneWithWhereWithoutAssociatedUserInput, AlumniUpdateWithoutAssociatedUserInput>, AlumniUncheckedUpdateWithoutAssociatedUserInput>
  }

  export type UserCreateNestedOneWithoutAssociatedAlumniInput = {
    create?: XOR<UserCreateWithoutAssociatedAlumniInput, UserUncheckedCreateWithoutAssociatedAlumniInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssociatedAlumniInput
    connect?: UserWhereUniqueInput
  }

  export type JobApplicationCreateNestedManyWithoutAlumniWhoAppliedInput = {
    create?: XOR<JobApplicationCreateWithoutAlumniWhoAppliedInput, JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput> | JobApplicationCreateWithoutAlumniWhoAppliedInput[] | JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput | JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput[]
    createMany?: JobApplicationCreateManyAlumniWhoAppliedInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type ResumeCreateNestedOneWithoutOwnerInput = {
    create?: XOR<ResumeCreateWithoutOwnerInput, ResumeUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutOwnerInput
    connect?: ResumeWhereUniqueInput
  }

  export type GraduationCreateNestedManyWithoutAlumniInput = {
    create?: XOR<GraduationCreateWithoutAlumniInput, GraduationUncheckedCreateWithoutAlumniInput> | GraduationCreateWithoutAlumniInput[] | GraduationUncheckedCreateWithoutAlumniInput[]
    connectOrCreate?: GraduationCreateOrConnectWithoutAlumniInput | GraduationCreateOrConnectWithoutAlumniInput[]
    createMany?: GraduationCreateManyAlumniInputEnvelope
    connect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutAlumniWhoAppliedInput = {
    create?: XOR<JobApplicationCreateWithoutAlumniWhoAppliedInput, JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput> | JobApplicationCreateWithoutAlumniWhoAppliedInput[] | JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput | JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput[]
    createMany?: JobApplicationCreateManyAlumniWhoAppliedInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type ResumeUncheckedCreateNestedOneWithoutOwnerInput = {
    create?: XOR<ResumeCreateWithoutOwnerInput, ResumeUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutOwnerInput
    connect?: ResumeWhereUniqueInput
  }

  export type GraduationUncheckedCreateNestedManyWithoutAlumniInput = {
    create?: XOR<GraduationCreateWithoutAlumniInput, GraduationUncheckedCreateWithoutAlumniInput> | GraduationCreateWithoutAlumniInput[] | GraduationUncheckedCreateWithoutAlumniInput[]
    connectOrCreate?: GraduationCreateOrConnectWithoutAlumniInput | GraduationCreateOrConnectWithoutAlumniInput[]
    createMany?: GraduationCreateManyAlumniInputEnvelope
    connect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutAssociatedAlumniNestedInput = {
    create?: XOR<UserCreateWithoutAssociatedAlumniInput, UserUncheckedCreateWithoutAssociatedAlumniInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssociatedAlumniInput
    upsert?: UserUpsertWithoutAssociatedAlumniInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssociatedAlumniInput, UserUpdateWithoutAssociatedAlumniInput>, UserUncheckedUpdateWithoutAssociatedAlumniInput>
  }

  export type JobApplicationUpdateManyWithoutAlumniWhoAppliedNestedInput = {
    create?: XOR<JobApplicationCreateWithoutAlumniWhoAppliedInput, JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput> | JobApplicationCreateWithoutAlumniWhoAppliedInput[] | JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput | JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutAlumniWhoAppliedInput | JobApplicationUpsertWithWhereUniqueWithoutAlumniWhoAppliedInput[]
    createMany?: JobApplicationCreateManyAlumniWhoAppliedInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutAlumniWhoAppliedInput | JobApplicationUpdateWithWhereUniqueWithoutAlumniWhoAppliedInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutAlumniWhoAppliedInput | JobApplicationUpdateManyWithWhereWithoutAlumniWhoAppliedInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type ResumeUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<ResumeCreateWithoutOwnerInput, ResumeUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutOwnerInput
    upsert?: ResumeUpsertWithoutOwnerInput
    disconnect?: ResumeWhereInput | boolean
    delete?: ResumeWhereInput | boolean
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutOwnerInput, ResumeUpdateWithoutOwnerInput>, ResumeUncheckedUpdateWithoutOwnerInput>
  }

  export type GraduationUpdateManyWithoutAlumniNestedInput = {
    create?: XOR<GraduationCreateWithoutAlumniInput, GraduationUncheckedCreateWithoutAlumniInput> | GraduationCreateWithoutAlumniInput[] | GraduationUncheckedCreateWithoutAlumniInput[]
    connectOrCreate?: GraduationCreateOrConnectWithoutAlumniInput | GraduationCreateOrConnectWithoutAlumniInput[]
    upsert?: GraduationUpsertWithWhereUniqueWithoutAlumniInput | GraduationUpsertWithWhereUniqueWithoutAlumniInput[]
    createMany?: GraduationCreateManyAlumniInputEnvelope
    set?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    disconnect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    delete?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    connect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    update?: GraduationUpdateWithWhereUniqueWithoutAlumniInput | GraduationUpdateWithWhereUniqueWithoutAlumniInput[]
    updateMany?: GraduationUpdateManyWithWhereWithoutAlumniInput | GraduationUpdateManyWithWhereWithoutAlumniInput[]
    deleteMany?: GraduationScalarWhereInput | GraduationScalarWhereInput[]
  }

  export type JobApplicationUncheckedUpdateManyWithoutAlumniWhoAppliedNestedInput = {
    create?: XOR<JobApplicationCreateWithoutAlumniWhoAppliedInput, JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput> | JobApplicationCreateWithoutAlumniWhoAppliedInput[] | JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput | JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutAlumniWhoAppliedInput | JobApplicationUpsertWithWhereUniqueWithoutAlumniWhoAppliedInput[]
    createMany?: JobApplicationCreateManyAlumniWhoAppliedInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutAlumniWhoAppliedInput | JobApplicationUpdateWithWhereUniqueWithoutAlumniWhoAppliedInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutAlumniWhoAppliedInput | JobApplicationUpdateManyWithWhereWithoutAlumniWhoAppliedInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type ResumeUncheckedUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<ResumeCreateWithoutOwnerInput, ResumeUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutOwnerInput
    upsert?: ResumeUpsertWithoutOwnerInput
    disconnect?: ResumeWhereInput | boolean
    delete?: ResumeWhereInput | boolean
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutOwnerInput, ResumeUpdateWithoutOwnerInput>, ResumeUncheckedUpdateWithoutOwnerInput>
  }

  export type GraduationUncheckedUpdateManyWithoutAlumniNestedInput = {
    create?: XOR<GraduationCreateWithoutAlumniInput, GraduationUncheckedCreateWithoutAlumniInput> | GraduationCreateWithoutAlumniInput[] | GraduationUncheckedCreateWithoutAlumniInput[]
    connectOrCreate?: GraduationCreateOrConnectWithoutAlumniInput | GraduationCreateOrConnectWithoutAlumniInput[]
    upsert?: GraduationUpsertWithWhereUniqueWithoutAlumniInput | GraduationUpsertWithWhereUniqueWithoutAlumniInput[]
    createMany?: GraduationCreateManyAlumniInputEnvelope
    set?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    disconnect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    delete?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    connect?: GraduationWhereUniqueInput | GraduationWhereUniqueInput[]
    update?: GraduationUpdateWithWhereUniqueWithoutAlumniInput | GraduationUpdateWithWhereUniqueWithoutAlumniInput[]
    updateMany?: GraduationUpdateManyWithWhereWithoutAlumniInput | GraduationUpdateManyWithWhereWithoutAlumniInput[]
    deleteMany?: GraduationScalarWhereInput | GraduationScalarWhereInput[]
  }

  export type CareerCreateNestedOneWithoutGraduationsInput = {
    create?: XOR<CareerCreateWithoutGraduationsInput, CareerUncheckedCreateWithoutGraduationsInput>
    connectOrCreate?: CareerCreateOrConnectWithoutGraduationsInput
    connect?: CareerWhereUniqueInput
  }

  export type AlumniCreateNestedOneWithoutGraduationsInput = {
    create?: XOR<AlumniCreateWithoutGraduationsInput, AlumniUncheckedCreateWithoutGraduationsInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutGraduationsInput
    connect?: AlumniWhereUniqueInput
  }

  export type CareerUpdateOneRequiredWithoutGraduationsNestedInput = {
    create?: XOR<CareerCreateWithoutGraduationsInput, CareerUncheckedCreateWithoutGraduationsInput>
    connectOrCreate?: CareerCreateOrConnectWithoutGraduationsInput
    upsert?: CareerUpsertWithoutGraduationsInput
    connect?: CareerWhereUniqueInput
    update?: XOR<XOR<CareerUpdateToOneWithWhereWithoutGraduationsInput, CareerUpdateWithoutGraduationsInput>, CareerUncheckedUpdateWithoutGraduationsInput>
  }

  export type AlumniUpdateOneRequiredWithoutGraduationsNestedInput = {
    create?: XOR<AlumniCreateWithoutGraduationsInput, AlumniUncheckedCreateWithoutGraduationsInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutGraduationsInput
    upsert?: AlumniUpsertWithoutGraduationsInput
    connect?: AlumniWhereUniqueInput
    update?: XOR<XOR<AlumniUpdateToOneWithWhereWithoutGraduationsInput, AlumniUpdateWithoutGraduationsInput>, AlumniUncheckedUpdateWithoutGraduationsInput>
  }

  export type JobOfferCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<JobOfferCreateWithoutApplicationsInput, JobOfferUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: JobOfferCreateOrConnectWithoutApplicationsInput
    connect?: JobOfferWhereUniqueInput
  }

  export type AlumniCreateNestedOneWithoutJobApplicationsInput = {
    create?: XOR<AlumniCreateWithoutJobApplicationsInput, AlumniUncheckedCreateWithoutJobApplicationsInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutJobApplicationsInput
    connect?: AlumniWhereUniqueInput
  }

  export type JobOfferUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<JobOfferCreateWithoutApplicationsInput, JobOfferUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: JobOfferCreateOrConnectWithoutApplicationsInput
    upsert?: JobOfferUpsertWithoutApplicationsInput
    connect?: JobOfferWhereUniqueInput
    update?: XOR<XOR<JobOfferUpdateToOneWithWhereWithoutApplicationsInput, JobOfferUpdateWithoutApplicationsInput>, JobOfferUncheckedUpdateWithoutApplicationsInput>
  }

  export type AlumniUpdateOneRequiredWithoutJobApplicationsNestedInput = {
    create?: XOR<AlumniCreateWithoutJobApplicationsInput, AlumniUncheckedCreateWithoutJobApplicationsInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutJobApplicationsInput
    upsert?: AlumniUpsertWithoutJobApplicationsInput
    connect?: AlumniWhereUniqueInput
    update?: XOR<XOR<AlumniUpdateToOneWithWhereWithoutJobApplicationsInput, AlumniUpdateWithoutJobApplicationsInput>, AlumniUncheckedUpdateWithoutJobApplicationsInput>
  }

  export type AlumniCreateNestedOneWithoutResumeInput = {
    create?: XOR<AlumniCreateWithoutResumeInput, AlumniUncheckedCreateWithoutResumeInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutResumeInput
    connect?: AlumniWhereUniqueInput
  }

  export type ResumeLanguageCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeLanguageCreateWithoutResumeInput, ResumeLanguageUncheckedCreateWithoutResumeInput> | ResumeLanguageCreateWithoutResumeInput[] | ResumeLanguageUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeLanguageCreateOrConnectWithoutResumeInput | ResumeLanguageCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeLanguageCreateManyResumeInputEnvelope
    connect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
  }

  export type PortfolioItemCreateNestedManyWithoutResumeInput = {
    create?: XOR<PortfolioItemCreateWithoutResumeInput, PortfolioItemUncheckedCreateWithoutResumeInput> | PortfolioItemCreateWithoutResumeInput[] | PortfolioItemUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutResumeInput | PortfolioItemCreateOrConnectWithoutResumeInput[]
    createMany?: PortfolioItemCreateManyResumeInputEnvelope
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
  }

  export type HigherEducationStudyCreateNestedManyWithoutResumeInput = {
    create?: XOR<HigherEducationStudyCreateWithoutResumeInput, HigherEducationStudyUncheckedCreateWithoutResumeInput> | HigherEducationStudyCreateWithoutResumeInput[] | HigherEducationStudyUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: HigherEducationStudyCreateOrConnectWithoutResumeInput | HigherEducationStudyCreateOrConnectWithoutResumeInput[]
    createMany?: HigherEducationStudyCreateManyResumeInputEnvelope
    connect?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
  }

  export type ResumeTechnicalSkillCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeTechnicalSkillCreateWithoutResumeInput, ResumeTechnicalSkillUncheckedCreateWithoutResumeInput> | ResumeTechnicalSkillCreateWithoutResumeInput[] | ResumeTechnicalSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeTechnicalSkillCreateOrConnectWithoutResumeInput | ResumeTechnicalSkillCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeTechnicalSkillCreateManyResumeInputEnvelope
    connect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
  }

  export type ResumeSoftSkillCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeSoftSkillCreateWithoutResumeInput, ResumeSoftSkillUncheckedCreateWithoutResumeInput> | ResumeSoftSkillCreateWithoutResumeInput[] | ResumeSoftSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeSoftSkillCreateOrConnectWithoutResumeInput | ResumeSoftSkillCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeSoftSkillCreateManyResumeInputEnvelope
    connect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
  }

  export type ResumeCiapCourseCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeCiapCourseCreateWithoutResumeInput, ResumeCiapCourseUncheckedCreateWithoutResumeInput> | ResumeCiapCourseCreateWithoutResumeInput[] | ResumeCiapCourseUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeCiapCourseCreateOrConnectWithoutResumeInput | ResumeCiapCourseCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeCiapCourseCreateManyResumeInputEnvelope
    connect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
  }

  export type PositionOfInterestCreateNestedManyWithoutResumeInput = {
    create?: XOR<PositionOfInterestCreateWithoutResumeInput, PositionOfInterestUncheckedCreateWithoutResumeInput> | PositionOfInterestCreateWithoutResumeInput[] | PositionOfInterestUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PositionOfInterestCreateOrConnectWithoutResumeInput | PositionOfInterestCreateOrConnectWithoutResumeInput[]
    createMany?: PositionOfInterestCreateManyResumeInputEnvelope
    connect?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
  }

  export type IndustryOfInterestCreateNestedManyWithoutResumeInput = {
    create?: XOR<IndustryOfInterestCreateWithoutResumeInput, IndustryOfInterestUncheckedCreateWithoutResumeInput> | IndustryOfInterestCreateWithoutResumeInput[] | IndustryOfInterestUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: IndustryOfInterestCreateOrConnectWithoutResumeInput | IndustryOfInterestCreateOrConnectWithoutResumeInput[]
    createMany?: IndustryOfInterestCreateManyResumeInputEnvelope
    connect?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
  }

  export type ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeLanguageCreateWithoutResumeInput, ResumeLanguageUncheckedCreateWithoutResumeInput> | ResumeLanguageCreateWithoutResumeInput[] | ResumeLanguageUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeLanguageCreateOrConnectWithoutResumeInput | ResumeLanguageCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeLanguageCreateManyResumeInputEnvelope
    connect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
  }

  export type PortfolioItemUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<PortfolioItemCreateWithoutResumeInput, PortfolioItemUncheckedCreateWithoutResumeInput> | PortfolioItemCreateWithoutResumeInput[] | PortfolioItemUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutResumeInput | PortfolioItemCreateOrConnectWithoutResumeInput[]
    createMany?: PortfolioItemCreateManyResumeInputEnvelope
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
  }

  export type HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<HigherEducationStudyCreateWithoutResumeInput, HigherEducationStudyUncheckedCreateWithoutResumeInput> | HigherEducationStudyCreateWithoutResumeInput[] | HigherEducationStudyUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: HigherEducationStudyCreateOrConnectWithoutResumeInput | HigherEducationStudyCreateOrConnectWithoutResumeInput[]
    createMany?: HigherEducationStudyCreateManyResumeInputEnvelope
    connect?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
  }

  export type ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeTechnicalSkillCreateWithoutResumeInput, ResumeTechnicalSkillUncheckedCreateWithoutResumeInput> | ResumeTechnicalSkillCreateWithoutResumeInput[] | ResumeTechnicalSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeTechnicalSkillCreateOrConnectWithoutResumeInput | ResumeTechnicalSkillCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeTechnicalSkillCreateManyResumeInputEnvelope
    connect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
  }

  export type ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeSoftSkillCreateWithoutResumeInput, ResumeSoftSkillUncheckedCreateWithoutResumeInput> | ResumeSoftSkillCreateWithoutResumeInput[] | ResumeSoftSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeSoftSkillCreateOrConnectWithoutResumeInput | ResumeSoftSkillCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeSoftSkillCreateManyResumeInputEnvelope
    connect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
  }

  export type ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeCiapCourseCreateWithoutResumeInput, ResumeCiapCourseUncheckedCreateWithoutResumeInput> | ResumeCiapCourseCreateWithoutResumeInput[] | ResumeCiapCourseUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeCiapCourseCreateOrConnectWithoutResumeInput | ResumeCiapCourseCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeCiapCourseCreateManyResumeInputEnvelope
    connect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
  }

  export type PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<PositionOfInterestCreateWithoutResumeInput, PositionOfInterestUncheckedCreateWithoutResumeInput> | PositionOfInterestCreateWithoutResumeInput[] | PositionOfInterestUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PositionOfInterestCreateOrConnectWithoutResumeInput | PositionOfInterestCreateOrConnectWithoutResumeInput[]
    createMany?: PositionOfInterestCreateManyResumeInputEnvelope
    connect?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
  }

  export type IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<IndustryOfInterestCreateWithoutResumeInput, IndustryOfInterestUncheckedCreateWithoutResumeInput> | IndustryOfInterestCreateWithoutResumeInput[] | IndustryOfInterestUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: IndustryOfInterestCreateOrConnectWithoutResumeInput | IndustryOfInterestCreateOrConnectWithoutResumeInput[]
    createMany?: IndustryOfInterestCreateManyResumeInputEnvelope
    connect?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlumniUpdateOneRequiredWithoutResumeNestedInput = {
    create?: XOR<AlumniCreateWithoutResumeInput, AlumniUncheckedCreateWithoutResumeInput>
    connectOrCreate?: AlumniCreateOrConnectWithoutResumeInput
    upsert?: AlumniUpsertWithoutResumeInput
    connect?: AlumniWhereUniqueInput
    update?: XOR<XOR<AlumniUpdateToOneWithWhereWithoutResumeInput, AlumniUpdateWithoutResumeInput>, AlumniUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeLanguageUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeLanguageCreateWithoutResumeInput, ResumeLanguageUncheckedCreateWithoutResumeInput> | ResumeLanguageCreateWithoutResumeInput[] | ResumeLanguageUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeLanguageCreateOrConnectWithoutResumeInput | ResumeLanguageCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeLanguageUpsertWithWhereUniqueWithoutResumeInput | ResumeLanguageUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeLanguageCreateManyResumeInputEnvelope
    set?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    disconnect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    delete?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    connect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    update?: ResumeLanguageUpdateWithWhereUniqueWithoutResumeInput | ResumeLanguageUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeLanguageUpdateManyWithWhereWithoutResumeInput | ResumeLanguageUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeLanguageScalarWhereInput | ResumeLanguageScalarWhereInput[]
  }

  export type PortfolioItemUpdateManyWithoutResumeNestedInput = {
    create?: XOR<PortfolioItemCreateWithoutResumeInput, PortfolioItemUncheckedCreateWithoutResumeInput> | PortfolioItemCreateWithoutResumeInput[] | PortfolioItemUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutResumeInput | PortfolioItemCreateOrConnectWithoutResumeInput[]
    upsert?: PortfolioItemUpsertWithWhereUniqueWithoutResumeInput | PortfolioItemUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: PortfolioItemCreateManyResumeInputEnvelope
    set?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    disconnect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    delete?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    update?: PortfolioItemUpdateWithWhereUniqueWithoutResumeInput | PortfolioItemUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: PortfolioItemUpdateManyWithWhereWithoutResumeInput | PortfolioItemUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
  }

  export type HigherEducationStudyUpdateManyWithoutResumeNestedInput = {
    create?: XOR<HigherEducationStudyCreateWithoutResumeInput, HigherEducationStudyUncheckedCreateWithoutResumeInput> | HigherEducationStudyCreateWithoutResumeInput[] | HigherEducationStudyUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: HigherEducationStudyCreateOrConnectWithoutResumeInput | HigherEducationStudyCreateOrConnectWithoutResumeInput[]
    upsert?: HigherEducationStudyUpsertWithWhereUniqueWithoutResumeInput | HigherEducationStudyUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: HigherEducationStudyCreateManyResumeInputEnvelope
    set?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
    disconnect?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
    delete?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
    connect?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
    update?: HigherEducationStudyUpdateWithWhereUniqueWithoutResumeInput | HigherEducationStudyUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: HigherEducationStudyUpdateManyWithWhereWithoutResumeInput | HigherEducationStudyUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: HigherEducationStudyScalarWhereInput | HigherEducationStudyScalarWhereInput[]
  }

  export type ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeTechnicalSkillCreateWithoutResumeInput, ResumeTechnicalSkillUncheckedCreateWithoutResumeInput> | ResumeTechnicalSkillCreateWithoutResumeInput[] | ResumeTechnicalSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeTechnicalSkillCreateOrConnectWithoutResumeInput | ResumeTechnicalSkillCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeTechnicalSkillUpsertWithWhereUniqueWithoutResumeInput | ResumeTechnicalSkillUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeTechnicalSkillCreateManyResumeInputEnvelope
    set?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    disconnect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    delete?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    connect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    update?: ResumeTechnicalSkillUpdateWithWhereUniqueWithoutResumeInput | ResumeTechnicalSkillUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeTechnicalSkillUpdateManyWithWhereWithoutResumeInput | ResumeTechnicalSkillUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeTechnicalSkillScalarWhereInput | ResumeTechnicalSkillScalarWhereInput[]
  }

  export type ResumeSoftSkillUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeSoftSkillCreateWithoutResumeInput, ResumeSoftSkillUncheckedCreateWithoutResumeInput> | ResumeSoftSkillCreateWithoutResumeInput[] | ResumeSoftSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeSoftSkillCreateOrConnectWithoutResumeInput | ResumeSoftSkillCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeSoftSkillUpsertWithWhereUniqueWithoutResumeInput | ResumeSoftSkillUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeSoftSkillCreateManyResumeInputEnvelope
    set?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    disconnect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    delete?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    connect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    update?: ResumeSoftSkillUpdateWithWhereUniqueWithoutResumeInput | ResumeSoftSkillUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeSoftSkillUpdateManyWithWhereWithoutResumeInput | ResumeSoftSkillUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeSoftSkillScalarWhereInput | ResumeSoftSkillScalarWhereInput[]
  }

  export type ResumeCiapCourseUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeCiapCourseCreateWithoutResumeInput, ResumeCiapCourseUncheckedCreateWithoutResumeInput> | ResumeCiapCourseCreateWithoutResumeInput[] | ResumeCiapCourseUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeCiapCourseCreateOrConnectWithoutResumeInput | ResumeCiapCourseCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeCiapCourseUpsertWithWhereUniqueWithoutResumeInput | ResumeCiapCourseUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeCiapCourseCreateManyResumeInputEnvelope
    set?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    disconnect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    delete?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    connect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    update?: ResumeCiapCourseUpdateWithWhereUniqueWithoutResumeInput | ResumeCiapCourseUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeCiapCourseUpdateManyWithWhereWithoutResumeInput | ResumeCiapCourseUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeCiapCourseScalarWhereInput | ResumeCiapCourseScalarWhereInput[]
  }

  export type PositionOfInterestUpdateManyWithoutResumeNestedInput = {
    create?: XOR<PositionOfInterestCreateWithoutResumeInput, PositionOfInterestUncheckedCreateWithoutResumeInput> | PositionOfInterestCreateWithoutResumeInput[] | PositionOfInterestUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PositionOfInterestCreateOrConnectWithoutResumeInput | PositionOfInterestCreateOrConnectWithoutResumeInput[]
    upsert?: PositionOfInterestUpsertWithWhereUniqueWithoutResumeInput | PositionOfInterestUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: PositionOfInterestCreateManyResumeInputEnvelope
    set?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
    disconnect?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
    delete?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
    connect?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
    update?: PositionOfInterestUpdateWithWhereUniqueWithoutResumeInput | PositionOfInterestUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: PositionOfInterestUpdateManyWithWhereWithoutResumeInput | PositionOfInterestUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: PositionOfInterestScalarWhereInput | PositionOfInterestScalarWhereInput[]
  }

  export type IndustryOfInterestUpdateManyWithoutResumeNestedInput = {
    create?: XOR<IndustryOfInterestCreateWithoutResumeInput, IndustryOfInterestUncheckedCreateWithoutResumeInput> | IndustryOfInterestCreateWithoutResumeInput[] | IndustryOfInterestUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: IndustryOfInterestCreateOrConnectWithoutResumeInput | IndustryOfInterestCreateOrConnectWithoutResumeInput[]
    upsert?: IndustryOfInterestUpsertWithWhereUniqueWithoutResumeInput | IndustryOfInterestUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: IndustryOfInterestCreateManyResumeInputEnvelope
    set?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
    disconnect?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
    delete?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
    connect?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
    update?: IndustryOfInterestUpdateWithWhereUniqueWithoutResumeInput | IndustryOfInterestUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: IndustryOfInterestUpdateManyWithWhereWithoutResumeInput | IndustryOfInterestUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: IndustryOfInterestScalarWhereInput | IndustryOfInterestScalarWhereInput[]
  }

  export type ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeLanguageCreateWithoutResumeInput, ResumeLanguageUncheckedCreateWithoutResumeInput> | ResumeLanguageCreateWithoutResumeInput[] | ResumeLanguageUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeLanguageCreateOrConnectWithoutResumeInput | ResumeLanguageCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeLanguageUpsertWithWhereUniqueWithoutResumeInput | ResumeLanguageUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeLanguageCreateManyResumeInputEnvelope
    set?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    disconnect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    delete?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    connect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    update?: ResumeLanguageUpdateWithWhereUniqueWithoutResumeInput | ResumeLanguageUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeLanguageUpdateManyWithWhereWithoutResumeInput | ResumeLanguageUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeLanguageScalarWhereInput | ResumeLanguageScalarWhereInput[]
  }

  export type PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<PortfolioItemCreateWithoutResumeInput, PortfolioItemUncheckedCreateWithoutResumeInput> | PortfolioItemCreateWithoutResumeInput[] | PortfolioItemUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PortfolioItemCreateOrConnectWithoutResumeInput | PortfolioItemCreateOrConnectWithoutResumeInput[]
    upsert?: PortfolioItemUpsertWithWhereUniqueWithoutResumeInput | PortfolioItemUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: PortfolioItemCreateManyResumeInputEnvelope
    set?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    disconnect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    delete?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    connect?: PortfolioItemWhereUniqueInput | PortfolioItemWhereUniqueInput[]
    update?: PortfolioItemUpdateWithWhereUniqueWithoutResumeInput | PortfolioItemUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: PortfolioItemUpdateManyWithWhereWithoutResumeInput | PortfolioItemUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
  }

  export type HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<HigherEducationStudyCreateWithoutResumeInput, HigherEducationStudyUncheckedCreateWithoutResumeInput> | HigherEducationStudyCreateWithoutResumeInput[] | HigherEducationStudyUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: HigherEducationStudyCreateOrConnectWithoutResumeInput | HigherEducationStudyCreateOrConnectWithoutResumeInput[]
    upsert?: HigherEducationStudyUpsertWithWhereUniqueWithoutResumeInput | HigherEducationStudyUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: HigherEducationStudyCreateManyResumeInputEnvelope
    set?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
    disconnect?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
    delete?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
    connect?: HigherEducationStudyWhereUniqueInput | HigherEducationStudyWhereUniqueInput[]
    update?: HigherEducationStudyUpdateWithWhereUniqueWithoutResumeInput | HigherEducationStudyUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: HigherEducationStudyUpdateManyWithWhereWithoutResumeInput | HigherEducationStudyUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: HigherEducationStudyScalarWhereInput | HigherEducationStudyScalarWhereInput[]
  }

  export type ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeTechnicalSkillCreateWithoutResumeInput, ResumeTechnicalSkillUncheckedCreateWithoutResumeInput> | ResumeTechnicalSkillCreateWithoutResumeInput[] | ResumeTechnicalSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeTechnicalSkillCreateOrConnectWithoutResumeInput | ResumeTechnicalSkillCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeTechnicalSkillUpsertWithWhereUniqueWithoutResumeInput | ResumeTechnicalSkillUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeTechnicalSkillCreateManyResumeInputEnvelope
    set?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    disconnect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    delete?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    connect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    update?: ResumeTechnicalSkillUpdateWithWhereUniqueWithoutResumeInput | ResumeTechnicalSkillUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeTechnicalSkillUpdateManyWithWhereWithoutResumeInput | ResumeTechnicalSkillUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeTechnicalSkillScalarWhereInput | ResumeTechnicalSkillScalarWhereInput[]
  }

  export type ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeSoftSkillCreateWithoutResumeInput, ResumeSoftSkillUncheckedCreateWithoutResumeInput> | ResumeSoftSkillCreateWithoutResumeInput[] | ResumeSoftSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeSoftSkillCreateOrConnectWithoutResumeInput | ResumeSoftSkillCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeSoftSkillUpsertWithWhereUniqueWithoutResumeInput | ResumeSoftSkillUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeSoftSkillCreateManyResumeInputEnvelope
    set?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    disconnect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    delete?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    connect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    update?: ResumeSoftSkillUpdateWithWhereUniqueWithoutResumeInput | ResumeSoftSkillUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeSoftSkillUpdateManyWithWhereWithoutResumeInput | ResumeSoftSkillUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeSoftSkillScalarWhereInput | ResumeSoftSkillScalarWhereInput[]
  }

  export type ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeCiapCourseCreateWithoutResumeInput, ResumeCiapCourseUncheckedCreateWithoutResumeInput> | ResumeCiapCourseCreateWithoutResumeInput[] | ResumeCiapCourseUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeCiapCourseCreateOrConnectWithoutResumeInput | ResumeCiapCourseCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeCiapCourseUpsertWithWhereUniqueWithoutResumeInput | ResumeCiapCourseUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeCiapCourseCreateManyResumeInputEnvelope
    set?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    disconnect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    delete?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    connect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    update?: ResumeCiapCourseUpdateWithWhereUniqueWithoutResumeInput | ResumeCiapCourseUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeCiapCourseUpdateManyWithWhereWithoutResumeInput | ResumeCiapCourseUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeCiapCourseScalarWhereInput | ResumeCiapCourseScalarWhereInput[]
  }

  export type PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<PositionOfInterestCreateWithoutResumeInput, PositionOfInterestUncheckedCreateWithoutResumeInput> | PositionOfInterestCreateWithoutResumeInput[] | PositionOfInterestUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PositionOfInterestCreateOrConnectWithoutResumeInput | PositionOfInterestCreateOrConnectWithoutResumeInput[]
    upsert?: PositionOfInterestUpsertWithWhereUniqueWithoutResumeInput | PositionOfInterestUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: PositionOfInterestCreateManyResumeInputEnvelope
    set?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
    disconnect?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
    delete?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
    connect?: PositionOfInterestWhereUniqueInput | PositionOfInterestWhereUniqueInput[]
    update?: PositionOfInterestUpdateWithWhereUniqueWithoutResumeInput | PositionOfInterestUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: PositionOfInterestUpdateManyWithWhereWithoutResumeInput | PositionOfInterestUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: PositionOfInterestScalarWhereInput | PositionOfInterestScalarWhereInput[]
  }

  export type IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<IndustryOfInterestCreateWithoutResumeInput, IndustryOfInterestUncheckedCreateWithoutResumeInput> | IndustryOfInterestCreateWithoutResumeInput[] | IndustryOfInterestUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: IndustryOfInterestCreateOrConnectWithoutResumeInput | IndustryOfInterestCreateOrConnectWithoutResumeInput[]
    upsert?: IndustryOfInterestUpsertWithWhereUniqueWithoutResumeInput | IndustryOfInterestUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: IndustryOfInterestCreateManyResumeInputEnvelope
    set?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
    disconnect?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
    delete?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
    connect?: IndustryOfInterestWhereUniqueInput | IndustryOfInterestWhereUniqueInput[]
    update?: IndustryOfInterestUpdateWithWhereUniqueWithoutResumeInput | IndustryOfInterestUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: IndustryOfInterestUpdateManyWithWhereWithoutResumeInput | IndustryOfInterestUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: IndustryOfInterestScalarWhereInput | IndustryOfInterestScalarWhereInput[]
  }

  export type ResumeCiapCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<ResumeCiapCourseCreateWithoutCourseInput, ResumeCiapCourseUncheckedCreateWithoutCourseInput> | ResumeCiapCourseCreateWithoutCourseInput[] | ResumeCiapCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ResumeCiapCourseCreateOrConnectWithoutCourseInput | ResumeCiapCourseCreateOrConnectWithoutCourseInput[]
    createMany?: ResumeCiapCourseCreateManyCourseInputEnvelope
    connect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
  }

  export type ResumeCiapCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ResumeCiapCourseCreateWithoutCourseInput, ResumeCiapCourseUncheckedCreateWithoutCourseInput> | ResumeCiapCourseCreateWithoutCourseInput[] | ResumeCiapCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ResumeCiapCourseCreateOrConnectWithoutCourseInput | ResumeCiapCourseCreateOrConnectWithoutCourseInput[]
    createMany?: ResumeCiapCourseCreateManyCourseInputEnvelope
    connect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
  }

  export type ResumeCiapCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ResumeCiapCourseCreateWithoutCourseInput, ResumeCiapCourseUncheckedCreateWithoutCourseInput> | ResumeCiapCourseCreateWithoutCourseInput[] | ResumeCiapCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ResumeCiapCourseCreateOrConnectWithoutCourseInput | ResumeCiapCourseCreateOrConnectWithoutCourseInput[]
    upsert?: ResumeCiapCourseUpsertWithWhereUniqueWithoutCourseInput | ResumeCiapCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ResumeCiapCourseCreateManyCourseInputEnvelope
    set?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    disconnect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    delete?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    connect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    update?: ResumeCiapCourseUpdateWithWhereUniqueWithoutCourseInput | ResumeCiapCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ResumeCiapCourseUpdateManyWithWhereWithoutCourseInput | ResumeCiapCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ResumeCiapCourseScalarWhereInput | ResumeCiapCourseScalarWhereInput[]
  }

  export type ResumeCiapCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ResumeCiapCourseCreateWithoutCourseInput, ResumeCiapCourseUncheckedCreateWithoutCourseInput> | ResumeCiapCourseCreateWithoutCourseInput[] | ResumeCiapCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ResumeCiapCourseCreateOrConnectWithoutCourseInput | ResumeCiapCourseCreateOrConnectWithoutCourseInput[]
    upsert?: ResumeCiapCourseUpsertWithWhereUniqueWithoutCourseInput | ResumeCiapCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ResumeCiapCourseCreateManyCourseInputEnvelope
    set?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    disconnect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    delete?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    connect?: ResumeCiapCourseWhereUniqueInput | ResumeCiapCourseWhereUniqueInput[]
    update?: ResumeCiapCourseUpdateWithWhereUniqueWithoutCourseInput | ResumeCiapCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ResumeCiapCourseUpdateManyWithWhereWithoutCourseInput | ResumeCiapCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ResumeCiapCourseScalarWhereInput | ResumeCiapCourseScalarWhereInput[]
  }

  export type ResumeCreateNestedOneWithoutCiapCoursesInput = {
    create?: XOR<ResumeCreateWithoutCiapCoursesInput, ResumeUncheckedCreateWithoutCiapCoursesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutCiapCoursesInput
    connect?: ResumeWhereUniqueInput
  }

  export type CiapCourseCreateNestedOneWithoutResumesListingThisInput = {
    create?: XOR<CiapCourseCreateWithoutResumesListingThisInput, CiapCourseUncheckedCreateWithoutResumesListingThisInput>
    connectOrCreate?: CiapCourseCreateOrConnectWithoutResumesListingThisInput
    connect?: CiapCourseWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutCiapCoursesNestedInput = {
    create?: XOR<ResumeCreateWithoutCiapCoursesInput, ResumeUncheckedCreateWithoutCiapCoursesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutCiapCoursesInput
    upsert?: ResumeUpsertWithoutCiapCoursesInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutCiapCoursesInput, ResumeUpdateWithoutCiapCoursesInput>, ResumeUncheckedUpdateWithoutCiapCoursesInput>
  }

  export type CiapCourseUpdateOneRequiredWithoutResumesListingThisNestedInput = {
    create?: XOR<CiapCourseCreateWithoutResumesListingThisInput, CiapCourseUncheckedCreateWithoutResumesListingThisInput>
    connectOrCreate?: CiapCourseCreateOrConnectWithoutResumesListingThisInput
    upsert?: CiapCourseUpsertWithoutResumesListingThisInput
    connect?: CiapCourseWhereUniqueInput
    update?: XOR<XOR<CiapCourseUpdateToOneWithWhereWithoutResumesListingThisInput, CiapCourseUpdateWithoutResumesListingThisInput>, CiapCourseUncheckedUpdateWithoutResumesListingThisInput>
  }

  export type ResumeSoftSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<ResumeSoftSkillCreateWithoutSkillInput, ResumeSoftSkillUncheckedCreateWithoutSkillInput> | ResumeSoftSkillCreateWithoutSkillInput[] | ResumeSoftSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ResumeSoftSkillCreateOrConnectWithoutSkillInput | ResumeSoftSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ResumeSoftSkillCreateManySkillInputEnvelope
    connect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
  }

  export type ResumeSoftSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<ResumeSoftSkillCreateWithoutSkillInput, ResumeSoftSkillUncheckedCreateWithoutSkillInput> | ResumeSoftSkillCreateWithoutSkillInput[] | ResumeSoftSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ResumeSoftSkillCreateOrConnectWithoutSkillInput | ResumeSoftSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ResumeSoftSkillCreateManySkillInputEnvelope
    connect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
  }

  export type ResumeSoftSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ResumeSoftSkillCreateWithoutSkillInput, ResumeSoftSkillUncheckedCreateWithoutSkillInput> | ResumeSoftSkillCreateWithoutSkillInput[] | ResumeSoftSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ResumeSoftSkillCreateOrConnectWithoutSkillInput | ResumeSoftSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ResumeSoftSkillUpsertWithWhereUniqueWithoutSkillInput | ResumeSoftSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ResumeSoftSkillCreateManySkillInputEnvelope
    set?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    disconnect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    delete?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    connect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    update?: ResumeSoftSkillUpdateWithWhereUniqueWithoutSkillInput | ResumeSoftSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ResumeSoftSkillUpdateManyWithWhereWithoutSkillInput | ResumeSoftSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ResumeSoftSkillScalarWhereInput | ResumeSoftSkillScalarWhereInput[]
  }

  export type ResumeSoftSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ResumeSoftSkillCreateWithoutSkillInput, ResumeSoftSkillUncheckedCreateWithoutSkillInput> | ResumeSoftSkillCreateWithoutSkillInput[] | ResumeSoftSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ResumeSoftSkillCreateOrConnectWithoutSkillInput | ResumeSoftSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ResumeSoftSkillUpsertWithWhereUniqueWithoutSkillInput | ResumeSoftSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ResumeSoftSkillCreateManySkillInputEnvelope
    set?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    disconnect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    delete?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    connect?: ResumeSoftSkillWhereUniqueInput | ResumeSoftSkillWhereUniqueInput[]
    update?: ResumeSoftSkillUpdateWithWhereUniqueWithoutSkillInput | ResumeSoftSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ResumeSoftSkillUpdateManyWithWhereWithoutSkillInput | ResumeSoftSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ResumeSoftSkillScalarWhereInput | ResumeSoftSkillScalarWhereInput[]
  }

  export type ResumeCreateNestedOneWithoutSoftSkillsInput = {
    create?: XOR<ResumeCreateWithoutSoftSkillsInput, ResumeUncheckedCreateWithoutSoftSkillsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutSoftSkillsInput
    connect?: ResumeWhereUniqueInput
  }

  export type SoftSkillCreateNestedOneWithoutResumesListingThisInput = {
    create?: XOR<SoftSkillCreateWithoutResumesListingThisInput, SoftSkillUncheckedCreateWithoutResumesListingThisInput>
    connectOrCreate?: SoftSkillCreateOrConnectWithoutResumesListingThisInput
    connect?: SoftSkillWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutSoftSkillsNestedInput = {
    create?: XOR<ResumeCreateWithoutSoftSkillsInput, ResumeUncheckedCreateWithoutSoftSkillsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutSoftSkillsInput
    upsert?: ResumeUpsertWithoutSoftSkillsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutSoftSkillsInput, ResumeUpdateWithoutSoftSkillsInput>, ResumeUncheckedUpdateWithoutSoftSkillsInput>
  }

  export type SoftSkillUpdateOneRequiredWithoutResumesListingThisNestedInput = {
    create?: XOR<SoftSkillCreateWithoutResumesListingThisInput, SoftSkillUncheckedCreateWithoutResumesListingThisInput>
    connectOrCreate?: SoftSkillCreateOrConnectWithoutResumesListingThisInput
    upsert?: SoftSkillUpsertWithoutResumesListingThisInput
    connect?: SoftSkillWhereUniqueInput
    update?: XOR<XOR<SoftSkillUpdateToOneWithWhereWithoutResumesListingThisInput, SoftSkillUpdateWithoutResumesListingThisInput>, SoftSkillUncheckedUpdateWithoutResumesListingThisInput>
  }

  export type TechnicalSkillCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TechnicalSkillCreateWithoutCategoryInput, TechnicalSkillUncheckedCreateWithoutCategoryInput> | TechnicalSkillCreateWithoutCategoryInput[] | TechnicalSkillUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TechnicalSkillCreateOrConnectWithoutCategoryInput | TechnicalSkillCreateOrConnectWithoutCategoryInput[]
    createMany?: TechnicalSkillCreateManyCategoryInputEnvelope
    connect?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
  }

  export type CareerCreateNestedManyWithoutSkillCategoriesInput = {
    create?: XOR<CareerCreateWithoutSkillCategoriesInput, CareerUncheckedCreateWithoutSkillCategoriesInput> | CareerCreateWithoutSkillCategoriesInput[] | CareerUncheckedCreateWithoutSkillCategoriesInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutSkillCategoriesInput | CareerCreateOrConnectWithoutSkillCategoriesInput[]
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
  }

  export type TechnicalSkillUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TechnicalSkillCreateWithoutCategoryInput, TechnicalSkillUncheckedCreateWithoutCategoryInput> | TechnicalSkillCreateWithoutCategoryInput[] | TechnicalSkillUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TechnicalSkillCreateOrConnectWithoutCategoryInput | TechnicalSkillCreateOrConnectWithoutCategoryInput[]
    createMany?: TechnicalSkillCreateManyCategoryInputEnvelope
    connect?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
  }

  export type CareerUncheckedCreateNestedManyWithoutSkillCategoriesInput = {
    create?: XOR<CareerCreateWithoutSkillCategoriesInput, CareerUncheckedCreateWithoutSkillCategoriesInput> | CareerCreateWithoutSkillCategoriesInput[] | CareerUncheckedCreateWithoutSkillCategoriesInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutSkillCategoriesInput | CareerCreateOrConnectWithoutSkillCategoriesInput[]
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
  }

  export type TechnicalSkillUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TechnicalSkillCreateWithoutCategoryInput, TechnicalSkillUncheckedCreateWithoutCategoryInput> | TechnicalSkillCreateWithoutCategoryInput[] | TechnicalSkillUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TechnicalSkillCreateOrConnectWithoutCategoryInput | TechnicalSkillCreateOrConnectWithoutCategoryInput[]
    upsert?: TechnicalSkillUpsertWithWhereUniqueWithoutCategoryInput | TechnicalSkillUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TechnicalSkillCreateManyCategoryInputEnvelope
    set?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
    disconnect?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
    delete?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
    connect?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
    update?: TechnicalSkillUpdateWithWhereUniqueWithoutCategoryInput | TechnicalSkillUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TechnicalSkillUpdateManyWithWhereWithoutCategoryInput | TechnicalSkillUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TechnicalSkillScalarWhereInput | TechnicalSkillScalarWhereInput[]
  }

  export type CareerUpdateManyWithoutSkillCategoriesNestedInput = {
    create?: XOR<CareerCreateWithoutSkillCategoriesInput, CareerUncheckedCreateWithoutSkillCategoriesInput> | CareerCreateWithoutSkillCategoriesInput[] | CareerUncheckedCreateWithoutSkillCategoriesInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutSkillCategoriesInput | CareerCreateOrConnectWithoutSkillCategoriesInput[]
    upsert?: CareerUpsertWithWhereUniqueWithoutSkillCategoriesInput | CareerUpsertWithWhereUniqueWithoutSkillCategoriesInput[]
    set?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    disconnect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    delete?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    update?: CareerUpdateWithWhereUniqueWithoutSkillCategoriesInput | CareerUpdateWithWhereUniqueWithoutSkillCategoriesInput[]
    updateMany?: CareerUpdateManyWithWhereWithoutSkillCategoriesInput | CareerUpdateManyWithWhereWithoutSkillCategoriesInput[]
    deleteMany?: CareerScalarWhereInput | CareerScalarWhereInput[]
  }

  export type TechnicalSkillUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TechnicalSkillCreateWithoutCategoryInput, TechnicalSkillUncheckedCreateWithoutCategoryInput> | TechnicalSkillCreateWithoutCategoryInput[] | TechnicalSkillUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TechnicalSkillCreateOrConnectWithoutCategoryInput | TechnicalSkillCreateOrConnectWithoutCategoryInput[]
    upsert?: TechnicalSkillUpsertWithWhereUniqueWithoutCategoryInput | TechnicalSkillUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TechnicalSkillCreateManyCategoryInputEnvelope
    set?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
    disconnect?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
    delete?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
    connect?: TechnicalSkillWhereUniqueInput | TechnicalSkillWhereUniqueInput[]
    update?: TechnicalSkillUpdateWithWhereUniqueWithoutCategoryInput | TechnicalSkillUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TechnicalSkillUpdateManyWithWhereWithoutCategoryInput | TechnicalSkillUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TechnicalSkillScalarWhereInput | TechnicalSkillScalarWhereInput[]
  }

  export type CareerUncheckedUpdateManyWithoutSkillCategoriesNestedInput = {
    create?: XOR<CareerCreateWithoutSkillCategoriesInput, CareerUncheckedCreateWithoutSkillCategoriesInput> | CareerCreateWithoutSkillCategoriesInput[] | CareerUncheckedCreateWithoutSkillCategoriesInput[]
    connectOrCreate?: CareerCreateOrConnectWithoutSkillCategoriesInput | CareerCreateOrConnectWithoutSkillCategoriesInput[]
    upsert?: CareerUpsertWithWhereUniqueWithoutSkillCategoriesInput | CareerUpsertWithWhereUniqueWithoutSkillCategoriesInput[]
    set?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    disconnect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    delete?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    connect?: CareerWhereUniqueInput | CareerWhereUniqueInput[]
    update?: CareerUpdateWithWhereUniqueWithoutSkillCategoriesInput | CareerUpdateWithWhereUniqueWithoutSkillCategoriesInput[]
    updateMany?: CareerUpdateManyWithWhereWithoutSkillCategoriesInput | CareerUpdateManyWithWhereWithoutSkillCategoriesInput[]
    deleteMany?: CareerScalarWhereInput | CareerScalarWhereInput[]
  }

  export type SkillCategoryCreateNestedOneWithoutTechnicalSkillsInput = {
    create?: XOR<SkillCategoryCreateWithoutTechnicalSkillsInput, SkillCategoryUncheckedCreateWithoutTechnicalSkillsInput>
    connectOrCreate?: SkillCategoryCreateOrConnectWithoutTechnicalSkillsInput
    connect?: SkillCategoryWhereUniqueInput
  }

  export type ResumeTechnicalSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<ResumeTechnicalSkillCreateWithoutSkillInput, ResumeTechnicalSkillUncheckedCreateWithoutSkillInput> | ResumeTechnicalSkillCreateWithoutSkillInput[] | ResumeTechnicalSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ResumeTechnicalSkillCreateOrConnectWithoutSkillInput | ResumeTechnicalSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ResumeTechnicalSkillCreateManySkillInputEnvelope
    connect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
  }

  export type JobOfferTechnicalSkillCreateNestedManyWithoutTechnicalSkillInput = {
    create?: XOR<JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput, JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput> | JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput[] | JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput[]
    connectOrCreate?: JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput | JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput[]
    createMany?: JobOfferTechnicalSkillCreateManyTechnicalSkillInputEnvelope
    connect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
  }

  export type ResumeTechnicalSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<ResumeTechnicalSkillCreateWithoutSkillInput, ResumeTechnicalSkillUncheckedCreateWithoutSkillInput> | ResumeTechnicalSkillCreateWithoutSkillInput[] | ResumeTechnicalSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ResumeTechnicalSkillCreateOrConnectWithoutSkillInput | ResumeTechnicalSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ResumeTechnicalSkillCreateManySkillInputEnvelope
    connect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
  }

  export type JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutTechnicalSkillInput = {
    create?: XOR<JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput, JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput> | JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput[] | JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput[]
    connectOrCreate?: JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput | JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput[]
    createMany?: JobOfferTechnicalSkillCreateManyTechnicalSkillInputEnvelope
    connect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
  }

  export type SkillCategoryUpdateOneRequiredWithoutTechnicalSkillsNestedInput = {
    create?: XOR<SkillCategoryCreateWithoutTechnicalSkillsInput, SkillCategoryUncheckedCreateWithoutTechnicalSkillsInput>
    connectOrCreate?: SkillCategoryCreateOrConnectWithoutTechnicalSkillsInput
    upsert?: SkillCategoryUpsertWithoutTechnicalSkillsInput
    connect?: SkillCategoryWhereUniqueInput
    update?: XOR<XOR<SkillCategoryUpdateToOneWithWhereWithoutTechnicalSkillsInput, SkillCategoryUpdateWithoutTechnicalSkillsInput>, SkillCategoryUncheckedUpdateWithoutTechnicalSkillsInput>
  }

  export type ResumeTechnicalSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ResumeTechnicalSkillCreateWithoutSkillInput, ResumeTechnicalSkillUncheckedCreateWithoutSkillInput> | ResumeTechnicalSkillCreateWithoutSkillInput[] | ResumeTechnicalSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ResumeTechnicalSkillCreateOrConnectWithoutSkillInput | ResumeTechnicalSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ResumeTechnicalSkillUpsertWithWhereUniqueWithoutSkillInput | ResumeTechnicalSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ResumeTechnicalSkillCreateManySkillInputEnvelope
    set?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    disconnect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    delete?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    connect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    update?: ResumeTechnicalSkillUpdateWithWhereUniqueWithoutSkillInput | ResumeTechnicalSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ResumeTechnicalSkillUpdateManyWithWhereWithoutSkillInput | ResumeTechnicalSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ResumeTechnicalSkillScalarWhereInput | ResumeTechnicalSkillScalarWhereInput[]
  }

  export type JobOfferTechnicalSkillUpdateManyWithoutTechnicalSkillNestedInput = {
    create?: XOR<JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput, JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput> | JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput[] | JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput[]
    connectOrCreate?: JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput | JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput[]
    upsert?: JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutTechnicalSkillInput | JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutTechnicalSkillInput[]
    createMany?: JobOfferTechnicalSkillCreateManyTechnicalSkillInputEnvelope
    set?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    disconnect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    delete?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    connect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    update?: JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutTechnicalSkillInput | JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutTechnicalSkillInput[]
    updateMany?: JobOfferTechnicalSkillUpdateManyWithWhereWithoutTechnicalSkillInput | JobOfferTechnicalSkillUpdateManyWithWhereWithoutTechnicalSkillInput[]
    deleteMany?: JobOfferTechnicalSkillScalarWhereInput | JobOfferTechnicalSkillScalarWhereInput[]
  }

  export type ResumeTechnicalSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ResumeTechnicalSkillCreateWithoutSkillInput, ResumeTechnicalSkillUncheckedCreateWithoutSkillInput> | ResumeTechnicalSkillCreateWithoutSkillInput[] | ResumeTechnicalSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ResumeTechnicalSkillCreateOrConnectWithoutSkillInput | ResumeTechnicalSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ResumeTechnicalSkillUpsertWithWhereUniqueWithoutSkillInput | ResumeTechnicalSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ResumeTechnicalSkillCreateManySkillInputEnvelope
    set?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    disconnect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    delete?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    connect?: ResumeTechnicalSkillWhereUniqueInput | ResumeTechnicalSkillWhereUniqueInput[]
    update?: ResumeTechnicalSkillUpdateWithWhereUniqueWithoutSkillInput | ResumeTechnicalSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ResumeTechnicalSkillUpdateManyWithWhereWithoutSkillInput | ResumeTechnicalSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ResumeTechnicalSkillScalarWhereInput | ResumeTechnicalSkillScalarWhereInput[]
  }

  export type JobOfferTechnicalSkillUncheckedUpdateManyWithoutTechnicalSkillNestedInput = {
    create?: XOR<JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput, JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput> | JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput[] | JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput[]
    connectOrCreate?: JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput | JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput[]
    upsert?: JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutTechnicalSkillInput | JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutTechnicalSkillInput[]
    createMany?: JobOfferTechnicalSkillCreateManyTechnicalSkillInputEnvelope
    set?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    disconnect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    delete?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    connect?: JobOfferTechnicalSkillWhereUniqueInput | JobOfferTechnicalSkillWhereUniqueInput[]
    update?: JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutTechnicalSkillInput | JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutTechnicalSkillInput[]
    updateMany?: JobOfferTechnicalSkillUpdateManyWithWhereWithoutTechnicalSkillInput | JobOfferTechnicalSkillUpdateManyWithWhereWithoutTechnicalSkillInput[]
    deleteMany?: JobOfferTechnicalSkillScalarWhereInput | JobOfferTechnicalSkillScalarWhereInput[]
  }

  export type ResumeCreateNestedOneWithoutTechnicalSkillsInput = {
    create?: XOR<ResumeCreateWithoutTechnicalSkillsInput, ResumeUncheckedCreateWithoutTechnicalSkillsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTechnicalSkillsInput
    connect?: ResumeWhereUniqueInput
  }

  export type TechnicalSkillCreateNestedOneWithoutResumesListingThisInput = {
    create?: XOR<TechnicalSkillCreateWithoutResumesListingThisInput, TechnicalSkillUncheckedCreateWithoutResumesListingThisInput>
    connectOrCreate?: TechnicalSkillCreateOrConnectWithoutResumesListingThisInput
    connect?: TechnicalSkillWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutTechnicalSkillsNestedInput = {
    create?: XOR<ResumeCreateWithoutTechnicalSkillsInput, ResumeUncheckedCreateWithoutTechnicalSkillsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTechnicalSkillsInput
    upsert?: ResumeUpsertWithoutTechnicalSkillsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutTechnicalSkillsInput, ResumeUpdateWithoutTechnicalSkillsInput>, ResumeUncheckedUpdateWithoutTechnicalSkillsInput>
  }

  export type TechnicalSkillUpdateOneRequiredWithoutResumesListingThisNestedInput = {
    create?: XOR<TechnicalSkillCreateWithoutResumesListingThisInput, TechnicalSkillUncheckedCreateWithoutResumesListingThisInput>
    connectOrCreate?: TechnicalSkillCreateOrConnectWithoutResumesListingThisInput
    upsert?: TechnicalSkillUpsertWithoutResumesListingThisInput
    connect?: TechnicalSkillWhereUniqueInput
    update?: XOR<XOR<TechnicalSkillUpdateToOneWithWhereWithoutResumesListingThisInput, TechnicalSkillUpdateWithoutResumesListingThisInput>, TechnicalSkillUncheckedUpdateWithoutResumesListingThisInput>
  }

  export type ResumeLanguageCreateNestedManyWithoutLanguageInput = {
    create?: XOR<ResumeLanguageCreateWithoutLanguageInput, ResumeLanguageUncheckedCreateWithoutLanguageInput> | ResumeLanguageCreateWithoutLanguageInput[] | ResumeLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ResumeLanguageCreateOrConnectWithoutLanguageInput | ResumeLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: ResumeLanguageCreateManyLanguageInputEnvelope
    connect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
  }

  export type ResumeLanguageUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<ResumeLanguageCreateWithoutLanguageInput, ResumeLanguageUncheckedCreateWithoutLanguageInput> | ResumeLanguageCreateWithoutLanguageInput[] | ResumeLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ResumeLanguageCreateOrConnectWithoutLanguageInput | ResumeLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: ResumeLanguageCreateManyLanguageInputEnvelope
    connect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
  }

  export type ResumeLanguageUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<ResumeLanguageCreateWithoutLanguageInput, ResumeLanguageUncheckedCreateWithoutLanguageInput> | ResumeLanguageCreateWithoutLanguageInput[] | ResumeLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ResumeLanguageCreateOrConnectWithoutLanguageInput | ResumeLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: ResumeLanguageUpsertWithWhereUniqueWithoutLanguageInput | ResumeLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: ResumeLanguageCreateManyLanguageInputEnvelope
    set?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    disconnect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    delete?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    connect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    update?: ResumeLanguageUpdateWithWhereUniqueWithoutLanguageInput | ResumeLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: ResumeLanguageUpdateManyWithWhereWithoutLanguageInput | ResumeLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: ResumeLanguageScalarWhereInput | ResumeLanguageScalarWhereInput[]
  }

  export type ResumeLanguageUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<ResumeLanguageCreateWithoutLanguageInput, ResumeLanguageUncheckedCreateWithoutLanguageInput> | ResumeLanguageCreateWithoutLanguageInput[] | ResumeLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: ResumeLanguageCreateOrConnectWithoutLanguageInput | ResumeLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: ResumeLanguageUpsertWithWhereUniqueWithoutLanguageInput | ResumeLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: ResumeLanguageCreateManyLanguageInputEnvelope
    set?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    disconnect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    delete?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    connect?: ResumeLanguageWhereUniqueInput | ResumeLanguageWhereUniqueInput[]
    update?: ResumeLanguageUpdateWithWhereUniqueWithoutLanguageInput | ResumeLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: ResumeLanguageUpdateManyWithWhereWithoutLanguageInput | ResumeLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: ResumeLanguageScalarWhereInput | ResumeLanguageScalarWhereInput[]
  }

  export type ResumeCreateNestedOneWithoutKnownLanguagesInput = {
    create?: XOR<ResumeCreateWithoutKnownLanguagesInput, ResumeUncheckedCreateWithoutKnownLanguagesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutKnownLanguagesInput
    connect?: ResumeWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutKnownByInput = {
    create?: XOR<LanguageCreateWithoutKnownByInput, LanguageUncheckedCreateWithoutKnownByInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutKnownByInput
    connect?: LanguageWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutKnownLanguagesNestedInput = {
    create?: XOR<ResumeCreateWithoutKnownLanguagesInput, ResumeUncheckedCreateWithoutKnownLanguagesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutKnownLanguagesInput
    upsert?: ResumeUpsertWithoutKnownLanguagesInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutKnownLanguagesInput, ResumeUpdateWithoutKnownLanguagesInput>, ResumeUncheckedUpdateWithoutKnownLanguagesInput>
  }

  export type LanguageUpdateOneRequiredWithoutKnownByNestedInput = {
    create?: XOR<LanguageCreateWithoutKnownByInput, LanguageUncheckedCreateWithoutKnownByInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutKnownByInput
    upsert?: LanguageUpsertWithoutKnownByInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutKnownByInput, LanguageUpdateWithoutKnownByInput>, LanguageUncheckedUpdateWithoutKnownByInput>
  }

  export type ResumeCreateNestedOneWithoutPortfolioInput = {
    create?: XOR<ResumeCreateWithoutPortfolioInput, ResumeUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutPortfolioInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutPortfolioNestedInput = {
    create?: XOR<ResumeCreateWithoutPortfolioInput, ResumeUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutPortfolioInput
    upsert?: ResumeUpsertWithoutPortfolioInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutPortfolioInput, ResumeUpdateWithoutPortfolioInput>, ResumeUncheckedUpdateWithoutPortfolioInput>
  }

  export type ResumeCreateNestedOneWithoutHigherEducationStudiesInput = {
    create?: XOR<ResumeCreateWithoutHigherEducationStudiesInput, ResumeUncheckedCreateWithoutHigherEducationStudiesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutHigherEducationStudiesInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutHigherEducationStudiesNestedInput = {
    create?: XOR<ResumeCreateWithoutHigherEducationStudiesInput, ResumeUncheckedCreateWithoutHigherEducationStudiesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutHigherEducationStudiesInput
    upsert?: ResumeUpsertWithoutHigherEducationStudiesInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutHigherEducationStudiesInput, ResumeUpdateWithoutHigherEducationStudiesInput>, ResumeUncheckedUpdateWithoutHigherEducationStudiesInput>
  }

  export type ResumeCreateNestedOneWithoutPositionsOfInterestInput = {
    create?: XOR<ResumeCreateWithoutPositionsOfInterestInput, ResumeUncheckedCreateWithoutPositionsOfInterestInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutPositionsOfInterestInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutPositionsOfInterestNestedInput = {
    create?: XOR<ResumeCreateWithoutPositionsOfInterestInput, ResumeUncheckedCreateWithoutPositionsOfInterestInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutPositionsOfInterestInput
    upsert?: ResumeUpsertWithoutPositionsOfInterestInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutPositionsOfInterestInput, ResumeUpdateWithoutPositionsOfInterestInput>, ResumeUncheckedUpdateWithoutPositionsOfInterestInput>
  }

  export type ResumeCreateNestedOneWithoutIndustriesOfInterestInput = {
    create?: XOR<ResumeCreateWithoutIndustriesOfInterestInput, ResumeUncheckedCreateWithoutIndustriesOfInterestInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutIndustriesOfInterestInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutIndustriesOfInterestNestedInput = {
    create?: XOR<ResumeCreateWithoutIndustriesOfInterestInput, ResumeUncheckedCreateWithoutIndustriesOfInterestInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutIndustriesOfInterestInput
    upsert?: ResumeUpsertWithoutIndustriesOfInterestInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutIndustriesOfInterestInput, ResumeUpdateWithoutIndustriesOfInterestInput>, ResumeUncheckedUpdateWithoutIndustriesOfInterestInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CareerCreateWithoutJobOffersInput = {
    name: string
    graduations?: GraduationCreateNestedManyWithoutCareerInput
    skillCategories?: SkillCategoryCreateNestedManyWithoutRelatedCareersInput
  }

  export type CareerUncheckedCreateWithoutJobOffersInput = {
    name: string
    graduations?: GraduationUncheckedCreateNestedManyWithoutCareerInput
    skillCategories?: SkillCategoryUncheckedCreateNestedManyWithoutRelatedCareersInput
  }

  export type CareerCreateOrConnectWithoutJobOffersInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutJobOffersInput, CareerUncheckedCreateWithoutJobOffersInput>
  }

  export type JobApplicationCreateWithoutJobOfferInput = {
    applicationTimestamp: Date | string
    alumniWhoApplied: AlumniCreateNestedOneWithoutJobApplicationsInput
  }

  export type JobApplicationUncheckedCreateWithoutJobOfferInput = {
    alumniWhoAppliedEmail: string
    applicationTimestamp: Date | string
  }

  export type JobApplicationCreateOrConnectWithoutJobOfferInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutJobOfferInput, JobApplicationUncheckedCreateWithoutJobOfferInput>
  }

  export type JobApplicationCreateManyJobOfferInputEnvelope = {
    data: JobApplicationCreateManyJobOfferInput | JobApplicationCreateManyJobOfferInput[]
    skipDuplicates?: boolean
  }

  export type ContractTypeCreateWithoutContractsOfThisTypeInput = {
    name: string
  }

  export type ContractTypeUncheckedCreateWithoutContractsOfThisTypeInput = {
    name: string
  }

  export type ContractTypeCreateOrConnectWithoutContractsOfThisTypeInput = {
    where: ContractTypeWhereUniqueInput
    create: XOR<ContractTypeCreateWithoutContractsOfThisTypeInput, ContractTypeUncheckedCreateWithoutContractsOfThisTypeInput>
  }

  export type JobOfferTechnicalSkillCreateWithoutJobOfferInput = {
    technicalSkill: TechnicalSkillCreateNestedOneWithoutJobOffersListingThisInput
  }

  export type JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput = {
    technicalSkillName: string
    technicalSkillCategoryName: string
  }

  export type JobOfferTechnicalSkillCreateOrConnectWithoutJobOfferInput = {
    where: JobOfferTechnicalSkillWhereUniqueInput
    create: XOR<JobOfferTechnicalSkillCreateWithoutJobOfferInput, JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput>
  }

  export type JobOfferTechnicalSkillCreateManyJobOfferInputEnvelope = {
    data: JobOfferTechnicalSkillCreateManyJobOfferInput | JobOfferTechnicalSkillCreateManyJobOfferInput[]
    skipDuplicates?: boolean
  }

  export type CareerUpsertWithoutJobOffersInput = {
    update: XOR<CareerUpdateWithoutJobOffersInput, CareerUncheckedUpdateWithoutJobOffersInput>
    create: XOR<CareerCreateWithoutJobOffersInput, CareerUncheckedCreateWithoutJobOffersInput>
    where?: CareerWhereInput
  }

  export type CareerUpdateToOneWithWhereWithoutJobOffersInput = {
    where?: CareerWhereInput
    data: XOR<CareerUpdateWithoutJobOffersInput, CareerUncheckedUpdateWithoutJobOffersInput>
  }

  export type CareerUpdateWithoutJobOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    graduations?: GraduationUpdateManyWithoutCareerNestedInput
    skillCategories?: SkillCategoryUpdateManyWithoutRelatedCareersNestedInput
  }

  export type CareerUncheckedUpdateWithoutJobOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    graduations?: GraduationUncheckedUpdateManyWithoutCareerNestedInput
    skillCategories?: SkillCategoryUncheckedUpdateManyWithoutRelatedCareersNestedInput
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutJobOfferInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutJobOfferInput, JobApplicationUncheckedUpdateWithoutJobOfferInput>
    create: XOR<JobApplicationCreateWithoutJobOfferInput, JobApplicationUncheckedCreateWithoutJobOfferInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutJobOfferInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutJobOfferInput, JobApplicationUncheckedUpdateWithoutJobOfferInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutJobOfferInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutJobOfferInput>
  }

  export type JobApplicationScalarWhereInput = {
    AND?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    OR?: JobApplicationScalarWhereInput[]
    NOT?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    jobOfferId?: UuidFilter<"JobApplication"> | string
    alumniWhoAppliedEmail?: StringFilter<"JobApplication"> | string
    applicationTimestamp?: DateTimeFilter<"JobApplication"> | Date | string
  }

  export type ContractTypeUpsertWithoutContractsOfThisTypeInput = {
    update: XOR<ContractTypeUpdateWithoutContractsOfThisTypeInput, ContractTypeUncheckedUpdateWithoutContractsOfThisTypeInput>
    create: XOR<ContractTypeCreateWithoutContractsOfThisTypeInput, ContractTypeUncheckedCreateWithoutContractsOfThisTypeInput>
    where?: ContractTypeWhereInput
  }

  export type ContractTypeUpdateToOneWithWhereWithoutContractsOfThisTypeInput = {
    where?: ContractTypeWhereInput
    data: XOR<ContractTypeUpdateWithoutContractsOfThisTypeInput, ContractTypeUncheckedUpdateWithoutContractsOfThisTypeInput>
  }

  export type ContractTypeUpdateWithoutContractsOfThisTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ContractTypeUncheckedUpdateWithoutContractsOfThisTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutJobOfferInput = {
    where: JobOfferTechnicalSkillWhereUniqueInput
    update: XOR<JobOfferTechnicalSkillUpdateWithoutJobOfferInput, JobOfferTechnicalSkillUncheckedUpdateWithoutJobOfferInput>
    create: XOR<JobOfferTechnicalSkillCreateWithoutJobOfferInput, JobOfferTechnicalSkillUncheckedCreateWithoutJobOfferInput>
  }

  export type JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutJobOfferInput = {
    where: JobOfferTechnicalSkillWhereUniqueInput
    data: XOR<JobOfferTechnicalSkillUpdateWithoutJobOfferInput, JobOfferTechnicalSkillUncheckedUpdateWithoutJobOfferInput>
  }

  export type JobOfferTechnicalSkillUpdateManyWithWhereWithoutJobOfferInput = {
    where: JobOfferTechnicalSkillScalarWhereInput
    data: XOR<JobOfferTechnicalSkillUpdateManyMutationInput, JobOfferTechnicalSkillUncheckedUpdateManyWithoutJobOfferInput>
  }

  export type JobOfferTechnicalSkillScalarWhereInput = {
    AND?: JobOfferTechnicalSkillScalarWhereInput | JobOfferTechnicalSkillScalarWhereInput[]
    OR?: JobOfferTechnicalSkillScalarWhereInput[]
    NOT?: JobOfferTechnicalSkillScalarWhereInput | JobOfferTechnicalSkillScalarWhereInput[]
    jobOfferId?: UuidFilter<"JobOfferTechnicalSkill"> | string
    technicalSkillName?: StringFilter<"JobOfferTechnicalSkill"> | string
    technicalSkillCategoryName?: StringFilter<"JobOfferTechnicalSkill"> | string
  }

  export type JobOfferCreateWithoutTechnicalSkillsInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    career: CareerCreateNestedOneWithoutJobOffersInput
    applications?: JobApplicationCreateNestedManyWithoutJobOfferInput
    contractType: ContractTypeCreateNestedOneWithoutContractsOfThisTypeInput
  }

  export type JobOfferUncheckedCreateWithoutTechnicalSkillsInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    careerName: string
    contractTypeName: string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferCreateOrConnectWithoutTechnicalSkillsInput = {
    where: JobOfferWhereUniqueInput
    create: XOR<JobOfferCreateWithoutTechnicalSkillsInput, JobOfferUncheckedCreateWithoutTechnicalSkillsInput>
  }

  export type TechnicalSkillCreateWithoutJobOffersListingThisInput = {
    name: string
    category: SkillCategoryCreateNestedOneWithoutTechnicalSkillsInput
    resumesListingThis?: ResumeTechnicalSkillCreateNestedManyWithoutSkillInput
  }

  export type TechnicalSkillUncheckedCreateWithoutJobOffersListingThisInput = {
    name: string
    categoryName: string
    resumesListingThis?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type TechnicalSkillCreateOrConnectWithoutJobOffersListingThisInput = {
    where: TechnicalSkillWhereUniqueInput
    create: XOR<TechnicalSkillCreateWithoutJobOffersListingThisInput, TechnicalSkillUncheckedCreateWithoutJobOffersListingThisInput>
  }

  export type JobOfferUpsertWithoutTechnicalSkillsInput = {
    update: XOR<JobOfferUpdateWithoutTechnicalSkillsInput, JobOfferUncheckedUpdateWithoutTechnicalSkillsInput>
    create: XOR<JobOfferCreateWithoutTechnicalSkillsInput, JobOfferUncheckedCreateWithoutTechnicalSkillsInput>
    where?: JobOfferWhereInput
  }

  export type JobOfferUpdateToOneWithWhereWithoutTechnicalSkillsInput = {
    where?: JobOfferWhereInput
    data: XOR<JobOfferUpdateWithoutTechnicalSkillsInput, JobOfferUncheckedUpdateWithoutTechnicalSkillsInput>
  }

  export type JobOfferUpdateWithoutTechnicalSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutJobOffersNestedInput
    applications?: JobApplicationUpdateManyWithoutJobOfferNestedInput
    contractType?: ContractTypeUpdateOneRequiredWithoutContractsOfThisTypeNestedInput
  }

  export type JobOfferUncheckedUpdateWithoutTechnicalSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    careerName?: StringFieldUpdateOperationsInput | string
    contractTypeName?: StringFieldUpdateOperationsInput | string
    applications?: JobApplicationUncheckedUpdateManyWithoutJobOfferNestedInput
  }

  export type TechnicalSkillUpsertWithoutJobOffersListingThisInput = {
    update: XOR<TechnicalSkillUpdateWithoutJobOffersListingThisInput, TechnicalSkillUncheckedUpdateWithoutJobOffersListingThisInput>
    create: XOR<TechnicalSkillCreateWithoutJobOffersListingThisInput, TechnicalSkillUncheckedCreateWithoutJobOffersListingThisInput>
    where?: TechnicalSkillWhereInput
  }

  export type TechnicalSkillUpdateToOneWithWhereWithoutJobOffersListingThisInput = {
    where?: TechnicalSkillWhereInput
    data: XOR<TechnicalSkillUpdateWithoutJobOffersListingThisInput, TechnicalSkillUncheckedUpdateWithoutJobOffersListingThisInput>
  }

  export type TechnicalSkillUpdateWithoutJobOffersListingThisInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: SkillCategoryUpdateOneRequiredWithoutTechnicalSkillsNestedInput
    resumesListingThis?: ResumeTechnicalSkillUpdateManyWithoutSkillNestedInput
  }

  export type TechnicalSkillUncheckedUpdateWithoutJobOffersListingThisInput = {
    name?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    resumesListingThis?: ResumeTechnicalSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type JobOfferCreateWithoutContractTypeInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    career: CareerCreateNestedOneWithoutJobOffersInput
    applications?: JobApplicationCreateNestedManyWithoutJobOfferInput
    technicalSkills?: JobOfferTechnicalSkillCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferUncheckedCreateWithoutContractTypeInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    careerName: string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobOfferInput
    technicalSkills?: JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferCreateOrConnectWithoutContractTypeInput = {
    where: JobOfferWhereUniqueInput
    create: XOR<JobOfferCreateWithoutContractTypeInput, JobOfferUncheckedCreateWithoutContractTypeInput>
  }

  export type JobOfferCreateManyContractTypeInputEnvelope = {
    data: JobOfferCreateManyContractTypeInput | JobOfferCreateManyContractTypeInput[]
    skipDuplicates?: boolean
  }

  export type JobOfferUpsertWithWhereUniqueWithoutContractTypeInput = {
    where: JobOfferWhereUniqueInput
    update: XOR<JobOfferUpdateWithoutContractTypeInput, JobOfferUncheckedUpdateWithoutContractTypeInput>
    create: XOR<JobOfferCreateWithoutContractTypeInput, JobOfferUncheckedCreateWithoutContractTypeInput>
  }

  export type JobOfferUpdateWithWhereUniqueWithoutContractTypeInput = {
    where: JobOfferWhereUniqueInput
    data: XOR<JobOfferUpdateWithoutContractTypeInput, JobOfferUncheckedUpdateWithoutContractTypeInput>
  }

  export type JobOfferUpdateManyWithWhereWithoutContractTypeInput = {
    where: JobOfferScalarWhereInput
    data: XOR<JobOfferUpdateManyMutationInput, JobOfferUncheckedUpdateManyWithoutContractTypeInput>
  }

  export type JobOfferScalarWhereInput = {
    AND?: JobOfferScalarWhereInput | JobOfferScalarWhereInput[]
    OR?: JobOfferScalarWhereInput[]
    NOT?: JobOfferScalarWhereInput | JobOfferScalarWhereInput[]
    id?: UuidFilter<"JobOffer"> | string
    description?: StringFilter<"JobOffer"> | string
    companyName?: StringFilter<"JobOffer"> | string
    companyContact?: StringFilter<"JobOffer"> | string
    companyLogo?: StringFilter<"JobOffer"> | string
    department?: StringFilter<"JobOffer"> | string
    position?: StringFilter<"JobOffer"> | string
    offerLocation?: StringFilter<"JobOffer"> | string
    offerTimestamp?: DateTimeFilter<"JobOffer"> | Date | string
    isVisible?: BoolFilter<"JobOffer"> | boolean
    visibleSince?: DateTimeFilter<"JobOffer"> | Date | string
    careerName?: StringFilter<"JobOffer"> | string
    contractTypeName?: StringFilter<"JobOffer"> | string
  }

  export type JobOfferCreateWithoutCareerInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    applications?: JobApplicationCreateNestedManyWithoutJobOfferInput
    contractType: ContractTypeCreateNestedOneWithoutContractsOfThisTypeInput
    technicalSkills?: JobOfferTechnicalSkillCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferUncheckedCreateWithoutCareerInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    contractTypeName: string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobOfferInput
    technicalSkills?: JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferCreateOrConnectWithoutCareerInput = {
    where: JobOfferWhereUniqueInput
    create: XOR<JobOfferCreateWithoutCareerInput, JobOfferUncheckedCreateWithoutCareerInput>
  }

  export type JobOfferCreateManyCareerInputEnvelope = {
    data: JobOfferCreateManyCareerInput | JobOfferCreateManyCareerInput[]
    skipDuplicates?: boolean
  }

  export type GraduationCreateWithoutCareerInput = {
    graduationDate: Date | string
    alumni: AlumniCreateNestedOneWithoutGraduationsInput
  }

  export type GraduationUncheckedCreateWithoutCareerInput = {
    alumniEmail: string
    graduationDate: Date | string
  }

  export type GraduationCreateOrConnectWithoutCareerInput = {
    where: GraduationWhereUniqueInput
    create: XOR<GraduationCreateWithoutCareerInput, GraduationUncheckedCreateWithoutCareerInput>
  }

  export type GraduationCreateManyCareerInputEnvelope = {
    data: GraduationCreateManyCareerInput | GraduationCreateManyCareerInput[]
    skipDuplicates?: boolean
  }

  export type SkillCategoryCreateWithoutRelatedCareersInput = {
    name: string
    technicalSkills?: TechnicalSkillCreateNestedManyWithoutCategoryInput
  }

  export type SkillCategoryUncheckedCreateWithoutRelatedCareersInput = {
    name: string
    technicalSkills?: TechnicalSkillUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type SkillCategoryCreateOrConnectWithoutRelatedCareersInput = {
    where: SkillCategoryWhereUniqueInput
    create: XOR<SkillCategoryCreateWithoutRelatedCareersInput, SkillCategoryUncheckedCreateWithoutRelatedCareersInput>
  }

  export type JobOfferUpsertWithWhereUniqueWithoutCareerInput = {
    where: JobOfferWhereUniqueInput
    update: XOR<JobOfferUpdateWithoutCareerInput, JobOfferUncheckedUpdateWithoutCareerInput>
    create: XOR<JobOfferCreateWithoutCareerInput, JobOfferUncheckedCreateWithoutCareerInput>
  }

  export type JobOfferUpdateWithWhereUniqueWithoutCareerInput = {
    where: JobOfferWhereUniqueInput
    data: XOR<JobOfferUpdateWithoutCareerInput, JobOfferUncheckedUpdateWithoutCareerInput>
  }

  export type JobOfferUpdateManyWithWhereWithoutCareerInput = {
    where: JobOfferScalarWhereInput
    data: XOR<JobOfferUpdateManyMutationInput, JobOfferUncheckedUpdateManyWithoutCareerInput>
  }

  export type GraduationUpsertWithWhereUniqueWithoutCareerInput = {
    where: GraduationWhereUniqueInput
    update: XOR<GraduationUpdateWithoutCareerInput, GraduationUncheckedUpdateWithoutCareerInput>
    create: XOR<GraduationCreateWithoutCareerInput, GraduationUncheckedCreateWithoutCareerInput>
  }

  export type GraduationUpdateWithWhereUniqueWithoutCareerInput = {
    where: GraduationWhereUniqueInput
    data: XOR<GraduationUpdateWithoutCareerInput, GraduationUncheckedUpdateWithoutCareerInput>
  }

  export type GraduationUpdateManyWithWhereWithoutCareerInput = {
    where: GraduationScalarWhereInput
    data: XOR<GraduationUpdateManyMutationInput, GraduationUncheckedUpdateManyWithoutCareerInput>
  }

  export type GraduationScalarWhereInput = {
    AND?: GraduationScalarWhereInput | GraduationScalarWhereInput[]
    OR?: GraduationScalarWhereInput[]
    NOT?: GraduationScalarWhereInput | GraduationScalarWhereInput[]
    careerName?: StringFilter<"Graduation"> | string
    alumniEmail?: StringFilter<"Graduation"> | string
    graduationDate?: DateTimeFilter<"Graduation"> | Date | string
  }

  export type SkillCategoryUpsertWithWhereUniqueWithoutRelatedCareersInput = {
    where: SkillCategoryWhereUniqueInput
    update: XOR<SkillCategoryUpdateWithoutRelatedCareersInput, SkillCategoryUncheckedUpdateWithoutRelatedCareersInput>
    create: XOR<SkillCategoryCreateWithoutRelatedCareersInput, SkillCategoryUncheckedCreateWithoutRelatedCareersInput>
  }

  export type SkillCategoryUpdateWithWhereUniqueWithoutRelatedCareersInput = {
    where: SkillCategoryWhereUniqueInput
    data: XOR<SkillCategoryUpdateWithoutRelatedCareersInput, SkillCategoryUncheckedUpdateWithoutRelatedCareersInput>
  }

  export type SkillCategoryUpdateManyWithWhereWithoutRelatedCareersInput = {
    where: SkillCategoryScalarWhereInput
    data: XOR<SkillCategoryUpdateManyMutationInput, SkillCategoryUncheckedUpdateManyWithoutRelatedCareersInput>
  }

  export type SkillCategoryScalarWhereInput = {
    AND?: SkillCategoryScalarWhereInput | SkillCategoryScalarWhereInput[]
    OR?: SkillCategoryScalarWhereInput[]
    NOT?: SkillCategoryScalarWhereInput | SkillCategoryScalarWhereInput[]
    name?: StringFilter<"SkillCategory"> | string
  }

  export type AlumniCreateWithoutAssociatedUserInput = {
    address?: string | null
    telephoneNumber?: string | null
    jobApplications?: JobApplicationCreateNestedManyWithoutAlumniWhoAppliedInput
    resume?: ResumeCreateNestedOneWithoutOwnerInput
    graduations?: GraduationCreateNestedManyWithoutAlumniInput
  }

  export type AlumniUncheckedCreateWithoutAssociatedUserInput = {
    address?: string | null
    telephoneNumber?: string | null
    jobApplications?: JobApplicationUncheckedCreateNestedManyWithoutAlumniWhoAppliedInput
    resume?: ResumeUncheckedCreateNestedOneWithoutOwnerInput
    graduations?: GraduationUncheckedCreateNestedManyWithoutAlumniInput
  }

  export type AlumniCreateOrConnectWithoutAssociatedUserInput = {
    where: AlumniWhereUniqueInput
    create: XOR<AlumniCreateWithoutAssociatedUserInput, AlumniUncheckedCreateWithoutAssociatedUserInput>
  }

  export type AlumniUpsertWithoutAssociatedUserInput = {
    update: XOR<AlumniUpdateWithoutAssociatedUserInput, AlumniUncheckedUpdateWithoutAssociatedUserInput>
    create: XOR<AlumniCreateWithoutAssociatedUserInput, AlumniUncheckedCreateWithoutAssociatedUserInput>
    where?: AlumniWhereInput
  }

  export type AlumniUpdateToOneWithWhereWithoutAssociatedUserInput = {
    where?: AlumniWhereInput
    data: XOR<AlumniUpdateWithoutAssociatedUserInput, AlumniUncheckedUpdateWithoutAssociatedUserInput>
  }

  export type AlumniUpdateWithoutAssociatedUserInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    jobApplications?: JobApplicationUpdateManyWithoutAlumniWhoAppliedNestedInput
    resume?: ResumeUpdateOneWithoutOwnerNestedInput
    graduations?: GraduationUpdateManyWithoutAlumniNestedInput
  }

  export type AlumniUncheckedUpdateWithoutAssociatedUserInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    jobApplications?: JobApplicationUncheckedUpdateManyWithoutAlumniWhoAppliedNestedInput
    resume?: ResumeUncheckedUpdateOneWithoutOwnerNestedInput
    graduations?: GraduationUncheckedUpdateManyWithoutAlumniNestedInput
  }

  export type UserCreateWithoutAssociatedAlumniInput = {
    email: string
    password: string
    names: string
    surnames: string
    role: $Enums.Role
  }

  export type UserUncheckedCreateWithoutAssociatedAlumniInput = {
    email: string
    password: string
    names: string
    surnames: string
    role: $Enums.Role
  }

  export type UserCreateOrConnectWithoutAssociatedAlumniInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssociatedAlumniInput, UserUncheckedCreateWithoutAssociatedAlumniInput>
  }

  export type JobApplicationCreateWithoutAlumniWhoAppliedInput = {
    applicationTimestamp: Date | string
    jobOffer: JobOfferCreateNestedOneWithoutApplicationsInput
  }

  export type JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput = {
    jobOfferId: string
    applicationTimestamp: Date | string
  }

  export type JobApplicationCreateOrConnectWithoutAlumniWhoAppliedInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutAlumniWhoAppliedInput, JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput>
  }

  export type JobApplicationCreateManyAlumniWhoAppliedInputEnvelope = {
    data: JobApplicationCreateManyAlumniWhoAppliedInput | JobApplicationCreateManyAlumniWhoAppliedInput[]
    skipDuplicates?: boolean
  }

  export type ResumeCreateWithoutOwnerInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutOwnerInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutOwnerInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutOwnerInput, ResumeUncheckedCreateWithoutOwnerInput>
  }

  export type GraduationCreateWithoutAlumniInput = {
    graduationDate: Date | string
    career: CareerCreateNestedOneWithoutGraduationsInput
  }

  export type GraduationUncheckedCreateWithoutAlumniInput = {
    careerName: string
    graduationDate: Date | string
  }

  export type GraduationCreateOrConnectWithoutAlumniInput = {
    where: GraduationWhereUniqueInput
    create: XOR<GraduationCreateWithoutAlumniInput, GraduationUncheckedCreateWithoutAlumniInput>
  }

  export type GraduationCreateManyAlumniInputEnvelope = {
    data: GraduationCreateManyAlumniInput | GraduationCreateManyAlumniInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssociatedAlumniInput = {
    update: XOR<UserUpdateWithoutAssociatedAlumniInput, UserUncheckedUpdateWithoutAssociatedAlumniInput>
    create: XOR<UserCreateWithoutAssociatedAlumniInput, UserUncheckedCreateWithoutAssociatedAlumniInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssociatedAlumniInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssociatedAlumniInput, UserUncheckedUpdateWithoutAssociatedAlumniInput>
  }

  export type UserUpdateWithoutAssociatedAlumniInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    names?: StringFieldUpdateOperationsInput | string
    surnames?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateWithoutAssociatedAlumniInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    names?: StringFieldUpdateOperationsInput | string
    surnames?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutAlumniWhoAppliedInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutAlumniWhoAppliedInput, JobApplicationUncheckedUpdateWithoutAlumniWhoAppliedInput>
    create: XOR<JobApplicationCreateWithoutAlumniWhoAppliedInput, JobApplicationUncheckedCreateWithoutAlumniWhoAppliedInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutAlumniWhoAppliedInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutAlumniWhoAppliedInput, JobApplicationUncheckedUpdateWithoutAlumniWhoAppliedInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutAlumniWhoAppliedInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutAlumniWhoAppliedInput>
  }

  export type ResumeUpsertWithoutOwnerInput = {
    update: XOR<ResumeUpdateWithoutOwnerInput, ResumeUncheckedUpdateWithoutOwnerInput>
    create: XOR<ResumeCreateWithoutOwnerInput, ResumeUncheckedCreateWithoutOwnerInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutOwnerInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutOwnerInput, ResumeUncheckedUpdateWithoutOwnerInput>
  }

  export type ResumeUpdateWithoutOwnerInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutOwnerInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type GraduationUpsertWithWhereUniqueWithoutAlumniInput = {
    where: GraduationWhereUniqueInput
    update: XOR<GraduationUpdateWithoutAlumniInput, GraduationUncheckedUpdateWithoutAlumniInput>
    create: XOR<GraduationCreateWithoutAlumniInput, GraduationUncheckedCreateWithoutAlumniInput>
  }

  export type GraduationUpdateWithWhereUniqueWithoutAlumniInput = {
    where: GraduationWhereUniqueInput
    data: XOR<GraduationUpdateWithoutAlumniInput, GraduationUncheckedUpdateWithoutAlumniInput>
  }

  export type GraduationUpdateManyWithWhereWithoutAlumniInput = {
    where: GraduationScalarWhereInput
    data: XOR<GraduationUpdateManyMutationInput, GraduationUncheckedUpdateManyWithoutAlumniInput>
  }

  export type CareerCreateWithoutGraduationsInput = {
    name: string
    jobOffers?: JobOfferCreateNestedManyWithoutCareerInput
    skillCategories?: SkillCategoryCreateNestedManyWithoutRelatedCareersInput
  }

  export type CareerUncheckedCreateWithoutGraduationsInput = {
    name: string
    jobOffers?: JobOfferUncheckedCreateNestedManyWithoutCareerInput
    skillCategories?: SkillCategoryUncheckedCreateNestedManyWithoutRelatedCareersInput
  }

  export type CareerCreateOrConnectWithoutGraduationsInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutGraduationsInput, CareerUncheckedCreateWithoutGraduationsInput>
  }

  export type AlumniCreateWithoutGraduationsInput = {
    address?: string | null
    telephoneNumber?: string | null
    associatedUser: UserCreateNestedOneWithoutAssociatedAlumniInput
    jobApplications?: JobApplicationCreateNestedManyWithoutAlumniWhoAppliedInput
    resume?: ResumeCreateNestedOneWithoutOwnerInput
  }

  export type AlumniUncheckedCreateWithoutGraduationsInput = {
    email: string
    address?: string | null
    telephoneNumber?: string | null
    jobApplications?: JobApplicationUncheckedCreateNestedManyWithoutAlumniWhoAppliedInput
    resume?: ResumeUncheckedCreateNestedOneWithoutOwnerInput
  }

  export type AlumniCreateOrConnectWithoutGraduationsInput = {
    where: AlumniWhereUniqueInput
    create: XOR<AlumniCreateWithoutGraduationsInput, AlumniUncheckedCreateWithoutGraduationsInput>
  }

  export type CareerUpsertWithoutGraduationsInput = {
    update: XOR<CareerUpdateWithoutGraduationsInput, CareerUncheckedUpdateWithoutGraduationsInput>
    create: XOR<CareerCreateWithoutGraduationsInput, CareerUncheckedCreateWithoutGraduationsInput>
    where?: CareerWhereInput
  }

  export type CareerUpdateToOneWithWhereWithoutGraduationsInput = {
    where?: CareerWhereInput
    data: XOR<CareerUpdateWithoutGraduationsInput, CareerUncheckedUpdateWithoutGraduationsInput>
  }

  export type CareerUpdateWithoutGraduationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobOffers?: JobOfferUpdateManyWithoutCareerNestedInput
    skillCategories?: SkillCategoryUpdateManyWithoutRelatedCareersNestedInput
  }

  export type CareerUncheckedUpdateWithoutGraduationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobOffers?: JobOfferUncheckedUpdateManyWithoutCareerNestedInput
    skillCategories?: SkillCategoryUncheckedUpdateManyWithoutRelatedCareersNestedInput
  }

  export type AlumniUpsertWithoutGraduationsInput = {
    update: XOR<AlumniUpdateWithoutGraduationsInput, AlumniUncheckedUpdateWithoutGraduationsInput>
    create: XOR<AlumniCreateWithoutGraduationsInput, AlumniUncheckedCreateWithoutGraduationsInput>
    where?: AlumniWhereInput
  }

  export type AlumniUpdateToOneWithWhereWithoutGraduationsInput = {
    where?: AlumniWhereInput
    data: XOR<AlumniUpdateWithoutGraduationsInput, AlumniUncheckedUpdateWithoutGraduationsInput>
  }

  export type AlumniUpdateWithoutGraduationsInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    associatedUser?: UserUpdateOneRequiredWithoutAssociatedAlumniNestedInput
    jobApplications?: JobApplicationUpdateManyWithoutAlumniWhoAppliedNestedInput
    resume?: ResumeUpdateOneWithoutOwnerNestedInput
  }

  export type AlumniUncheckedUpdateWithoutGraduationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    jobApplications?: JobApplicationUncheckedUpdateManyWithoutAlumniWhoAppliedNestedInput
    resume?: ResumeUncheckedUpdateOneWithoutOwnerNestedInput
  }

  export type JobOfferCreateWithoutApplicationsInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    career: CareerCreateNestedOneWithoutJobOffersInput
    contractType: ContractTypeCreateNestedOneWithoutContractsOfThisTypeInput
    technicalSkills?: JobOfferTechnicalSkillCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferUncheckedCreateWithoutApplicationsInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    careerName: string
    contractTypeName: string
    technicalSkills?: JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutJobOfferInput
  }

  export type JobOfferCreateOrConnectWithoutApplicationsInput = {
    where: JobOfferWhereUniqueInput
    create: XOR<JobOfferCreateWithoutApplicationsInput, JobOfferUncheckedCreateWithoutApplicationsInput>
  }

  export type AlumniCreateWithoutJobApplicationsInput = {
    address?: string | null
    telephoneNumber?: string | null
    associatedUser: UserCreateNestedOneWithoutAssociatedAlumniInput
    resume?: ResumeCreateNestedOneWithoutOwnerInput
    graduations?: GraduationCreateNestedManyWithoutAlumniInput
  }

  export type AlumniUncheckedCreateWithoutJobApplicationsInput = {
    email: string
    address?: string | null
    telephoneNumber?: string | null
    resume?: ResumeUncheckedCreateNestedOneWithoutOwnerInput
    graduations?: GraduationUncheckedCreateNestedManyWithoutAlumniInput
  }

  export type AlumniCreateOrConnectWithoutJobApplicationsInput = {
    where: AlumniWhereUniqueInput
    create: XOR<AlumniCreateWithoutJobApplicationsInput, AlumniUncheckedCreateWithoutJobApplicationsInput>
  }

  export type JobOfferUpsertWithoutApplicationsInput = {
    update: XOR<JobOfferUpdateWithoutApplicationsInput, JobOfferUncheckedUpdateWithoutApplicationsInput>
    create: XOR<JobOfferCreateWithoutApplicationsInput, JobOfferUncheckedCreateWithoutApplicationsInput>
    where?: JobOfferWhereInput
  }

  export type JobOfferUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: JobOfferWhereInput
    data: XOR<JobOfferUpdateWithoutApplicationsInput, JobOfferUncheckedUpdateWithoutApplicationsInput>
  }

  export type JobOfferUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutJobOffersNestedInput
    contractType?: ContractTypeUpdateOneRequiredWithoutContractsOfThisTypeNestedInput
    technicalSkills?: JobOfferTechnicalSkillUpdateManyWithoutJobOfferNestedInput
  }

  export type JobOfferUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    careerName?: StringFieldUpdateOperationsInput | string
    contractTypeName?: StringFieldUpdateOperationsInput | string
    technicalSkills?: JobOfferTechnicalSkillUncheckedUpdateManyWithoutJobOfferNestedInput
  }

  export type AlumniUpsertWithoutJobApplicationsInput = {
    update: XOR<AlumniUpdateWithoutJobApplicationsInput, AlumniUncheckedUpdateWithoutJobApplicationsInput>
    create: XOR<AlumniCreateWithoutJobApplicationsInput, AlumniUncheckedCreateWithoutJobApplicationsInput>
    where?: AlumniWhereInput
  }

  export type AlumniUpdateToOneWithWhereWithoutJobApplicationsInput = {
    where?: AlumniWhereInput
    data: XOR<AlumniUpdateWithoutJobApplicationsInput, AlumniUncheckedUpdateWithoutJobApplicationsInput>
  }

  export type AlumniUpdateWithoutJobApplicationsInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    associatedUser?: UserUpdateOneRequiredWithoutAssociatedAlumniNestedInput
    resume?: ResumeUpdateOneWithoutOwnerNestedInput
    graduations?: GraduationUpdateManyWithoutAlumniNestedInput
  }

  export type AlumniUncheckedUpdateWithoutJobApplicationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    resume?: ResumeUncheckedUpdateOneWithoutOwnerNestedInput
    graduations?: GraduationUncheckedUpdateManyWithoutAlumniNestedInput
  }

  export type AlumniCreateWithoutResumeInput = {
    address?: string | null
    telephoneNumber?: string | null
    associatedUser: UserCreateNestedOneWithoutAssociatedAlumniInput
    jobApplications?: JobApplicationCreateNestedManyWithoutAlumniWhoAppliedInput
    graduations?: GraduationCreateNestedManyWithoutAlumniInput
  }

  export type AlumniUncheckedCreateWithoutResumeInput = {
    email: string
    address?: string | null
    telephoneNumber?: string | null
    jobApplications?: JobApplicationUncheckedCreateNestedManyWithoutAlumniWhoAppliedInput
    graduations?: GraduationUncheckedCreateNestedManyWithoutAlumniInput
  }

  export type AlumniCreateOrConnectWithoutResumeInput = {
    where: AlumniWhereUniqueInput
    create: XOR<AlumniCreateWithoutResumeInput, AlumniUncheckedCreateWithoutResumeInput>
  }

  export type ResumeLanguageCreateWithoutResumeInput = {
    masteryLevel: number
    isVisible: boolean
    language: LanguageCreateNestedOneWithoutKnownByInput
  }

  export type ResumeLanguageUncheckedCreateWithoutResumeInput = {
    languageName: string
    masteryLevel: number
    isVisible: boolean
  }

  export type ResumeLanguageCreateOrConnectWithoutResumeInput = {
    where: ResumeLanguageWhereUniqueInput
    create: XOR<ResumeLanguageCreateWithoutResumeInput, ResumeLanguageUncheckedCreateWithoutResumeInput>
  }

  export type ResumeLanguageCreateManyResumeInputEnvelope = {
    data: ResumeLanguageCreateManyResumeInput | ResumeLanguageCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioItemCreateWithoutResumeInput = {
    title: string
    sourceLink: string
    isVisible: boolean
  }

  export type PortfolioItemUncheckedCreateWithoutResumeInput = {
    title: string
    sourceLink: string
    isVisible: boolean
  }

  export type PortfolioItemCreateOrConnectWithoutResumeInput = {
    where: PortfolioItemWhereUniqueInput
    create: XOR<PortfolioItemCreateWithoutResumeInput, PortfolioItemUncheckedCreateWithoutResumeInput>
  }

  export type PortfolioItemCreateManyResumeInputEnvelope = {
    data: PortfolioItemCreateManyResumeInput | PortfolioItemCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type HigherEducationStudyCreateWithoutResumeInput = {
    title: string
    institution: string
    endDate: Date | string
    isVisible: boolean
  }

  export type HigherEducationStudyUncheckedCreateWithoutResumeInput = {
    title: string
    institution: string
    endDate: Date | string
    isVisible: boolean
  }

  export type HigherEducationStudyCreateOrConnectWithoutResumeInput = {
    where: HigherEducationStudyWhereUniqueInput
    create: XOR<HigherEducationStudyCreateWithoutResumeInput, HigherEducationStudyUncheckedCreateWithoutResumeInput>
  }

  export type HigherEducationStudyCreateManyResumeInputEnvelope = {
    data: HigherEducationStudyCreateManyResumeInput | HigherEducationStudyCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeTechnicalSkillCreateWithoutResumeInput = {
    isVisible: boolean
    skill: TechnicalSkillCreateNestedOneWithoutResumesListingThisInput
  }

  export type ResumeTechnicalSkillUncheckedCreateWithoutResumeInput = {
    skillName: string
    skillCategoryName: string
    isVisible: boolean
  }

  export type ResumeTechnicalSkillCreateOrConnectWithoutResumeInput = {
    where: ResumeTechnicalSkillWhereUniqueInput
    create: XOR<ResumeTechnicalSkillCreateWithoutResumeInput, ResumeTechnicalSkillUncheckedCreateWithoutResumeInput>
  }

  export type ResumeTechnicalSkillCreateManyResumeInputEnvelope = {
    data: ResumeTechnicalSkillCreateManyResumeInput | ResumeTechnicalSkillCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeSoftSkillCreateWithoutResumeInput = {
    isVisible: boolean
    skill: SoftSkillCreateNestedOneWithoutResumesListingThisInput
  }

  export type ResumeSoftSkillUncheckedCreateWithoutResumeInput = {
    skillName: string
    isVisible: boolean
  }

  export type ResumeSoftSkillCreateOrConnectWithoutResumeInput = {
    where: ResumeSoftSkillWhereUniqueInput
    create: XOR<ResumeSoftSkillCreateWithoutResumeInput, ResumeSoftSkillUncheckedCreateWithoutResumeInput>
  }

  export type ResumeSoftSkillCreateManyResumeInputEnvelope = {
    data: ResumeSoftSkillCreateManyResumeInput | ResumeSoftSkillCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeCiapCourseCreateWithoutResumeInput = {
    isVisible: boolean
    course: CiapCourseCreateNestedOneWithoutResumesListingThisInput
  }

  export type ResumeCiapCourseUncheckedCreateWithoutResumeInput = {
    courseId: string
    isVisible: boolean
  }

  export type ResumeCiapCourseCreateOrConnectWithoutResumeInput = {
    where: ResumeCiapCourseWhereUniqueInput
    create: XOR<ResumeCiapCourseCreateWithoutResumeInput, ResumeCiapCourseUncheckedCreateWithoutResumeInput>
  }

  export type ResumeCiapCourseCreateManyResumeInputEnvelope = {
    data: ResumeCiapCourseCreateManyResumeInput | ResumeCiapCourseCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type PositionOfInterestCreateWithoutResumeInput = {
    positionName: string
    isVisible: boolean
  }

  export type PositionOfInterestUncheckedCreateWithoutResumeInput = {
    positionName: string
    isVisible: boolean
  }

  export type PositionOfInterestCreateOrConnectWithoutResumeInput = {
    where: PositionOfInterestWhereUniqueInput
    create: XOR<PositionOfInterestCreateWithoutResumeInput, PositionOfInterestUncheckedCreateWithoutResumeInput>
  }

  export type PositionOfInterestCreateManyResumeInputEnvelope = {
    data: PositionOfInterestCreateManyResumeInput | PositionOfInterestCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type IndustryOfInterestCreateWithoutResumeInput = {
    industryName: string
    isVisible: boolean
  }

  export type IndustryOfInterestUncheckedCreateWithoutResumeInput = {
    industryName: string
    isVisible: boolean
  }

  export type IndustryOfInterestCreateOrConnectWithoutResumeInput = {
    where: IndustryOfInterestWhereUniqueInput
    create: XOR<IndustryOfInterestCreateWithoutResumeInput, IndustryOfInterestUncheckedCreateWithoutResumeInput>
  }

  export type IndustryOfInterestCreateManyResumeInputEnvelope = {
    data: IndustryOfInterestCreateManyResumeInput | IndustryOfInterestCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type AlumniUpsertWithoutResumeInput = {
    update: XOR<AlumniUpdateWithoutResumeInput, AlumniUncheckedUpdateWithoutResumeInput>
    create: XOR<AlumniCreateWithoutResumeInput, AlumniUncheckedCreateWithoutResumeInput>
    where?: AlumniWhereInput
  }

  export type AlumniUpdateToOneWithWhereWithoutResumeInput = {
    where?: AlumniWhereInput
    data: XOR<AlumniUpdateWithoutResumeInput, AlumniUncheckedUpdateWithoutResumeInput>
  }

  export type AlumniUpdateWithoutResumeInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    associatedUser?: UserUpdateOneRequiredWithoutAssociatedAlumniNestedInput
    jobApplications?: JobApplicationUpdateManyWithoutAlumniWhoAppliedNestedInput
    graduations?: GraduationUpdateManyWithoutAlumniNestedInput
  }

  export type AlumniUncheckedUpdateWithoutResumeInput = {
    email?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    jobApplications?: JobApplicationUncheckedUpdateManyWithoutAlumniWhoAppliedNestedInput
    graduations?: GraduationUncheckedUpdateManyWithoutAlumniNestedInput
  }

  export type ResumeLanguageUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeLanguageWhereUniqueInput
    update: XOR<ResumeLanguageUpdateWithoutResumeInput, ResumeLanguageUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeLanguageCreateWithoutResumeInput, ResumeLanguageUncheckedCreateWithoutResumeInput>
  }

  export type ResumeLanguageUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeLanguageWhereUniqueInput
    data: XOR<ResumeLanguageUpdateWithoutResumeInput, ResumeLanguageUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeLanguageUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeLanguageScalarWhereInput
    data: XOR<ResumeLanguageUpdateManyMutationInput, ResumeLanguageUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeLanguageScalarWhereInput = {
    AND?: ResumeLanguageScalarWhereInput | ResumeLanguageScalarWhereInput[]
    OR?: ResumeLanguageScalarWhereInput[]
    NOT?: ResumeLanguageScalarWhereInput | ResumeLanguageScalarWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeLanguage"> | string
    languageName?: StringFilter<"ResumeLanguage"> | string
    masteryLevel?: IntFilter<"ResumeLanguage"> | number
    isVisible?: BoolFilter<"ResumeLanguage"> | boolean
  }

  export type PortfolioItemUpsertWithWhereUniqueWithoutResumeInput = {
    where: PortfolioItemWhereUniqueInput
    update: XOR<PortfolioItemUpdateWithoutResumeInput, PortfolioItemUncheckedUpdateWithoutResumeInput>
    create: XOR<PortfolioItemCreateWithoutResumeInput, PortfolioItemUncheckedCreateWithoutResumeInput>
  }

  export type PortfolioItemUpdateWithWhereUniqueWithoutResumeInput = {
    where: PortfolioItemWhereUniqueInput
    data: XOR<PortfolioItemUpdateWithoutResumeInput, PortfolioItemUncheckedUpdateWithoutResumeInput>
  }

  export type PortfolioItemUpdateManyWithWhereWithoutResumeInput = {
    where: PortfolioItemScalarWhereInput
    data: XOR<PortfolioItemUpdateManyMutationInput, PortfolioItemUncheckedUpdateManyWithoutResumeInput>
  }

  export type PortfolioItemScalarWhereInput = {
    AND?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
    OR?: PortfolioItemScalarWhereInput[]
    NOT?: PortfolioItemScalarWhereInput | PortfolioItemScalarWhereInput[]
    resumeOwnerEmail?: StringFilter<"PortfolioItem"> | string
    title?: StringFilter<"PortfolioItem"> | string
    sourceLink?: StringFilter<"PortfolioItem"> | string
    isVisible?: BoolFilter<"PortfolioItem"> | boolean
  }

  export type HigherEducationStudyUpsertWithWhereUniqueWithoutResumeInput = {
    where: HigherEducationStudyWhereUniqueInput
    update: XOR<HigherEducationStudyUpdateWithoutResumeInput, HigherEducationStudyUncheckedUpdateWithoutResumeInput>
    create: XOR<HigherEducationStudyCreateWithoutResumeInput, HigherEducationStudyUncheckedCreateWithoutResumeInput>
  }

  export type HigherEducationStudyUpdateWithWhereUniqueWithoutResumeInput = {
    where: HigherEducationStudyWhereUniqueInput
    data: XOR<HigherEducationStudyUpdateWithoutResumeInput, HigherEducationStudyUncheckedUpdateWithoutResumeInput>
  }

  export type HigherEducationStudyUpdateManyWithWhereWithoutResumeInput = {
    where: HigherEducationStudyScalarWhereInput
    data: XOR<HigherEducationStudyUpdateManyMutationInput, HigherEducationStudyUncheckedUpdateManyWithoutResumeInput>
  }

  export type HigherEducationStudyScalarWhereInput = {
    AND?: HigherEducationStudyScalarWhereInput | HigherEducationStudyScalarWhereInput[]
    OR?: HigherEducationStudyScalarWhereInput[]
    NOT?: HigherEducationStudyScalarWhereInput | HigherEducationStudyScalarWhereInput[]
    resumeOwnerEmail?: StringFilter<"HigherEducationStudy"> | string
    title?: StringFilter<"HigherEducationStudy"> | string
    institution?: StringFilter<"HigherEducationStudy"> | string
    endDate?: DateTimeFilter<"HigherEducationStudy"> | Date | string
    isVisible?: BoolFilter<"HigherEducationStudy"> | boolean
  }

  export type ResumeTechnicalSkillUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeTechnicalSkillWhereUniqueInput
    update: XOR<ResumeTechnicalSkillUpdateWithoutResumeInput, ResumeTechnicalSkillUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeTechnicalSkillCreateWithoutResumeInput, ResumeTechnicalSkillUncheckedCreateWithoutResumeInput>
  }

  export type ResumeTechnicalSkillUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeTechnicalSkillWhereUniqueInput
    data: XOR<ResumeTechnicalSkillUpdateWithoutResumeInput, ResumeTechnicalSkillUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeTechnicalSkillUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeTechnicalSkillScalarWhereInput
    data: XOR<ResumeTechnicalSkillUpdateManyMutationInput, ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeTechnicalSkillScalarWhereInput = {
    AND?: ResumeTechnicalSkillScalarWhereInput | ResumeTechnicalSkillScalarWhereInput[]
    OR?: ResumeTechnicalSkillScalarWhereInput[]
    NOT?: ResumeTechnicalSkillScalarWhereInput | ResumeTechnicalSkillScalarWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeTechnicalSkill"> | string
    skillName?: StringFilter<"ResumeTechnicalSkill"> | string
    skillCategoryName?: StringFilter<"ResumeTechnicalSkill"> | string
    isVisible?: BoolFilter<"ResumeTechnicalSkill"> | boolean
  }

  export type ResumeSoftSkillUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeSoftSkillWhereUniqueInput
    update: XOR<ResumeSoftSkillUpdateWithoutResumeInput, ResumeSoftSkillUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeSoftSkillCreateWithoutResumeInput, ResumeSoftSkillUncheckedCreateWithoutResumeInput>
  }

  export type ResumeSoftSkillUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeSoftSkillWhereUniqueInput
    data: XOR<ResumeSoftSkillUpdateWithoutResumeInput, ResumeSoftSkillUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeSoftSkillUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeSoftSkillScalarWhereInput
    data: XOR<ResumeSoftSkillUpdateManyMutationInput, ResumeSoftSkillUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeSoftSkillScalarWhereInput = {
    AND?: ResumeSoftSkillScalarWhereInput | ResumeSoftSkillScalarWhereInput[]
    OR?: ResumeSoftSkillScalarWhereInput[]
    NOT?: ResumeSoftSkillScalarWhereInput | ResumeSoftSkillScalarWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeSoftSkill"> | string
    skillName?: StringFilter<"ResumeSoftSkill"> | string
    isVisible?: BoolFilter<"ResumeSoftSkill"> | boolean
  }

  export type ResumeCiapCourseUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeCiapCourseWhereUniqueInput
    update: XOR<ResumeCiapCourseUpdateWithoutResumeInput, ResumeCiapCourseUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeCiapCourseCreateWithoutResumeInput, ResumeCiapCourseUncheckedCreateWithoutResumeInput>
  }

  export type ResumeCiapCourseUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeCiapCourseWhereUniqueInput
    data: XOR<ResumeCiapCourseUpdateWithoutResumeInput, ResumeCiapCourseUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeCiapCourseUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeCiapCourseScalarWhereInput
    data: XOR<ResumeCiapCourseUpdateManyMutationInput, ResumeCiapCourseUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeCiapCourseScalarWhereInput = {
    AND?: ResumeCiapCourseScalarWhereInput | ResumeCiapCourseScalarWhereInput[]
    OR?: ResumeCiapCourseScalarWhereInput[]
    NOT?: ResumeCiapCourseScalarWhereInput | ResumeCiapCourseScalarWhereInput[]
    resumeOwnerEmail?: StringFilter<"ResumeCiapCourse"> | string
    courseId?: UuidFilter<"ResumeCiapCourse"> | string
    isVisible?: BoolFilter<"ResumeCiapCourse"> | boolean
  }

  export type PositionOfInterestUpsertWithWhereUniqueWithoutResumeInput = {
    where: PositionOfInterestWhereUniqueInput
    update: XOR<PositionOfInterestUpdateWithoutResumeInput, PositionOfInterestUncheckedUpdateWithoutResumeInput>
    create: XOR<PositionOfInterestCreateWithoutResumeInput, PositionOfInterestUncheckedCreateWithoutResumeInput>
  }

  export type PositionOfInterestUpdateWithWhereUniqueWithoutResumeInput = {
    where: PositionOfInterestWhereUniqueInput
    data: XOR<PositionOfInterestUpdateWithoutResumeInput, PositionOfInterestUncheckedUpdateWithoutResumeInput>
  }

  export type PositionOfInterestUpdateManyWithWhereWithoutResumeInput = {
    where: PositionOfInterestScalarWhereInput
    data: XOR<PositionOfInterestUpdateManyMutationInput, PositionOfInterestUncheckedUpdateManyWithoutResumeInput>
  }

  export type PositionOfInterestScalarWhereInput = {
    AND?: PositionOfInterestScalarWhereInput | PositionOfInterestScalarWhereInput[]
    OR?: PositionOfInterestScalarWhereInput[]
    NOT?: PositionOfInterestScalarWhereInput | PositionOfInterestScalarWhereInput[]
    resumeOwnerEmail?: StringFilter<"PositionOfInterest"> | string
    positionName?: StringFilter<"PositionOfInterest"> | string
    isVisible?: BoolFilter<"PositionOfInterest"> | boolean
  }

  export type IndustryOfInterestUpsertWithWhereUniqueWithoutResumeInput = {
    where: IndustryOfInterestWhereUniqueInput
    update: XOR<IndustryOfInterestUpdateWithoutResumeInput, IndustryOfInterestUncheckedUpdateWithoutResumeInput>
    create: XOR<IndustryOfInterestCreateWithoutResumeInput, IndustryOfInterestUncheckedCreateWithoutResumeInput>
  }

  export type IndustryOfInterestUpdateWithWhereUniqueWithoutResumeInput = {
    where: IndustryOfInterestWhereUniqueInput
    data: XOR<IndustryOfInterestUpdateWithoutResumeInput, IndustryOfInterestUncheckedUpdateWithoutResumeInput>
  }

  export type IndustryOfInterestUpdateManyWithWhereWithoutResumeInput = {
    where: IndustryOfInterestScalarWhereInput
    data: XOR<IndustryOfInterestUpdateManyMutationInput, IndustryOfInterestUncheckedUpdateManyWithoutResumeInput>
  }

  export type IndustryOfInterestScalarWhereInput = {
    AND?: IndustryOfInterestScalarWhereInput | IndustryOfInterestScalarWhereInput[]
    OR?: IndustryOfInterestScalarWhereInput[]
    NOT?: IndustryOfInterestScalarWhereInput | IndustryOfInterestScalarWhereInput[]
    resumeOwnerEmail?: StringFilter<"IndustryOfInterest"> | string
    industryName?: StringFilter<"IndustryOfInterest"> | string
    isVisible?: BoolFilter<"IndustryOfInterest"> | boolean
  }

  export type ResumeCiapCourseCreateWithoutCourseInput = {
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutCiapCoursesInput
  }

  export type ResumeCiapCourseUncheckedCreateWithoutCourseInput = {
    resumeOwnerEmail: string
    isVisible: boolean
  }

  export type ResumeCiapCourseCreateOrConnectWithoutCourseInput = {
    where: ResumeCiapCourseWhereUniqueInput
    create: XOR<ResumeCiapCourseCreateWithoutCourseInput, ResumeCiapCourseUncheckedCreateWithoutCourseInput>
  }

  export type ResumeCiapCourseCreateManyCourseInputEnvelope = {
    data: ResumeCiapCourseCreateManyCourseInput | ResumeCiapCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ResumeCiapCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: ResumeCiapCourseWhereUniqueInput
    update: XOR<ResumeCiapCourseUpdateWithoutCourseInput, ResumeCiapCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<ResumeCiapCourseCreateWithoutCourseInput, ResumeCiapCourseUncheckedCreateWithoutCourseInput>
  }

  export type ResumeCiapCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: ResumeCiapCourseWhereUniqueInput
    data: XOR<ResumeCiapCourseUpdateWithoutCourseInput, ResumeCiapCourseUncheckedUpdateWithoutCourseInput>
  }

  export type ResumeCiapCourseUpdateManyWithWhereWithoutCourseInput = {
    where: ResumeCiapCourseScalarWhereInput
    data: XOR<ResumeCiapCourseUpdateManyMutationInput, ResumeCiapCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type ResumeCreateWithoutCiapCoursesInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutCiapCoursesInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutCiapCoursesInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutCiapCoursesInput, ResumeUncheckedCreateWithoutCiapCoursesInput>
  }

  export type CiapCourseCreateWithoutResumesListingThisInput = {
    id?: string
    name: string
    date: Date | string
  }

  export type CiapCourseUncheckedCreateWithoutResumesListingThisInput = {
    id?: string
    name: string
    date: Date | string
  }

  export type CiapCourseCreateOrConnectWithoutResumesListingThisInput = {
    where: CiapCourseWhereUniqueInput
    create: XOR<CiapCourseCreateWithoutResumesListingThisInput, CiapCourseUncheckedCreateWithoutResumesListingThisInput>
  }

  export type ResumeUpsertWithoutCiapCoursesInput = {
    update: XOR<ResumeUpdateWithoutCiapCoursesInput, ResumeUncheckedUpdateWithoutCiapCoursesInput>
    create: XOR<ResumeCreateWithoutCiapCoursesInput, ResumeUncheckedCreateWithoutCiapCoursesInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutCiapCoursesInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutCiapCoursesInput, ResumeUncheckedUpdateWithoutCiapCoursesInput>
  }

  export type ResumeUpdateWithoutCiapCoursesInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutCiapCoursesInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type CiapCourseUpsertWithoutResumesListingThisInput = {
    update: XOR<CiapCourseUpdateWithoutResumesListingThisInput, CiapCourseUncheckedUpdateWithoutResumesListingThisInput>
    create: XOR<CiapCourseCreateWithoutResumesListingThisInput, CiapCourseUncheckedCreateWithoutResumesListingThisInput>
    where?: CiapCourseWhereInput
  }

  export type CiapCourseUpdateToOneWithWhereWithoutResumesListingThisInput = {
    where?: CiapCourseWhereInput
    data: XOR<CiapCourseUpdateWithoutResumesListingThisInput, CiapCourseUncheckedUpdateWithoutResumesListingThisInput>
  }

  export type CiapCourseUpdateWithoutResumesListingThisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CiapCourseUncheckedUpdateWithoutResumesListingThisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeSoftSkillCreateWithoutSkillInput = {
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutSoftSkillsInput
  }

  export type ResumeSoftSkillUncheckedCreateWithoutSkillInput = {
    resumeOwnerEmail: string
    isVisible: boolean
  }

  export type ResumeSoftSkillCreateOrConnectWithoutSkillInput = {
    where: ResumeSoftSkillWhereUniqueInput
    create: XOR<ResumeSoftSkillCreateWithoutSkillInput, ResumeSoftSkillUncheckedCreateWithoutSkillInput>
  }

  export type ResumeSoftSkillCreateManySkillInputEnvelope = {
    data: ResumeSoftSkillCreateManySkillInput | ResumeSoftSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type ResumeSoftSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: ResumeSoftSkillWhereUniqueInput
    update: XOR<ResumeSoftSkillUpdateWithoutSkillInput, ResumeSoftSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<ResumeSoftSkillCreateWithoutSkillInput, ResumeSoftSkillUncheckedCreateWithoutSkillInput>
  }

  export type ResumeSoftSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: ResumeSoftSkillWhereUniqueInput
    data: XOR<ResumeSoftSkillUpdateWithoutSkillInput, ResumeSoftSkillUncheckedUpdateWithoutSkillInput>
  }

  export type ResumeSoftSkillUpdateManyWithWhereWithoutSkillInput = {
    where: ResumeSoftSkillScalarWhereInput
    data: XOR<ResumeSoftSkillUpdateManyMutationInput, ResumeSoftSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type ResumeCreateWithoutSoftSkillsInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutSoftSkillsInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutSoftSkillsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutSoftSkillsInput, ResumeUncheckedCreateWithoutSoftSkillsInput>
  }

  export type SoftSkillCreateWithoutResumesListingThisInput = {
    name: string
  }

  export type SoftSkillUncheckedCreateWithoutResumesListingThisInput = {
    name: string
  }

  export type SoftSkillCreateOrConnectWithoutResumesListingThisInput = {
    where: SoftSkillWhereUniqueInput
    create: XOR<SoftSkillCreateWithoutResumesListingThisInput, SoftSkillUncheckedCreateWithoutResumesListingThisInput>
  }

  export type ResumeUpsertWithoutSoftSkillsInput = {
    update: XOR<ResumeUpdateWithoutSoftSkillsInput, ResumeUncheckedUpdateWithoutSoftSkillsInput>
    create: XOR<ResumeCreateWithoutSoftSkillsInput, ResumeUncheckedCreateWithoutSoftSkillsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutSoftSkillsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutSoftSkillsInput, ResumeUncheckedUpdateWithoutSoftSkillsInput>
  }

  export type ResumeUpdateWithoutSoftSkillsInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutSoftSkillsInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type SoftSkillUpsertWithoutResumesListingThisInput = {
    update: XOR<SoftSkillUpdateWithoutResumesListingThisInput, SoftSkillUncheckedUpdateWithoutResumesListingThisInput>
    create: XOR<SoftSkillCreateWithoutResumesListingThisInput, SoftSkillUncheckedCreateWithoutResumesListingThisInput>
    where?: SoftSkillWhereInput
  }

  export type SoftSkillUpdateToOneWithWhereWithoutResumesListingThisInput = {
    where?: SoftSkillWhereInput
    data: XOR<SoftSkillUpdateWithoutResumesListingThisInput, SoftSkillUncheckedUpdateWithoutResumesListingThisInput>
  }

  export type SoftSkillUpdateWithoutResumesListingThisInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SoftSkillUncheckedUpdateWithoutResumesListingThisInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TechnicalSkillCreateWithoutCategoryInput = {
    name: string
    resumesListingThis?: ResumeTechnicalSkillCreateNestedManyWithoutSkillInput
    jobOffersListingThis?: JobOfferTechnicalSkillCreateNestedManyWithoutTechnicalSkillInput
  }

  export type TechnicalSkillUncheckedCreateWithoutCategoryInput = {
    name: string
    resumesListingThis?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutSkillInput
    jobOffersListingThis?: JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutTechnicalSkillInput
  }

  export type TechnicalSkillCreateOrConnectWithoutCategoryInput = {
    where: TechnicalSkillWhereUniqueInput
    create: XOR<TechnicalSkillCreateWithoutCategoryInput, TechnicalSkillUncheckedCreateWithoutCategoryInput>
  }

  export type TechnicalSkillCreateManyCategoryInputEnvelope = {
    data: TechnicalSkillCreateManyCategoryInput | TechnicalSkillCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CareerCreateWithoutSkillCategoriesInput = {
    name: string
    jobOffers?: JobOfferCreateNestedManyWithoutCareerInput
    graduations?: GraduationCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateWithoutSkillCategoriesInput = {
    name: string
    jobOffers?: JobOfferUncheckedCreateNestedManyWithoutCareerInput
    graduations?: GraduationUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerCreateOrConnectWithoutSkillCategoriesInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutSkillCategoriesInput, CareerUncheckedCreateWithoutSkillCategoriesInput>
  }

  export type TechnicalSkillUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TechnicalSkillWhereUniqueInput
    update: XOR<TechnicalSkillUpdateWithoutCategoryInput, TechnicalSkillUncheckedUpdateWithoutCategoryInput>
    create: XOR<TechnicalSkillCreateWithoutCategoryInput, TechnicalSkillUncheckedCreateWithoutCategoryInput>
  }

  export type TechnicalSkillUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TechnicalSkillWhereUniqueInput
    data: XOR<TechnicalSkillUpdateWithoutCategoryInput, TechnicalSkillUncheckedUpdateWithoutCategoryInput>
  }

  export type TechnicalSkillUpdateManyWithWhereWithoutCategoryInput = {
    where: TechnicalSkillScalarWhereInput
    data: XOR<TechnicalSkillUpdateManyMutationInput, TechnicalSkillUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TechnicalSkillScalarWhereInput = {
    AND?: TechnicalSkillScalarWhereInput | TechnicalSkillScalarWhereInput[]
    OR?: TechnicalSkillScalarWhereInput[]
    NOT?: TechnicalSkillScalarWhereInput | TechnicalSkillScalarWhereInput[]
    name?: StringFilter<"TechnicalSkill"> | string
    categoryName?: StringFilter<"TechnicalSkill"> | string
  }

  export type CareerUpsertWithWhereUniqueWithoutSkillCategoriesInput = {
    where: CareerWhereUniqueInput
    update: XOR<CareerUpdateWithoutSkillCategoriesInput, CareerUncheckedUpdateWithoutSkillCategoriesInput>
    create: XOR<CareerCreateWithoutSkillCategoriesInput, CareerUncheckedCreateWithoutSkillCategoriesInput>
  }

  export type CareerUpdateWithWhereUniqueWithoutSkillCategoriesInput = {
    where: CareerWhereUniqueInput
    data: XOR<CareerUpdateWithoutSkillCategoriesInput, CareerUncheckedUpdateWithoutSkillCategoriesInput>
  }

  export type CareerUpdateManyWithWhereWithoutSkillCategoriesInput = {
    where: CareerScalarWhereInput
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyWithoutSkillCategoriesInput>
  }

  export type CareerScalarWhereInput = {
    AND?: CareerScalarWhereInput | CareerScalarWhereInput[]
    OR?: CareerScalarWhereInput[]
    NOT?: CareerScalarWhereInput | CareerScalarWhereInput[]
    name?: StringFilter<"Career"> | string
  }

  export type SkillCategoryCreateWithoutTechnicalSkillsInput = {
    name: string
    relatedCareers?: CareerCreateNestedManyWithoutSkillCategoriesInput
  }

  export type SkillCategoryUncheckedCreateWithoutTechnicalSkillsInput = {
    name: string
    relatedCareers?: CareerUncheckedCreateNestedManyWithoutSkillCategoriesInput
  }

  export type SkillCategoryCreateOrConnectWithoutTechnicalSkillsInput = {
    where: SkillCategoryWhereUniqueInput
    create: XOR<SkillCategoryCreateWithoutTechnicalSkillsInput, SkillCategoryUncheckedCreateWithoutTechnicalSkillsInput>
  }

  export type ResumeTechnicalSkillCreateWithoutSkillInput = {
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutTechnicalSkillsInput
  }

  export type ResumeTechnicalSkillUncheckedCreateWithoutSkillInput = {
    resumeOwnerEmail: string
    isVisible: boolean
  }

  export type ResumeTechnicalSkillCreateOrConnectWithoutSkillInput = {
    where: ResumeTechnicalSkillWhereUniqueInput
    create: XOR<ResumeTechnicalSkillCreateWithoutSkillInput, ResumeTechnicalSkillUncheckedCreateWithoutSkillInput>
  }

  export type ResumeTechnicalSkillCreateManySkillInputEnvelope = {
    data: ResumeTechnicalSkillCreateManySkillInput | ResumeTechnicalSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput = {
    jobOffer: JobOfferCreateNestedOneWithoutTechnicalSkillsInput
  }

  export type JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput = {
    jobOfferId: string
  }

  export type JobOfferTechnicalSkillCreateOrConnectWithoutTechnicalSkillInput = {
    where: JobOfferTechnicalSkillWhereUniqueInput
    create: XOR<JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput, JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput>
  }

  export type JobOfferTechnicalSkillCreateManyTechnicalSkillInputEnvelope = {
    data: JobOfferTechnicalSkillCreateManyTechnicalSkillInput | JobOfferTechnicalSkillCreateManyTechnicalSkillInput[]
    skipDuplicates?: boolean
  }

  export type SkillCategoryUpsertWithoutTechnicalSkillsInput = {
    update: XOR<SkillCategoryUpdateWithoutTechnicalSkillsInput, SkillCategoryUncheckedUpdateWithoutTechnicalSkillsInput>
    create: XOR<SkillCategoryCreateWithoutTechnicalSkillsInput, SkillCategoryUncheckedCreateWithoutTechnicalSkillsInput>
    where?: SkillCategoryWhereInput
  }

  export type SkillCategoryUpdateToOneWithWhereWithoutTechnicalSkillsInput = {
    where?: SkillCategoryWhereInput
    data: XOR<SkillCategoryUpdateWithoutTechnicalSkillsInput, SkillCategoryUncheckedUpdateWithoutTechnicalSkillsInput>
  }

  export type SkillCategoryUpdateWithoutTechnicalSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    relatedCareers?: CareerUpdateManyWithoutSkillCategoriesNestedInput
  }

  export type SkillCategoryUncheckedUpdateWithoutTechnicalSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    relatedCareers?: CareerUncheckedUpdateManyWithoutSkillCategoriesNestedInput
  }

  export type ResumeTechnicalSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: ResumeTechnicalSkillWhereUniqueInput
    update: XOR<ResumeTechnicalSkillUpdateWithoutSkillInput, ResumeTechnicalSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<ResumeTechnicalSkillCreateWithoutSkillInput, ResumeTechnicalSkillUncheckedCreateWithoutSkillInput>
  }

  export type ResumeTechnicalSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: ResumeTechnicalSkillWhereUniqueInput
    data: XOR<ResumeTechnicalSkillUpdateWithoutSkillInput, ResumeTechnicalSkillUncheckedUpdateWithoutSkillInput>
  }

  export type ResumeTechnicalSkillUpdateManyWithWhereWithoutSkillInput = {
    where: ResumeTechnicalSkillScalarWhereInput
    data: XOR<ResumeTechnicalSkillUpdateManyMutationInput, ResumeTechnicalSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type JobOfferTechnicalSkillUpsertWithWhereUniqueWithoutTechnicalSkillInput = {
    where: JobOfferTechnicalSkillWhereUniqueInput
    update: XOR<JobOfferTechnicalSkillUpdateWithoutTechnicalSkillInput, JobOfferTechnicalSkillUncheckedUpdateWithoutTechnicalSkillInput>
    create: XOR<JobOfferTechnicalSkillCreateWithoutTechnicalSkillInput, JobOfferTechnicalSkillUncheckedCreateWithoutTechnicalSkillInput>
  }

  export type JobOfferTechnicalSkillUpdateWithWhereUniqueWithoutTechnicalSkillInput = {
    where: JobOfferTechnicalSkillWhereUniqueInput
    data: XOR<JobOfferTechnicalSkillUpdateWithoutTechnicalSkillInput, JobOfferTechnicalSkillUncheckedUpdateWithoutTechnicalSkillInput>
  }

  export type JobOfferTechnicalSkillUpdateManyWithWhereWithoutTechnicalSkillInput = {
    where: JobOfferTechnicalSkillScalarWhereInput
    data: XOR<JobOfferTechnicalSkillUpdateManyMutationInput, JobOfferTechnicalSkillUncheckedUpdateManyWithoutTechnicalSkillInput>
  }

  export type ResumeCreateWithoutTechnicalSkillsInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutTechnicalSkillsInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutTechnicalSkillsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutTechnicalSkillsInput, ResumeUncheckedCreateWithoutTechnicalSkillsInput>
  }

  export type TechnicalSkillCreateWithoutResumesListingThisInput = {
    name: string
    category: SkillCategoryCreateNestedOneWithoutTechnicalSkillsInput
    jobOffersListingThis?: JobOfferTechnicalSkillCreateNestedManyWithoutTechnicalSkillInput
  }

  export type TechnicalSkillUncheckedCreateWithoutResumesListingThisInput = {
    name: string
    categoryName: string
    jobOffersListingThis?: JobOfferTechnicalSkillUncheckedCreateNestedManyWithoutTechnicalSkillInput
  }

  export type TechnicalSkillCreateOrConnectWithoutResumesListingThisInput = {
    where: TechnicalSkillWhereUniqueInput
    create: XOR<TechnicalSkillCreateWithoutResumesListingThisInput, TechnicalSkillUncheckedCreateWithoutResumesListingThisInput>
  }

  export type ResumeUpsertWithoutTechnicalSkillsInput = {
    update: XOR<ResumeUpdateWithoutTechnicalSkillsInput, ResumeUncheckedUpdateWithoutTechnicalSkillsInput>
    create: XOR<ResumeCreateWithoutTechnicalSkillsInput, ResumeUncheckedCreateWithoutTechnicalSkillsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutTechnicalSkillsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutTechnicalSkillsInput, ResumeUncheckedUpdateWithoutTechnicalSkillsInput>
  }

  export type ResumeUpdateWithoutTechnicalSkillsInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutTechnicalSkillsInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type TechnicalSkillUpsertWithoutResumesListingThisInput = {
    update: XOR<TechnicalSkillUpdateWithoutResumesListingThisInput, TechnicalSkillUncheckedUpdateWithoutResumesListingThisInput>
    create: XOR<TechnicalSkillCreateWithoutResumesListingThisInput, TechnicalSkillUncheckedCreateWithoutResumesListingThisInput>
    where?: TechnicalSkillWhereInput
  }

  export type TechnicalSkillUpdateToOneWithWhereWithoutResumesListingThisInput = {
    where?: TechnicalSkillWhereInput
    data: XOR<TechnicalSkillUpdateWithoutResumesListingThisInput, TechnicalSkillUncheckedUpdateWithoutResumesListingThisInput>
  }

  export type TechnicalSkillUpdateWithoutResumesListingThisInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: SkillCategoryUpdateOneRequiredWithoutTechnicalSkillsNestedInput
    jobOffersListingThis?: JobOfferTechnicalSkillUpdateManyWithoutTechnicalSkillNestedInput
  }

  export type TechnicalSkillUncheckedUpdateWithoutResumesListingThisInput = {
    name?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    jobOffersListingThis?: JobOfferTechnicalSkillUncheckedUpdateManyWithoutTechnicalSkillNestedInput
  }

  export type ResumeLanguageCreateWithoutLanguageInput = {
    masteryLevel: number
    isVisible: boolean
    resume: ResumeCreateNestedOneWithoutKnownLanguagesInput
  }

  export type ResumeLanguageUncheckedCreateWithoutLanguageInput = {
    resumeOwnerEmail: string
    masteryLevel: number
    isVisible: boolean
  }

  export type ResumeLanguageCreateOrConnectWithoutLanguageInput = {
    where: ResumeLanguageWhereUniqueInput
    create: XOR<ResumeLanguageCreateWithoutLanguageInput, ResumeLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type ResumeLanguageCreateManyLanguageInputEnvelope = {
    data: ResumeLanguageCreateManyLanguageInput | ResumeLanguageCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type ResumeLanguageUpsertWithWhereUniqueWithoutLanguageInput = {
    where: ResumeLanguageWhereUniqueInput
    update: XOR<ResumeLanguageUpdateWithoutLanguageInput, ResumeLanguageUncheckedUpdateWithoutLanguageInput>
    create: XOR<ResumeLanguageCreateWithoutLanguageInput, ResumeLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type ResumeLanguageUpdateWithWhereUniqueWithoutLanguageInput = {
    where: ResumeLanguageWhereUniqueInput
    data: XOR<ResumeLanguageUpdateWithoutLanguageInput, ResumeLanguageUncheckedUpdateWithoutLanguageInput>
  }

  export type ResumeLanguageUpdateManyWithWhereWithoutLanguageInput = {
    where: ResumeLanguageScalarWhereInput
    data: XOR<ResumeLanguageUpdateManyMutationInput, ResumeLanguageUncheckedUpdateManyWithoutLanguageInput>
  }

  export type ResumeCreateWithoutKnownLanguagesInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutKnownLanguagesInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutKnownLanguagesInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutKnownLanguagesInput, ResumeUncheckedCreateWithoutKnownLanguagesInput>
  }

  export type LanguageCreateWithoutKnownByInput = {
    name: string
  }

  export type LanguageUncheckedCreateWithoutKnownByInput = {
    name: string
  }

  export type LanguageCreateOrConnectWithoutKnownByInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutKnownByInput, LanguageUncheckedCreateWithoutKnownByInput>
  }

  export type ResumeUpsertWithoutKnownLanguagesInput = {
    update: XOR<ResumeUpdateWithoutKnownLanguagesInput, ResumeUncheckedUpdateWithoutKnownLanguagesInput>
    create: XOR<ResumeCreateWithoutKnownLanguagesInput, ResumeUncheckedCreateWithoutKnownLanguagesInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutKnownLanguagesInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutKnownLanguagesInput, ResumeUncheckedUpdateWithoutKnownLanguagesInput>
  }

  export type ResumeUpdateWithoutKnownLanguagesInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutKnownLanguagesInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type LanguageUpsertWithoutKnownByInput = {
    update: XOR<LanguageUpdateWithoutKnownByInput, LanguageUncheckedUpdateWithoutKnownByInput>
    create: XOR<LanguageCreateWithoutKnownByInput, LanguageUncheckedCreateWithoutKnownByInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutKnownByInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutKnownByInput, LanguageUncheckedUpdateWithoutKnownByInput>
  }

  export type LanguageUpdateWithoutKnownByInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateWithoutKnownByInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeCreateWithoutPortfolioInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutPortfolioInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutPortfolioInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutPortfolioInput, ResumeUncheckedCreateWithoutPortfolioInput>
  }

  export type ResumeUpsertWithoutPortfolioInput = {
    update: XOR<ResumeUpdateWithoutPortfolioInput, ResumeUncheckedUpdateWithoutPortfolioInput>
    create: XOR<ResumeCreateWithoutPortfolioInput, ResumeUncheckedCreateWithoutPortfolioInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutPortfolioInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutPortfolioInput, ResumeUncheckedUpdateWithoutPortfolioInput>
  }

  export type ResumeUpdateWithoutPortfolioInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutPortfolioInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutHigherEducationStudiesInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutHigherEducationStudiesInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutHigherEducationStudiesInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutHigherEducationStudiesInput, ResumeUncheckedCreateWithoutHigherEducationStudiesInput>
  }

  export type ResumeUpsertWithoutHigherEducationStudiesInput = {
    update: XOR<ResumeUpdateWithoutHigherEducationStudiesInput, ResumeUncheckedUpdateWithoutHigherEducationStudiesInput>
    create: XOR<ResumeCreateWithoutHigherEducationStudiesInput, ResumeUncheckedCreateWithoutHigherEducationStudiesInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutHigherEducationStudiesInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutHigherEducationStudiesInput, ResumeUncheckedUpdateWithoutHigherEducationStudiesInput>
  }

  export type ResumeUpdateWithoutHigherEducationStudiesInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutHigherEducationStudiesInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutPositionsOfInterestInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutPositionsOfInterestInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    industriesOfInterest?: IndustryOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutPositionsOfInterestInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutPositionsOfInterestInput, ResumeUncheckedCreateWithoutPositionsOfInterestInput>
  }

  export type ResumeUpsertWithoutPositionsOfInterestInput = {
    update: XOR<ResumeUpdateWithoutPositionsOfInterestInput, ResumeUncheckedUpdateWithoutPositionsOfInterestInput>
    create: XOR<ResumeCreateWithoutPositionsOfInterestInput, ResumeUncheckedCreateWithoutPositionsOfInterestInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutPositionsOfInterestInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutPositionsOfInterestInput, ResumeUncheckedUpdateWithoutPositionsOfInterestInput>
  }

  export type ResumeUpdateWithoutPositionsOfInterestInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutPositionsOfInterestInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    industriesOfInterest?: IndustryOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutIndustriesOfInterestInput = {
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    owner: AlumniCreateNestedOneWithoutResumeInput
    knownLanguages?: ResumeLanguageCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutIndustriesOfInterestInput = {
    ownerEmail: string
    numberOfDownloads?: number
    isVisible?: boolean
    visibleSince?: Date | string
    aboutMe?: string | null
    knownLanguages?: ResumeLanguageUncheckedCreateNestedManyWithoutResumeInput
    portfolio?: PortfolioItemUncheckedCreateNestedManyWithoutResumeInput
    higherEducationStudies?: HigherEducationStudyUncheckedCreateNestedManyWithoutResumeInput
    technicalSkills?: ResumeTechnicalSkillUncheckedCreateNestedManyWithoutResumeInput
    softSkills?: ResumeSoftSkillUncheckedCreateNestedManyWithoutResumeInput
    ciapCourses?: ResumeCiapCourseUncheckedCreateNestedManyWithoutResumeInput
    positionsOfInterest?: PositionOfInterestUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutIndustriesOfInterestInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutIndustriesOfInterestInput, ResumeUncheckedCreateWithoutIndustriesOfInterestInput>
  }

  export type ResumeUpsertWithoutIndustriesOfInterestInput = {
    update: XOR<ResumeUpdateWithoutIndustriesOfInterestInput, ResumeUncheckedUpdateWithoutIndustriesOfInterestInput>
    create: XOR<ResumeCreateWithoutIndustriesOfInterestInput, ResumeUncheckedCreateWithoutIndustriesOfInterestInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutIndustriesOfInterestInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutIndustriesOfInterestInput, ResumeUncheckedUpdateWithoutIndustriesOfInterestInput>
  }

  export type ResumeUpdateWithoutIndustriesOfInterestInput = {
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: AlumniUpdateOneRequiredWithoutResumeNestedInput
    knownLanguages?: ResumeLanguageUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutIndustriesOfInterestInput = {
    ownerEmail?: StringFieldUpdateOperationsInput | string
    numberOfDownloads?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutMe?: NullableStringFieldUpdateOperationsInput | string | null
    knownLanguages?: ResumeLanguageUncheckedUpdateManyWithoutResumeNestedInput
    portfolio?: PortfolioItemUncheckedUpdateManyWithoutResumeNestedInput
    higherEducationStudies?: HigherEducationStudyUncheckedUpdateManyWithoutResumeNestedInput
    technicalSkills?: ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeNestedInput
    softSkills?: ResumeSoftSkillUncheckedUpdateManyWithoutResumeNestedInput
    ciapCourses?: ResumeCiapCourseUncheckedUpdateManyWithoutResumeNestedInput
    positionsOfInterest?: PositionOfInterestUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type JobApplicationCreateManyJobOfferInput = {
    alumniWhoAppliedEmail: string
    applicationTimestamp: Date | string
  }

  export type JobOfferTechnicalSkillCreateManyJobOfferInput = {
    technicalSkillName: string
    technicalSkillCategoryName: string
  }

  export type JobApplicationUpdateWithoutJobOfferInput = {
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    alumniWhoApplied?: AlumniUpdateOneRequiredWithoutJobApplicationsNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutJobOfferInput = {
    alumniWhoAppliedEmail?: StringFieldUpdateOperationsInput | string
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobOfferInput = {
    alumniWhoAppliedEmail?: StringFieldUpdateOperationsInput | string
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobOfferTechnicalSkillUpdateWithoutJobOfferInput = {
    technicalSkill?: TechnicalSkillUpdateOneRequiredWithoutJobOffersListingThisNestedInput
  }

  export type JobOfferTechnicalSkillUncheckedUpdateWithoutJobOfferInput = {
    technicalSkillName?: StringFieldUpdateOperationsInput | string
    technicalSkillCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type JobOfferTechnicalSkillUncheckedUpdateManyWithoutJobOfferInput = {
    technicalSkillName?: StringFieldUpdateOperationsInput | string
    technicalSkillCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type JobOfferCreateManyContractTypeInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    careerName: string
  }

  export type JobOfferUpdateWithoutContractTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutJobOffersNestedInput
    applications?: JobApplicationUpdateManyWithoutJobOfferNestedInput
    technicalSkills?: JobOfferTechnicalSkillUpdateManyWithoutJobOfferNestedInput
  }

  export type JobOfferUncheckedUpdateWithoutContractTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    careerName?: StringFieldUpdateOperationsInput | string
    applications?: JobApplicationUncheckedUpdateManyWithoutJobOfferNestedInput
    technicalSkills?: JobOfferTechnicalSkillUncheckedUpdateManyWithoutJobOfferNestedInput
  }

  export type JobOfferUncheckedUpdateManyWithoutContractTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    careerName?: StringFieldUpdateOperationsInput | string
  }

  export type JobOfferCreateManyCareerInput = {
    id?: string
    description: string
    companyName: string
    companyContact: string
    companyLogo: string
    department: string
    position: string
    offerLocation: string
    offerTimestamp: Date | string
    isVisible?: boolean
    visibleSince?: Date | string
    contractTypeName: string
  }

  export type GraduationCreateManyCareerInput = {
    alumniEmail: string
    graduationDate: Date | string
  }

  export type JobOfferUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUpdateManyWithoutJobOfferNestedInput
    contractType?: ContractTypeUpdateOneRequiredWithoutContractsOfThisTypeNestedInput
    technicalSkills?: JobOfferTechnicalSkillUpdateManyWithoutJobOfferNestedInput
  }

  export type JobOfferUncheckedUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    contractTypeName?: StringFieldUpdateOperationsInput | string
    applications?: JobApplicationUncheckedUpdateManyWithoutJobOfferNestedInput
    technicalSkills?: JobOfferTechnicalSkillUncheckedUpdateManyWithoutJobOfferNestedInput
  }

  export type JobOfferUncheckedUpdateManyWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyContact?: StringFieldUpdateOperationsInput | string
    companyLogo?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    offerLocation?: StringFieldUpdateOperationsInput | string
    offerTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    visibleSince?: DateTimeFieldUpdateOperationsInput | Date | string
    contractTypeName?: StringFieldUpdateOperationsInput | string
  }

  export type GraduationUpdateWithoutCareerInput = {
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    alumni?: AlumniUpdateOneRequiredWithoutGraduationsNestedInput
  }

  export type GraduationUncheckedUpdateWithoutCareerInput = {
    alumniEmail?: StringFieldUpdateOperationsInput | string
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GraduationUncheckedUpdateManyWithoutCareerInput = {
    alumniEmail?: StringFieldUpdateOperationsInput | string
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCategoryUpdateWithoutRelatedCareersInput = {
    name?: StringFieldUpdateOperationsInput | string
    technicalSkills?: TechnicalSkillUpdateManyWithoutCategoryNestedInput
  }

  export type SkillCategoryUncheckedUpdateWithoutRelatedCareersInput = {
    name?: StringFieldUpdateOperationsInput | string
    technicalSkills?: TechnicalSkillUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SkillCategoryUncheckedUpdateManyWithoutRelatedCareersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type JobApplicationCreateManyAlumniWhoAppliedInput = {
    jobOfferId: string
    applicationTimestamp: Date | string
  }

  export type GraduationCreateManyAlumniInput = {
    careerName: string
    graduationDate: Date | string
  }

  export type JobApplicationUpdateWithoutAlumniWhoAppliedInput = {
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    jobOffer?: JobOfferUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutAlumniWhoAppliedInput = {
    jobOfferId?: StringFieldUpdateOperationsInput | string
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyWithoutAlumniWhoAppliedInput = {
    jobOfferId?: StringFieldUpdateOperationsInput | string
    applicationTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GraduationUpdateWithoutAlumniInput = {
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    career?: CareerUpdateOneRequiredWithoutGraduationsNestedInput
  }

  export type GraduationUncheckedUpdateWithoutAlumniInput = {
    careerName?: StringFieldUpdateOperationsInput | string
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GraduationUncheckedUpdateManyWithoutAlumniInput = {
    careerName?: StringFieldUpdateOperationsInput | string
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeLanguageCreateManyResumeInput = {
    languageName: string
    masteryLevel: number
    isVisible: boolean
  }

  export type PortfolioItemCreateManyResumeInput = {
    title: string
    sourceLink: string
    isVisible: boolean
  }

  export type HigherEducationStudyCreateManyResumeInput = {
    title: string
    institution: string
    endDate: Date | string
    isVisible: boolean
  }

  export type ResumeTechnicalSkillCreateManyResumeInput = {
    skillName: string
    skillCategoryName: string
    isVisible: boolean
  }

  export type ResumeSoftSkillCreateManyResumeInput = {
    skillName: string
    isVisible: boolean
  }

  export type ResumeCiapCourseCreateManyResumeInput = {
    courseId: string
    isVisible: boolean
  }

  export type PositionOfInterestCreateManyResumeInput = {
    positionName: string
    isVisible: boolean
  }

  export type IndustryOfInterestCreateManyResumeInput = {
    industryName: string
    isVisible: boolean
  }

  export type ResumeLanguageUpdateWithoutResumeInput = {
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    language?: LanguageUpdateOneRequiredWithoutKnownByNestedInput
  }

  export type ResumeLanguageUncheckedUpdateWithoutResumeInput = {
    languageName?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeLanguageUncheckedUpdateManyWithoutResumeInput = {
    languageName?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PortfolioItemUpdateWithoutResumeInput = {
    title?: StringFieldUpdateOperationsInput | string
    sourceLink?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PortfolioItemUncheckedUpdateWithoutResumeInput = {
    title?: StringFieldUpdateOperationsInput | string
    sourceLink?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PortfolioItemUncheckedUpdateManyWithoutResumeInput = {
    title?: StringFieldUpdateOperationsInput | string
    sourceLink?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HigherEducationStudyUpdateWithoutResumeInput = {
    title?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HigherEducationStudyUncheckedUpdateWithoutResumeInput = {
    title?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HigherEducationStudyUncheckedUpdateManyWithoutResumeInput = {
    title?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeTechnicalSkillUpdateWithoutResumeInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    skill?: TechnicalSkillUpdateOneRequiredWithoutResumesListingThisNestedInput
  }

  export type ResumeTechnicalSkillUncheckedUpdateWithoutResumeInput = {
    skillName?: StringFieldUpdateOperationsInput | string
    skillCategoryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeTechnicalSkillUncheckedUpdateManyWithoutResumeInput = {
    skillName?: StringFieldUpdateOperationsInput | string
    skillCategoryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeSoftSkillUpdateWithoutResumeInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    skill?: SoftSkillUpdateOneRequiredWithoutResumesListingThisNestedInput
  }

  export type ResumeSoftSkillUncheckedUpdateWithoutResumeInput = {
    skillName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeSoftSkillUncheckedUpdateManyWithoutResumeInput = {
    skillName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeCiapCourseUpdateWithoutResumeInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    course?: CiapCourseUpdateOneRequiredWithoutResumesListingThisNestedInput
  }

  export type ResumeCiapCourseUncheckedUpdateWithoutResumeInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeCiapCourseUncheckedUpdateManyWithoutResumeInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PositionOfInterestUpdateWithoutResumeInput = {
    positionName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PositionOfInterestUncheckedUpdateWithoutResumeInput = {
    positionName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PositionOfInterestUncheckedUpdateManyWithoutResumeInput = {
    positionName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IndustryOfInterestUpdateWithoutResumeInput = {
    industryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IndustryOfInterestUncheckedUpdateWithoutResumeInput = {
    industryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IndustryOfInterestUncheckedUpdateManyWithoutResumeInput = {
    industryName?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeCiapCourseCreateManyCourseInput = {
    resumeOwnerEmail: string
    isVisible: boolean
  }

  export type ResumeCiapCourseUpdateWithoutCourseInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutCiapCoursesNestedInput
  }

  export type ResumeCiapCourseUncheckedUpdateWithoutCourseInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeCiapCourseUncheckedUpdateManyWithoutCourseInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeSoftSkillCreateManySkillInput = {
    resumeOwnerEmail: string
    isVisible: boolean
  }

  export type ResumeSoftSkillUpdateWithoutSkillInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutSoftSkillsNestedInput
  }

  export type ResumeSoftSkillUncheckedUpdateWithoutSkillInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeSoftSkillUncheckedUpdateManyWithoutSkillInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TechnicalSkillCreateManyCategoryInput = {
    name: string
  }

  export type TechnicalSkillUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    resumesListingThis?: ResumeTechnicalSkillUpdateManyWithoutSkillNestedInput
    jobOffersListingThis?: JobOfferTechnicalSkillUpdateManyWithoutTechnicalSkillNestedInput
  }

  export type TechnicalSkillUncheckedUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    resumesListingThis?: ResumeTechnicalSkillUncheckedUpdateManyWithoutSkillNestedInput
    jobOffersListingThis?: JobOfferTechnicalSkillUncheckedUpdateManyWithoutTechnicalSkillNestedInput
  }

  export type TechnicalSkillUncheckedUpdateManyWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CareerUpdateWithoutSkillCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobOffers?: JobOfferUpdateManyWithoutCareerNestedInput
    graduations?: GraduationUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateWithoutSkillCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobOffers?: JobOfferUncheckedUpdateManyWithoutCareerNestedInput
    graduations?: GraduationUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateManyWithoutSkillCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeTechnicalSkillCreateManySkillInput = {
    resumeOwnerEmail: string
    isVisible: boolean
  }

  export type JobOfferTechnicalSkillCreateManyTechnicalSkillInput = {
    jobOfferId: string
  }

  export type ResumeTechnicalSkillUpdateWithoutSkillInput = {
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutTechnicalSkillsNestedInput
  }

  export type ResumeTechnicalSkillUncheckedUpdateWithoutSkillInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeTechnicalSkillUncheckedUpdateManyWithoutSkillInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobOfferTechnicalSkillUpdateWithoutTechnicalSkillInput = {
    jobOffer?: JobOfferUpdateOneRequiredWithoutTechnicalSkillsNestedInput
  }

  export type JobOfferTechnicalSkillUncheckedUpdateWithoutTechnicalSkillInput = {
    jobOfferId?: StringFieldUpdateOperationsInput | string
  }

  export type JobOfferTechnicalSkillUncheckedUpdateManyWithoutTechnicalSkillInput = {
    jobOfferId?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeLanguageCreateManyLanguageInput = {
    resumeOwnerEmail: string
    masteryLevel: number
    isVisible: boolean
  }

  export type ResumeLanguageUpdateWithoutLanguageInput = {
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    resume?: ResumeUpdateOneRequiredWithoutKnownLanguagesNestedInput
  }

  export type ResumeLanguageUncheckedUpdateWithoutLanguageInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResumeLanguageUncheckedUpdateManyWithoutLanguageInput = {
    resumeOwnerEmail?: StringFieldUpdateOperationsInput | string
    masteryLevel?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use JobOfferCountOutputTypeDefaultArgs instead
     */
    export type JobOfferCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobOfferCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractTypeCountOutputTypeDefaultArgs instead
     */
    export type ContractTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CareerCountOutputTypeDefaultArgs instead
     */
    export type CareerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CareerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlumniCountOutputTypeDefaultArgs instead
     */
    export type AlumniCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlumniCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResumeCountOutputTypeDefaultArgs instead
     */
    export type ResumeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResumeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CiapCourseCountOutputTypeDefaultArgs instead
     */
    export type CiapCourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CiapCourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoftSkillCountOutputTypeDefaultArgs instead
     */
    export type SoftSkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoftSkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillCategoryCountOutputTypeDefaultArgs instead
     */
    export type SkillCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TechnicalSkillCountOutputTypeDefaultArgs instead
     */
    export type TechnicalSkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TechnicalSkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageCountOutputTypeDefaultArgs instead
     */
    export type LanguageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobOfferDefaultArgs instead
     */
    export type JobOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobOfferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobOfferTechnicalSkillDefaultArgs instead
     */
    export type JobOfferTechnicalSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobOfferTechnicalSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractTypeDefaultArgs instead
     */
    export type ContractTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CareerDefaultArgs instead
     */
    export type CareerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CareerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlumniDefaultArgs instead
     */
    export type AlumniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlumniDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GraduationDefaultArgs instead
     */
    export type GraduationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GraduationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobApplicationDefaultArgs instead
     */
    export type JobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResumeDefaultArgs instead
     */
    export type ResumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResumeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CiapCourseDefaultArgs instead
     */
    export type CiapCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CiapCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResumeCiapCourseDefaultArgs instead
     */
    export type ResumeCiapCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResumeCiapCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SoftSkillDefaultArgs instead
     */
    export type SoftSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SoftSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResumeSoftSkillDefaultArgs instead
     */
    export type ResumeSoftSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResumeSoftSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillCategoryDefaultArgs instead
     */
    export type SkillCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TechnicalSkillDefaultArgs instead
     */
    export type TechnicalSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TechnicalSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResumeTechnicalSkillDefaultArgs instead
     */
    export type ResumeTechnicalSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResumeTechnicalSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageDefaultArgs instead
     */
    export type LanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResumeLanguageDefaultArgs instead
     */
    export type ResumeLanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResumeLanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortfolioItemDefaultArgs instead
     */
    export type PortfolioItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortfolioItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HigherEducationStudyDefaultArgs instead
     */
    export type HigherEducationStudyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HigherEducationStudyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PositionOfInterestDefaultArgs instead
     */
    export type PositionOfInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PositionOfInterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndustryOfInterestDefaultArgs instead
     */
    export type IndustryOfInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndustryOfInterestDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}